<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>edo.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/search.js"></script>
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.5/fuse.min.js"></script> -->
    <script src="scripts/fuse.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme.css">
    
    
    
<svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/>
                <path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/>
            </g>
        </symbol>
    </defs>
</svg>

</head>
<body>
<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html"><div class="text">Home</div></a></h2><div class="search-box"><input type="text" placeholder="Search..." id="search-box" /><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-list-div"><h3>Classes</h3><ul><li><a href="EDO.html">EDO</a><ul class='methods'><li data-type='method'><a href="EDO.html#scale">scale</a></li></ul></li><li><a href="Scale.html">Scale</a><ul class='methods'><li data-type='method'><a href="Scale.html#complement">complement</a></li><li data-type='method'><a href="Scale.html#invert">invert</a></li><li data-type='method'><a href="Scale.html#mode">mode</a></li><li data-type='method'><a href="Scale.html#normal">normal</a></li><li data-type='method'><a href="Scale.html#prime">prime</a></li></ul></li><li><a href="Time.html">Time</a></li></ul><h3>Namespaces</h3><ul><li><a href="EDO_convert.html">EDO#convert</a><ul class='methods'><li data-type='method'><a href="EDO_convert.html#.cents_to_ratio">cents_to_ratio</a></li><li data-type='method'><a href="EDO_convert.html#.interval_to_cents">interval_to_cents</a></li><li data-type='method'><a href="EDO_convert.html#.interval_to_ratio">interval_to_ratio</a></li><li data-type='method'><a href="EDO_convert.html#.intervals_to_pitches">intervals_to_pitches</a></li><li data-type='method'><a href="EDO_convert.html#.intervals_to_scale">intervals_to_scale</a></li><li data-type='method'><a href="EDO_convert.html#.midi_to_freq">midi_to_freq</a></li><li data-type='method'><a href="EDO_convert.html#.midi_to_intervals">midi_to_intervals</a></li><li data-type='method'><a href="EDO_convert.html#.midi_to_name">midi_to_name</a></li><li data-type='method'><a href="EDO_convert.html#.name_to_scale">name_to_scale</a></li><li data-type='method'><a href="EDO_convert.html#.pc_to_name">pc_to_name</a></li><li data-type='method'><a href="EDO_convert.html#.pitches_to_PCs">pitches_to_PCs</a></li><li data-type='method'><a href="EDO_convert.html#.ratio_to_cents">ratio_to_cents</a></li><li data-type='method'><a href="EDO_convert.html#.ratio_to_interval">ratio_to_interval</a></li><li data-type='method'><a href="EDO_convert.html#.to_steps">to_steps</a></li></ul></li><li><a href="EDO_count.html">EDO#count</a><ul class='methods'><li data-type='method'><a href="EDO_count.html#.common_tones">common_tones</a></li><li data-type='method'><a href="EDO_count.html#.differences">differences</a></li><li data-type='method'><a href="EDO_count.html#.pitches">pitches</a></li></ul></li><li><a href="EDO_export.html">EDO#export</a><ul class='methods'><li data-type='method'><a href="EDO_export.html#.png">png</a></li></ul></li><li><a href="EDO_get.html">EDO#get</a><ul class='methods'><li data-type='method'><a href="EDO_get.html#.angle">angle</a></li><li data-type='method'><a href="EDO_get.html#.combinations">combinations</a></li><li data-type='method'><a href="EDO_get.html#.complementary_interval">complementary_interval</a></li><li data-type='method'><a href="EDO_get.html#.complementary_set">complementary_set</a></li><li data-type='method'><a href="EDO_get.html#.contour">contour</a></li><li data-type='method'><a href="EDO_get.html#.contour_motives">contour_motives</a></li><li data-type='method'><a href="EDO_get.html#.coordinates">coordinates</a></li><li data-type='method'><a href="EDO_get.html#.fill_partial_harp_pedaling">fill_partial_harp_pedaling</a></li><li data-type='method'><a href="EDO_get.html#.generated_scale">generated_scale</a></li><li data-type='method'><a href="EDO_get.html#.generators">generators</a></li><li data-type='method'><a href="EDO_get.html#.harmonic_progression">harmonic_progression</a></li><li data-type='method'><a href="EDO_get.html#.harmonized_melody">harmonized_melody</a></li><li data-type='method'><a href="EDO_get.html#.harp_pedals_to_pitches">harp_pedals_to_pitches</a></li><li data-type='method'><a href="EDO_get.html#.harp_position_of_quality">harp_position_of_quality</a></li><li data-type='method'><a href="EDO_get.html#.intersection">intersection</a></li><li data-type='method'><a href="EDO_get.html#.interval_stack">interval_stack</a></li><li data-type='method'><a href="EDO_get.html#.interval_traversed">interval_traversed</a></li><li data-type='method'><a href="EDO_get.html#.inversion">inversion</a></li><li data-type='method'><a href="EDO_get.html#.lattice">lattice</a></li><li data-type='method'><a href="EDO_get.html#.levenshtein">levenshtein</a></li><li data-type='method'><a href="EDO_get.html#.maximal_carey_coherence_failures">maximal_carey_coherence_failures</a></li><li data-type='method'><a href="EDO_get.html#.maximal_rahn_difference">maximal_rahn_difference</a></li><li data-type='method'><a href="EDO_get.html#.minimal_voice_leading">minimal_voice_leading</a></li><li data-type='method'><a href="EDO_get.html#.modes">modes</a></li><li data-type='method'><a href="EDO_get.html#.motives">motives</a></li><li data-type='method'><a href="EDO_get.html#.necklace">necklace</a></li><li data-type='method'><a href="EDO_get.html#.new_pitches">new_pitches</a></li><li data-type='method'><a href="EDO_get.html#.ngrams">ngrams</a></li><li data-type='method'><a href="EDO_get.html#.normal_order">normal_order</a></li><li data-type='method'><a href="EDO_get.html#.partitioned_subsets">partitioned_subsets</a></li><li data-type='method'><a href="EDO_get.html#.path_n_steps">path_n_steps</a></li><li data-type='method'><a href="EDO_get.html#.path_on_tree">path_on_tree</a></li><li data-type='method'><a href="EDO_get.html#.permutations">permutations</a></li><li data-type='method'><a href="EDO_get.html#.pitch_distribution">pitch_distribution</a></li><li data-type='method'><a href="EDO_get.html#.pitch_fields">pitch_fields</a></li><li data-type='method'><a href="EDO_get.html#.random_melody">random_melody</a></li><li data-type='method'><a href="EDO_get.html#.random_melody_from_contour">random_melody_from_contour</a></li><li data-type='method'><a href="EDO_get.html#.random_melody_from_distribution">random_melody_from_distribution</a></li><li data-type='method'><a href="EDO_get.html#.random_melody_from_ngram">random_melody_from_ngram</a></li><li data-type='method'><a href="EDO_get.html#.ratio_approximation">ratio_approximation</a></li><li data-type='method'><a href="EDO_get.html#.retrograde">retrograde</a></li><li data-type='method'><a href="EDO_get.html#.rotated">rotated</a></li><li data-type='method'><a href="EDO_get.html#.rotations">rotations</a></li><li data-type='method'><a href="EDO_get.html#.scalar_melodies">scalar_melodies</a></li><li data-type='method'><a href="EDO_get.html#.scales">scales</a></li><li data-type='method'><a href="EDO_get.html#.shortest_path">shortest_path</a></li><li data-type='method'><a href="EDO_get.html#.simple_ratios">simple_ratios</a></li><li data-type='method'><a href="EDO_get.html#.stacked">stacked</a></li><li data-type='method'><a href="EDO_get.html#.starting_at">starting_at</a></li><li data-type='method'><a href="EDO_get.html#.subset_indices">subset_indices</a></li><li data-type='method'><a href="EDO_get.html#.subsets">subsets</a></li><li data-type='method'><a href="EDO_get.html#.transposition">transposition</a></li><li data-type='method'><a href="EDO_get.html#.union">union</a></li><li data-type='method'><a href="EDO_get.html#.unique_elements">unique_elements</a></li><li data-type='method'><a href="EDO_get.html#.well_formed_scale">well_formed_scale</a></li><li data-type='method'><a href="EDO_get.html#.without">without</a></li><li data-type='method'><a href="EDO_get.html#.without_chromatic_notes">without_chromatic_notes</a></li></ul></li><li><a href="EDO_is.html">EDO#is</a><ul class='methods'><li data-type='method'><a href="EDO_is.html#.element_of">element_of</a></li><li data-type='method'><a href="EDO_is.html#.rotation">rotation</a></li><li data-type='method'><a href="EDO_is.html#.same">same</a></li><li data-type='method'><a href="EDO_is.html#.subset">subset</a></li><li data-type='method'><a href="EDO_is.html#.transposition">transposition</a></li></ul></li><li><a href="EDO_midi.html">EDO#midi</a><ul class='methods'><li data-type='method'><a href="EDO_midi.html#.chordify">chordify</a></li><li data-type='method'><a href="EDO_midi.html#.import">import</a></li><li data-type='method'><a href="EDO_midi.html#.strip">strip</a></li></ul></li><li><a href="EDO_show.html">EDO#show</a><ul class='methods'><li data-type='method'><a href="EDO_show.html#.contour">contour</a></li><li data-type='method'><a href="EDO_show.html#.interval_fractal_tree">interval_fractal_tree</a></li><li data-type='method'><a href="EDO_show.html#.necklace">necklace</a></li><li data-type='method'><a href="EDO_show.html#.necklace_fractal">necklace_fractal</a></li><li data-type='method'><a href="EDO_show.html#.nested_necklaces">nested_necklaces</a></li></ul></li><li><a href="EDO_xml.html">EDO#xml</a></li><li><a href="Scale_count.html">Scale#count</a><ul class='methods'><li data-type='method'><a href="Scale_count.html#.chord_quality">chord_quality</a></li><li data-type='method'><a href="Scale_count.html#.consecutive_steps">consecutive_steps</a></li><li data-type='method'><a href="Scale_count.html#.imperfections">imperfections</a></li><li data-type='method'><a href="Scale_count.html#.interval">interval</a></li><li data-type='method'><a href="Scale_count.html#.M3s">M3s</a></li><li data-type='method'><a href="Scale_count.html#.m3s">m3s</a></li><li data-type='method'><a href="Scale_count.html#.major_minor_triads">major_minor_triads</a></li><li data-type='method'><a href="Scale_count.html#.modes">modes</a></li><li data-type='method'><a href="Scale_count.html#.P5s">P5s</a></li><li data-type='method'><a href="Scale_count.html#.pitches">pitches</a></li><li data-type='method'><a href="Scale_count.html#.rahn_ambiguities">rahn_ambiguities</a></li><li data-type='method'><a href="Scale_count.html#.rahn_contradictions">rahn_contradictions</a></li><li data-type='method'><a href="Scale_count.html#.rahn_differences">rahn_differences</a></li><li data-type='method'><a href="Scale_count.html#.ratio">ratio</a></li><li data-type='method'><a href="Scale_count.html#.rotational_symmetries">rotational_symmetries</a></li><li data-type='method'><a href="Scale_count.html#.simple_ratios">simple_ratios</a></li><li data-type='method'><a href="Scale_count.html#.tetrachords">tetrachords</a></li><li data-type='method'><a href="Scale_count.html#.thirds">thirds</a></li><li data-type='method'><a href="Scale_count.html#.transpositions">transpositions</a></li><li data-type='method'><a href="Scale_count.html#.trichords">trichords</a></li></ul></li><li><a href="Scale_export.html">Scale#export</a><ul class='methods'><li data-type='method'><a href="Scale_export.html#.scala">scala</a></li></ul></li><li><a href="Scale_get.html">Scale#get</a><ul class='methods'><li data-type='method'><a href="Scale_get.html#.area">area</a></li><li data-type='method'><a href="Scale_get.html#.chord_quality_from_shape">chord_quality_from_shape</a></li><li data-type='method'><a href="Scale_get.html#.coherence_quotient">coherence_quotient</a></li><li data-type='method'><a href="Scale_get.html#.common_tone_transpositions">common_tone_transpositions</a></li><li data-type='method'><a href="Scale_get.html#.complement">complement</a></li><li data-type='method'><a href="Scale_get.html#.coordinates">coordinates</a></li><li data-type='method'><a href="Scale_get.html#.generic_intervals">generic_intervals</a></li><li data-type='method'><a href="Scale_get.html#.interval_class">interval_class</a></li><li data-type='method'><a href="Scale_get.html#.interval_vector">interval_vector</a></li><li data-type='method'><a href="Scale_get.html#.inversion">inversion</a></li><li data-type='method'><a href="Scale_get.html#.least_step_multiplier">least_step_multiplier</a></li><li data-type='method'><a href="Scale_get.html#.lerdahl_attraction">lerdahl_attraction</a></li><li data-type='method'><a href="Scale_get.html#.lerdahl_attraction_vector">lerdahl_attraction_vector</a></li><li data-type='method'><a href="Scale_get.html#.levenshtein">levenshtein</a></li><li data-type='method'><a href="Scale_get.html#.modes">modes</a></li><li data-type='method'><a href="Scale_get.html#.motives_diatonic">motives_diatonic</a></li><li data-type='method'><a href="Scale_get.html#.n_choose_k">n_choose_k</a></li><li data-type='method'><a href="Scale_get.html#.n_chords">n_chords</a></li><li data-type='method'><a href="Scale_get.html#.n_chords_diatonic">n_chords_diatonic</a></li><li data-type='method'><a href="Scale_get.html#.name">name</a></li><li data-type='method'><a href="Scale_get.html#.normal_order">normal_order</a></li><li data-type='method'><a href="Scale_get.html#.pairwise_generic_specific_intervals">pairwise_generic_specific_intervals</a></li><li data-type='method'><a href="Scale_get.html#.permutations">permutations</a></li><li data-type='method'><a href="Scale_get.html#.pitches">pitches</a></li><li data-type='method'><a href="Scale_get.html#.position_of_quality">position_of_quality</a></li><li data-type='method'><a href="Scale_get.html#.prime_form">prime_form</a></li><li data-type='method'><a href="Scale_get.html#.product">product</a></li><li data-type='method'><a href="Scale_get.html#.quality_with_intervals">quality_with_intervals</a></li><li data-type='method'><a href="Scale_get.html#.resize_melody">resize_melody</a></li><li data-type='method'><a href="Scale_get.html#.rotations">rotations</a></li><li data-type='method'><a href="Scale_get.html#.rothenberg_propriety">rothenberg_propriety</a></li><li data-type='method'><a href="Scale_get.html#.roughness">roughness</a></li><li data-type='method'><a href="Scale_get.html#.sameness_quotient">sameness_quotient</a></li><li data-type='method'><a href="Scale_get.html#.scale_degree_roles">scale_degree_roles</a></li><li data-type='method'><a href="Scale_get.html#.scale_degree_transpositions">scale_degree_transpositions</a></li><li data-type='method'><a href="Scale_get.html#.segments">segments</a></li><li data-type='method'><a href="Scale_get.html#.sequence_transposition">sequence_transposition</a></li><li data-type='method'><a href="Scale_get.html#.shortest_path">shortest_path</a></li><li data-type='method'><a href="Scale_get.html#.sine_pair_dissonance">sine_pair_dissonance</a></li><li data-type='method'><a href="Scale_get.html#.specific_intervals">specific_intervals</a></li><li data-type='method'><a href="Scale_get.html#.stacks">stacks</a></li><li data-type='method'><a href="Scale_get.html#.step_sizes">step_sizes</a></li><li data-type='method'><a href="Scale_get.html#.steps_to_qualities">steps_to_qualities</a></li><li data-type='method'><a href="Scale_get.html#.supersets">supersets</a></li><li data-type='method'><a href="Scale_get.html#.tetrachords">tetrachords</a></li><li data-type='method'><a href="Scale_get.html#.transposition">transposition</a></li><li data-type='method'><a href="Scale_get.html#.transpositions_with_pitches">transpositions_with_pitches</a></li><li data-type='method'><a href="Scale_get.html#.trichords">trichords</a></li><li data-type='method'><a href="Scale_get.html#.without">without</a></li></ul></li><li><a href="Scale_is.html">Scale#is</a><ul class='methods'><li data-type='method'><a href="Scale_is.html#.deep">deep</a></li><li data-type='method'><a href="Scale_is.html#.distributionally_even">distributionally_even</a></li><li data-type='method'><a href="Scale_is.html#.in_lower_edos">in_lower_edos</a></li><li data-type='method'><a href="Scale_is.html#.invertible">invertible</a></li><li data-type='method'><a href="Scale_is.html#.maximally_even">maximally_even</a></li><li data-type='method'><a href="Scale_is.html#.mode_of">mode_of</a></li><li data-type='method'><a href="Scale_is.html#.MOLT">MOLT</a></li><li data-type='method'><a href="Scale_is.html#.myhill_property">myhill_property</a></li><li data-type='method'><a href="Scale_is.html#.normal_order">normal_order</a></li><li data-type='method'><a href="Scale_is.html#.one_of">one_of</a></li><li data-type='method'><a href="Scale_is.html#.prime_form">prime_form</a></li><li data-type='method'><a href="Scale_is.html#.subset">subset</a></li></ul></li><li><a href="Scale_show.html">Scale#show</a><ul class='methods'><li data-type='method'><a href="Scale_show.html#.interval_fractal_tree">interval_fractal_tree</a></li><li data-type='method'><a href="Scale_show.html#.necklace">necklace</a></li></ul></li><li><a href="Scale_to.html">Scale#to</a><ul class='methods'><li data-type='method'><a href="Scale_to.html#.cents">cents</a></li><li data-type='method'><a href="Scale_to.html#.steps">steps</a></li></ul></li><li><a href="Time_convert.html">Time#convert</a><ul class='methods'><li data-type='method'><a href="Time_convert.html#.beats_to_msec">beats_to_msec</a></li><li data-type='method'><a href="Time_convert.html#.beats_to_ratios">beats_to_ratios</a></li><li data-type='method'><a href="Time_convert.html#.beats_to_tempo">beats_to_tempo</a></li></ul></li><li><a href="Time_get.html">Time#get</a><ul class='methods'><li data-type='method'><a href="Time_get.html#.beat">beat</a></li><li data-type='method'><a href="Time_get.html#.counterpoint_cycle">counterpoint_cycle</a></li><li data-type='method'><a href="Time_get.html#.explicit">explicit</a></li><li data-type='method'><a href="Time_get.html#.fractal">fractal</a></li><li data-type='method'><a href="Time_get.html#.motives">motives</a></li><li data-type='method'><a href="Time_get.html#.ratios">ratios</a></li><li data-type='method'><a href="Time_get.html#.relational_motives">relational_motives</a></li><li data-type='method'><a href="Time_get.html#.repeated">repeated</a></li><li data-type='method'><a href="Time_get.html#.subdivisions">subdivisions</a></li></ul></li><li><a href="Time_resize.html">Time#resize</a><ul class='methods'><li data-type='method'><a href="Time_resize.html#.by_product">by_product</a></li><li data-type='method'><a href="Time_resize.html#.by_sum">by_sum</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3><ul><li><a href="global.html#environment">environment</a></li><li><a href="global.html#myhill_property">myhill_property</a></li></ul></div>
</nav>

<div id="main">
    
    <h1 class="page-title">edo.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @author Michael Seltenreich &lt;seltenmusic@gmail.com>
 * @version 1.2.0
 * @license
 * &lt;pre>Copyright 2020 Michael Seltenreich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.&lt;/pre>*/



const environment = (typeof window === 'undefined') ? "server" : "browser"

let fs, parseXML, midiParser
if (environment == 'server') {
    fs = require('fs')
    parseXML = require('xml2js').parseString;
    midiParser = require('midi-parser-js');

}


let save_file
if (environment == 'server') {
    /**
     * @ignore*/
    save_file = function (name, dir, contents, _unused) {
        fs.writeFile(dir + name, contents, function (err) {
            if (err) {
                return console.log(err);
            }
        });

    }

} else {
    /**
     * Handles file saving when run client-side
     * @ignore
     * */
    save_file = function (name, dir, contents, mime_type = "text/plain") {

        const blob = new Blob([contents], {type: mime_type});

        const dlink = document.createElement('a');
        dlink.download = name;
        dlink.href = window.URL.createObjectURL(blob);
        dlink.onclick = function (e) {
            // revokeObjectURL needs a delay to work properly
            setTimeout(() => {
                window.URL.revokeObjectURL(this.href);
            }, 1500);
        };

        dlink.click();
        dlink.remove();
    }

}

let load_file
if (environment == 'server') {
    /**
     * Handles file loading when run server-side
     * @ignore
     * */
    /**
     * @ignore*/
    load_file = function (file) {
        return fs.readFileSync(file,
            // {encoding:'utf8', flag:'r'}
        );

    }

} else {

    /**
     * Handles file saving when run client-side
     * @ignore
     * */
    load_file = function (name, dir, contents) {
        var fileSelector = document.createElement('input');
        fileSelector.setAttribute('type', 'file');

        var selectDialogueLink = document.createElement('a');
        selectDialogueLink.setAttribute('href', '');
        selectDialogueLink.innerText = "Select File";

        selectDialogueLink.onclick = function () {
            fileSelector.click();
            return false;
        }
        selectDialogueLink.click()
    }

}


class FixedContentNecklace {
    constructor(number_list) {
        /*
        Class FixedContentNecklace Init Method

            :param number_list: A list of integers

        */
        // Force negative numbers to zero
        for (let i = 0; i &lt; number_list.length; i++) {
            if (number_list[i] &lt; 0) number_list[i] = 0
        }
        this.n_init = number_list
        this.N = number_list.reduce((t, n) => n + t)
        this.k = number_list.length
        this.initialize()
    }

    initialize(method = 'simple') {
        /*
        Determines what method algorithm to use in the generation

            :param method: The name of the method/algorithm to use
        */
        this.occurrence = [...this.n_init]
        this.word = Array(this.N).fill(0)
        this.alphabet = Array(this.k).fill(0)
        this.alphabet = this.alphabet.map((el, i, arr) => i)
        this.run = Array(this.N).fill(0)
        this.first_letter = 0
        this.last_letter = this.k - 1


        this.__set_letter_bounds(method)

        if (method != 'simple') {
            this.word = [this.word[0]].concat(Array(this.N - 1).fill(this.last_letter))
        }

    }

    __set_letter_bounds(method) {
        /*
        Assign the first letter with nonzero occurrence to word[0], short-circuiting the search to the
        letter to put there during the algorithm, and finds the last nonzero letter

            :param method: The name of the method/algorithm to use

        */
        let found_first_nonzero = false
        for (let letter = 0; letter &lt; this.k; letter++) {
            if (!found_first_nonzero &amp;&amp; this.occurrence[letter] > 0) {
                found_first_nonzero = true
                this.occurrence[letter] -= 1
                this.word[0] = letter
                this.first_letter = letter
            }

            // remove any letters with zero occurrence from the alphabet so that
            // we automatically skip them
            if (method != 'simple') {
                if (this.occurrence[letter] == 0) {
                    this.__remove_letter(letter)
                }
            }
        }
        this.last_letter = (!this.alphabet) ? 0 : Math.max.apply(Math, this.alphabet)
    }

    * execute(method = "simple") {
        /*
        Runs the algorithm that's passed to `method`

        :param method: The method/algorithm to execute

        */


        this.initialize(method)
        if (method == 'simple') {
            yield* this._simple_fixed_content(2, 1)
        } else if (method == 'fast') {
            yield* this._fast_fixed_content(2, 1, 2)
        }


    }

    * _simple_fixed_content(t, p) {
        /*
        The simple algorithm

        :param t: ?
        :param p: ?

        */
        if (t > this.N) { // if the prenecklace is complete
            if (this.N % p == 0) { // if the prenecklace word is a necklace
                yield [...this.word]
            }
        } else {
            for (let letter = this.word[t - p - 1]; letter &lt; this.k; letter++) {
                if (this.occurrence[letter] > 0) {
                    this.word[t - 1] = letter
                    this.occurrence[letter] -= 1
                    if (letter == this.word[t - p - 1]) {
                        yield* this._simple_fixed_content(t + 1, p)
                    } else {
                        yield* this._simple_fixed_content(t + 1, t)
                    }
                    this.occurrence[letter] += 1
                }
            }
        }
    }

    * _fast_fixed_content(t, p, s) {
        let i_removed
        /*
        The fast algorithm
        */
        if (this.occurrence[this.last_letter] == this.N - t + 1) {
            if (this.occurrence[this.last_letter] == this.run[t - p - 1]) {
                if (this.N % p == 0) {
                    yield [...this.word]
                }
            } else if (this.occurrence[this.last_letter] > this.run[t - p - 1]) {
                yield [...this.word]
            }
        } else if (this.occurrence[this.first_letter] != this.N - t + 1) {
            let letter = Math.max.apply(Math, this.alphabet)
            let i = this.alphabet.length - 1
            let s_current = s
            while (letter >= this.word[t - p - 1]) {
                this.run[parseInt(s - 1)] = parseInt(t - s)
                this.word[t - 1] = letter
                this.occurrence[letter] -= 1
                if (!this.occurrence[letter]) {
                    i_removed = this.__remove_letter(letter)
                }
                if (letter != this.last_letter) {
                    s_current = t + 1
                }
                if (letter == this.word[t - p - 1]) {
                    yield* this._fast_fixed_content(t + 1, p, s_current)
                } else {
                    yield* this._fast_fixed_content(t + 1, t, s_current)
                }
                if (!this.occurrence[letter]) {
                    this.__add_letter(i_removed, letter)
                }
                this.occurrence[letter] += 1
                i -= 1
                letter = this.__get_letter(i)
            }
            this.word[t - 1] = this.last_letter
        }
    }

    __remove_letter(letter) {
        let index = this.alphabet.indexOf(letter)
        this.alphabet.splice(index, 1)
        return index
    }

    __add_letter(index, letter) {
        this.alphabet.splice(index, 0, letter)
    }

    __get_letter(index) {
        return (index &lt; 0) ? -1 : this.alphabet[index]
    }
}

const combinations = (set, k) => {
    if (k > set.length || k &lt;= 0) {
        return []
    }

    if (k == set.length) {
        return [set]
    }

    if (k == 1) {
        return set.reduce((acc, cur) => [...acc, [cur]], [])
    }

    let combs = [], tail_combs = []

    for (let i = 0; i &lt;= set.length - k + 1; i++) {
        tail_combs = combinations(set.slice(i + 1), k - 1)
        for (let j = 0; j &lt; tail_combs.length; j++) {
            combs.push([set[i], ...tail_combs[j]])
        }
    }

    return combs
}


const rescale = (num, in_min, in_max, out_min, out_max) => {
    return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
const GCD = (...n) => n.length === 2 ? n[1] ? GCD(n[1], n[0] % n[1]) : n[0] : n.reduce((a, c) => a = GCD(a, c));

/** Class representing some EDO tuning system.*/

class EDO {

    /**
     * &lt;p>Creates a tuning context and system that exposes powerful functions for manipulating, analyzing, and generating music.&lt;/p>
     * &lt;p>This is the main class of the project. At its center stand 7 collections (see "Namespaces" below) of functions.&lt;/p>
     * &lt;ul>
     *  &lt;li> [EDO.convert]{@link EDO#convert} is a set of functions used to change between equivalent representations within the tuning context.&lt;/li>
     *  &lt;li> [EDO.count]{@link EDO#count} is a set of functions used to count stuff.&lt;/li>
     *  &lt;li> [EDO.get]{@link EDO#get} is a set of functions used to manipulate and generate stuff.&lt;/li>
     *  &lt;li> [EDO.is]{@link EDO#is} is a set of functions used for boolean truth statements.&lt;/li>
     *  &lt;li> [EDO.show]{@link EDO#show} is a set of functions used for visualization.&lt;/li>
     *  &lt;li> [EDO.midi]{@link EDO#midi} is a set of functions used for importing and processing midi files.&lt;/li>
     *  &lt;li> [EDO.xml]{@link EDO#xml} is a set of functions used for importing and processing musicXML files.&lt;/li>
     *  &lt;li> [EDO.export]{@link EDO#export} is a set of functions used for exporting the output to various formats.&lt;/li>
     *  &lt;/ul>
     * @param {number} edo - The number of equal divisions of the octave.
     * @example
     * //Basic usage:
     * let edo = new EDO(12) //create a new EDO context with 12 divisions.
     *
     * //once the object has been created, you can access its functions.
     * edo.get.inversion([0,2,4,5,7,9,11]) //inverts the pitches
     * //returns [0, 2,  4, 6, 7, 9, 11]
     *
     * edo.convert.ratio_to_interval(3/2)
     * //returns [7]
     *
     * edo.count.pitches([0, 3, 3, 2, 4, 3, 4])
     * //returns [[3,3],[4,2], [2,1], [0,1]] (3 appears 3 times, 4 appears 2 times, etc.)
     *
     * edo.is.subset([2,4],[1,2,3,4,5])
     * //returns true (the set [2,4] IS a subset of [1,2,3,4,5])
     */
    constructor(edo = 12) {
        this.edo = edo
        this.cents_per_step = (12 / edo) * 100
        this.M3s = this.convert.ratio_to_interval(5 / 4, 20)
        this.m3s = this.convert.ratio_to_interval(6 / 5, 20)
        this.P5s = this.convert.ratio_to_interval(3 / 2, 5)
        this.edo_divisors = this.get.divisors(edo)
        this.catalog = {}

    }

    /**
     * Returns a new Scale Object with given pitches
     * @param  {Array&lt;Number>} pitches - a collection of pitch classes
     * @return {Scale}
     */
    scale(pitches) {
        return new Scale(pitches, this)
    }

    make_DOM_svg(container_id, width, height, clean = false) {
        let div = document.createElement('div')
        div.style.width = width + "px";
        div.style.height = height + "px";
        div.style.display = "inline"
        let div_id = div.setAttribute("id", "paper_" + Date.now());
        let container = document.getElementById(container_id)
        if (clean) container.innerHTML = ""
        container.appendChild(div)
        const paper = new Raphael(div, width, height);
        let background = paper.rect(0, 0, width, height).attr('fill', '#000000')
        return {
            div_id: div_id,
            div: div,
            container_id: container_id,
            container: container,
            paper: paper,
            background: background,
            width: width,
            height: height,
            cleaned: clean
        }
    }

    shuffle_array(arr_in, in_place = true) {
        let arr
        if (in_place) arr = arr_in
        else arr = [...arr_in]
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * i)
            const temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
        }
        return arr
    }

    sort_scales = (scales) => {
        scales = scales.sort((a, b) => {
            let run = Math.min(a.pitches.length, b.pitches.length)
            for (let i = 0; i &lt; run; i++) {
                if (a.pitches[i] != b.pitches[i]) return a.pitches[i] - b.pitches[i]
                else if (a.pitches[i] == b.pitches[i] &amp;&amp; i == run - 1) return a.pitches.length - b.pitches.length
            }
        })
        return scales
    }



    /**A collection of functions that convert an input into other equivalent representations
     * @namespace EDO#convert*/
    convert = {

        /** Returns a ratio as a decimal number from an interval represented in cents
         *
         * @param  {Number} cents - an interval in cents
         * @returns {Number} a ratio
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system with 12 divisions of the octave
         * edo.convert.cents_to_ratio(700)
         * // returns 1.4983070768766815*/
        cents_to_ratio: (cents) => {
            return Math.pow(2, cents / 1200)
        },

        /** Returns a value in cents from a given interval
         *
         * @param  {Number} interval - Some interval
         * @returns {Number} the interval represented in cents
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(17) // define a tuning with 17 divisions of the octave
         * edo.convert.interval_to_cents(6)
         * //returns 423.5294117647059*/
        interval_to_cents: (interval) => {
            return this.cents_per_step * interval
        },

        /** Returns a ratio as a decimal number from a given interval
         *
         * @param  {Number|Array&lt;Number>} interval - Some interval
         * @returns {Number} a ratio
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system with 12 divisions of the octave
         * edo.convert.interval_to_ratio(7)
         * // returns 1.4983070768766815*/
        interval_to_ratio: (interval) => {
            if(Array.isArray(interval)) return interval.map(i=>this.convert.interval_to_ratio(i))
            return Math.pow(2, interval / this.edo)

        },

        /** Given a list of intervals (or list of lists), returns pitches made with the intervals
         * starting from starting_pitch
         * @param  {Array&lt;Number>|Array&lt;Array&lt;Number>>} intervals - a list of intervals
         * @param  {Number} [starting_pitch=0]
         * @param  {Boolean} [modulo] if modulo is provided, the pitches will conform to it
         * @returns {Array&lt;Number>|Array&lt;Array&lt;Number>>} The input as pitches
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system with 12 divisions of the octave
         * edo.convert.intervals_to_pitches([2,3])
         * //returns [ 0, 2, 5 ]*/
        intervals_to_pitches: (intervals, starting_pitch = 0, modulo = undefined) => {
            let pitches
            if (modulo) pitches = [mod(starting_pitch, modulo)]
            else pitches = [starting_pitch]
            for (let interval of intervals) {
                if (Array.isArray(interval)) {
                    starting_pitch = pitches.flat()[pitches.flat().length - 1]
                    let result = this.convert.intervals_to_pitches(interval, starting_pitch)
                    result = result.slice(1)
                    pitches.push(result)
                } else {
                    if (modulo) pitches.push(mod(parseInt(pitches[pitches.length - 1]) + parseInt(interval)), modulo)
                    else pitches.push(parseInt(pitches[pitches.length - 1]) + parseInt(interval))
                }
            }
            return pitches
        },

        /** Gets a list of intervals classes. Returns a scale as list of pitch classes.
         *
         * @param  {Array&lt;Number>} intervals - A list of intervals
         * @example
         * let edo = new EDO(12) // define a tuning system with 12 divisions of the octave
         * edo.convert.intervals_to_scale([2, 2, 1, 2, 2, 2, 1])
         * // returns [0,2,4,5,7,9,11]
         * @returns {Number} A scale made up by adding the intervals in order
         * @memberOf EDO#convert*/
        intervals_to_scale: (intervals) => {
            let pcs = [0]

            intervals.forEach((interval) => {
                pcs.push(interval + pcs[pcs.length - 1])
            })
            return pcs
        },

        /** Given a list of midi notes, returns a list of intervals
         * @param  {Array&lt;Number>} midi - a list of midi pitches
         * @returns {Array&lt;Number>} The input as intervals
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system with 12 divisions of the octave
         * edo.convert.midi_to_intervals([60,64,57,61])
         * //returns [ 4, -7, 4 ]*/
        midi_to_intervals: (midi) => {
            let intervals = []
            for (let i = 0; i &lt; midi.length - 1; i++) {
                intervals.push(midi[i + 1] - midi[i])
            }
            return intervals
        },

        /** Returns the name of the note (including octave) from a midi value
         * @param  {Array&lt;Number>|Number} note_number - a midi note number or an array of midi note numbers
         * @param  {Number} offset - an amount by which to shift note_number
         * @example
         * let edo = new EDO(12) // define a tuning system with 12 divisions of the octave
         * edo.convert.midi_to_name([60,62])
         * //returns ["C4","D4"]
         * @returns {Array&lt;String>|String} The input as note name(s)
         * @memberOf EDO#convert*/
        midi_to_name: (note_number, offset = 0) => {
            /*Given a midi note code as an integer, returns its note name and octave disposition (e.g C4 for 60).*/

            //only supports 12 edo, so it returns the input if in other edo
            if (this.edo != 12) return note_number

            //If it's an array of notes
            if (Array.isArray(note_number)) {
                return note_number.map((a) => this.convert.midi_to_name(a, offset))
            } else {
                note_number = note_number + offset
                let octave = Math.floor(note_number / 12) - 1
                let note_name = this.convert.pc_to_name(this.mod(note_number, 12))
                return note_name.trim() + octave
            }


        },

        /** Returns the frequency of the midi note
         * @param  {Array&lt;Number>|Number} note_number - a midi note number or an array of midi note numbers
         * @param  {Number} [offset=0] - By how much to offset every given number
         * @param  {Number} [A=440] - What is the tuning of A
         * @example
         * let edo = new EDO(12) // define a tuning system with 12 divisions of the octave
         * edo.convert.midi_to_freq(69) //returns 440
         * edo.convert.midi_to_freq([69,70]) //returns [ 440, 466.1637615180899 ]
         * @returns {Array&lt;Number>|Number} the frequency of the midi note
         * @memberOf EDO#convert*/
        midi_to_freq: (midi,offset=0,A=440) => {
            if(Array.isArray(midi)) return midi.map(n=>this.convert.midi_to_freq(n,offset,A))
            else return Math.pow(2,((midi+offset)-69)/12)*A
        },


        /** Gets a scale's name, and returns it as a Scale object
         *
         * @param  {String} name - a scale's name (based on this API's naming formula)
         * @returns {Scale} a scale object
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.convert.name_to_scale('12-1387')
         * //returns Scale object corresponding to the diatonic scale*/
        name_to_scale: (name) => {
            name = name.split('-')
            let edo = name[0]
            name = name[1]
            if (edo != this.edo) return "Wrong edo"

            let vector = []
            for (let i = edo; i > 0; i--) {
                let nw = Math.pow(2, i)
                if (nw > name) continue
                vector.push(i)
                name -= nw
            }
            vector.push(0)
            vector.reverse()
            return this.scale(vector)
        },

        /** Returns the name of a note from a given pitch class (supports only 12-edo)
         * @param  {Number | Array&lt;Number>} pc - a pitch class
         * @returns {String} The input as a note name
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system with 12 divisions of the octave
         * edo.convert.midi_to_name(4)
         * //returns "E"
         * */
        pc_to_name: (pc) => {
            let PC = {
                0: 'C ',
                1: 'C#',
                2: 'D ',
                3: 'Eb',
                4: 'E ',
                5: 'F ',
                6: 'F#',
                7: 'G ',
                8: 'Ab',
                9: 'A ',
                10: 'Bb',
                11: 'B ',
                '*': '**'
            }
            if (this.edo != 12) return pc
            if(Array.isArray(pc)) return pc.map(p=>this.convert.pc_to_name(p))
            return PC[pc]
        },

        /** Normalizes any input to include PC only (to ignore octave displacement)
         * @param  {Array&lt;Number>} pitches - any collection of pitches (e.g. a melody)
         * @returns {Array&lt;Number>} the input as pitch classes
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system with 12 divisions of the octave
         * edo.convert.pitches_to_PCs([0,2,12,-2,7])
         * //returns [0,2,0,10,7]
         * */
        pitches_to_PCs: (pitches) => {
            return pitches.map((pitch) => this.mod(pitch, this.edo))
        },

        /** Returns a value in cents to a given input ratio
         *
         * @param  {Number} ratio - A harmonic ratio
         * @returns {Number} The ratio represented in cents
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.convert.ratio_to_cents(5/4)
         * //returns 386.3137138648348*/
        ratio_to_cents: (ratio) => {
            return 1200 * Math.log2(ratio)
        },

        /** Returns all of the IC in the EDO that equal to a given ratio (with a given tolerance in cents)
         *
         * @param  {Number} ratio - A harmonic ratio
         * @param  {Number} [tolerance=10] - a tolerance (allowed error) in cents
         * @returns {Array&lt;Number>} Interval classes that fit that ratio
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.convert.ratio_to_interval(3/2)
         * //[7]
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.convert.ratio_to_interval(5/4,20) //increased the default tolerance (default 10 won't accept IC 4)
         * //returns [4]
         * */
        ratio_to_interval: (ratio, tolerance = 10) => {
            let intervals = []
            let cents = this.convert.ratio_to_cents(ratio)
            for (let i = 0; i &lt; this.edo; i++) {
                let interval = this.convert.interval_to_cents(i)
                if (Math.abs(interval - cents) &lt;= tolerance) intervals.push(i)
                else if (intervals.length > 0) break
            }
            return intervals
        },

        /** Gets a melody as pitches and returns the melody as intervals
         *
         * @param  {Array&lt;number>} lst - a collection of pitches
         * @param  {Boolean} [cache=false] - when true the result is cached for faster future retrieval
         * @returns {Array&lt;Number>} an array of intervals
         * @memberOf EDO#convert
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.convert.to_steps([0,2,4,5,7,9,11])
         * //returns [ 2, 2, 1, 2, 2, 2 ]*/
        to_steps: (lst, cache = false) => {
            if (!this.catalog[String(lst)]) this.catalog[String(lst)] = {}
            if (this.catalog[String(lst)]['steps']) return this.catalog[String(lst)]['steps']

            let s = [...lst]
            let intervals = []
            for (let i = 0; i &lt; s.length - 1; i++) {
                intervals.push(s[i + 1] - s[i])
            }
            if (cache) this.catalog[String(lst)]['steps'] = intervals
            return intervals
        }

    }

    /**A collection of functions that return an amount
     * @namespace EDO#count*/
    count = {
        /**
         * Returns the number of commons tones between two collections of pitches
         * @param  {Array&lt;Number>} list1 - a collection of pitches (not necessarily pitch classes)
         * @param  {Array&lt;Number>} list2 - a collection of pitches (not necessarily pitch classes)
         * @return {Number} The number of common tones between the two lists
         * @memberOf EDO#count
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.count.common_tones([1,2,4],[2,3,4,5])
         * //returns 2 (because 2 and 4 are in both lists)
         */
        common_tones: (list1, list2) => {

            return list1.reduce((ag,e)=>ag+ list2.includes(e),0)
        },

        /**
         * From a list of arrays passed to the function, returns the number of differences between each array and its following neighbor.
         * @param  {Array&lt;Number>} ...args - As many arrays as needed.
         * @return {Number} The number of differences between neighboring arrays
         * @memberOf EDO#count
         * @example
         * let edo = new EDO()
         * edo.count.differences([0,2,3],[0,1,2],[0,2,4],[0,2,1,1,1])
         * // returns [2,2,3] (2 differences between the 1st and 2nd arrays, 2 diffs between the 2nd and 3rd, and 3 diffs between the 3rd and 4th.)
         */
        differences: (...arrays) => {
            let args = arrays.map((el,i,arr)=>{
                if(i!=arr.length-1) {
                    let lena = arr[i].length
                    let lenb = arr[i+1].length
                    let minlen = Math.min(lena,lenb)
                    let maxlen = Math.max(lena,lenb)
                    let diff = maxlen-minlen
                    for (let j = 0; j &lt; minlen; j++) {
                        if(arr[i][j]!=arr[i+1][j]) diff++
                    }
                    return diff
                }
            })
            return args.slice(0,args.length-1)


        },

        /**
         * Returns the pitch and the number of its occurrences as a tuple for every unique value in pitches
         * @param  {Array&lt;Number>} pitches - a collection of pitches (not necessarily pitch classes)
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.count.pitches([0, 3, 3, 2, 4, 3, 4])
         * // returns [[3,3],[4,2], [2,1], [0,1]] (3 appears 3 times, 4 appears 2 times, etc.)
         * @return {Array&lt;Number>} A pitch, and how many times it appears
         * @memberOf EDO#count
         */
        pitches: (pitches) => {
            let counts = []
            let unique = new Set(pitches)
            for (let pitch of unique) {
                let count = pitches.reduce((t, e) => {
                    if (e == pitch) return t + 1
                    else return t
                }, 0)
                counts.push([pitch, count])
            }
            counts.sort((a, b) => b[1] - a[1])
            return counts
        }

    }

    /**A collection of functions that exports various file formats
     * @namespace*/
    export = {
        /**
         * &lt;p>Downloads / saves a png file with the contents of a container&lt;/p>
         * &lt;p>Note: all of the graphics made with this library create SVG elements, so just pass the same ID that you used to create the graphic in the first place&lt;/p>
         *
         * @param  {String} container_id - The ID of a container that has one or more SVG elements in it.
         * @memberOf EDO#export
         * @example
         * &lt;script src="edo.js">&lt;/script>
         * &lt;script src="raphael.min.js">&lt;/script>
         * &lt;div id="container" style="width:900px;height:600px; margin:0 auto;">&lt;/div>
         * &lt;script>
         *  let edo = new EDO()
         *  //Create a necklace graphic
         *  edo.show.necklace('container', [0,2,4,5,7,9,11])
         *
         *  //Save the graphic
         *  edo.export.png('container') //downloads the necklace
         * &lt;/script>
         */
        png: (container_id) => {
            if (environment == "server") return console.log("This is only support when run on client-side")

            const triggerDownload = function (imgURI) {
                let evt = new MouseEvent('click', {
                    view: window,
                    bubbles: false,
                    cancelable: true
                });

                let a = document.createElement('a');
                a.setAttribute('download', container_id + '.png');
                a.setAttribute('href', imgURI);
                a.setAttribute('target', '_blank');

                a.dispatchEvent(evt);
            }


            let el = document.getElementById(container_id)
            let svgs = el.getElementsByTagName('svg')

            for (let svg of svgs) {
                let bBox = svg.getBBox();
                let width = bBox.width
                let height = bBox.height
                let canvas = document.createElement('canvas');
                canvas.width = width
                canvas.height = height
                let ctx = canvas.getContext('2d');
                let data = (new XMLSerializer()).serializeToString(svg);
                let DOMURL = window.URL || window.webkitURL || window;
                let img = new Image();
                let mime_type = 'image/svg+xml;charset=utf-8'
                let svgBlob = new Blob([data], {type: mime_type});
                let url = DOMURL.createObjectURL(svgBlob);
                img.onload = function () {
                    ctx.drawImage(img, 0, 0);
                    DOMURL.revokeObjectURL(url);

                    var imgURI = canvas
                        .toDataURL('image/png')
                        .replace('image/png', 'image/octet-stream');
                    triggerDownload(imgURI);
                };

                img.src = url;
            }
        },


        svg: (container_id) => {
            if (environment == "server") return console.log("This is only support when run on client-side")
            let el = document.getElementById(container_id)
            let svgs = el.getElementsByTagName('svg')
            for (let svg of svgs) {
                let svgString = "&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>" + svg.outerHTML
                let a = document.createElement('a');
                a.download = container_id + '.svg';
                a.type = 'image/svg+xml';
                let blob = new Blob([svgString], {"type": "image/svg+xml"});
                a.href = (window.URL || webkitURL).createObjectURL(blob);
                a.click();
            }
        }

    }

    /**A collection of functions manipulating an input
     * @namespace EDO#get*/
    get = {
        /** &lt;p>Returns the angle created on the necklace for a given trichord.&lt;/p>
         *
         * &lt;p>If &lt;code>a&lt;/code>, &lt;code>b&lt;/code>, and &lt;code>c&lt;/code>, are vertices of a triangle (trichord) on a necklace. This function returns the angle &lt;code>abc&lt;/code>. That is, the angle node b has with a and c.&lt;/p>
         * @param  {Array&lt;Number>} triplet - a triplet/trichord of 3 numbers (pitch classes)
         * @returns {Number} the angle in degrees
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.angle([0,3,6]) //returns 90

         */
        angle: (triplet) => {
            let diff1=Math.abs(triplet[0]-triplet[1])
            diff1=(diff1>Math.ceil(this.edo/2))?this.edo-diff1:diff1
            let diff2=Math.abs(triplet[1]-triplet[2])
            diff2=(diff2>Math.ceil(this.edo/2))?this.edo-diff2:diff2
            return ((180-diff1/12*360)/2) + ((180-diff2/12*360)/2)
        },

        /** Returns the [x,y] coordinates of the nodes of the given pitches.
         * pitch
         * @param  {Array&lt;Number> | Number} pitch - A pitch, or an array of pitches
         * @param  {Array&lt;Number>} [circle_center=[0,0]] - The center of the circle
         * @param  {Number} [r=0.56418958354776] - The radius of the circle. By default the radius is of a circle with area=1
         * @returns {Array&lt;Array&lt;Number,Number>>} An array with tuples each corresponding to the x,y position of every pitch
         * @memberOf EDO#get
         * @see Scale#get.coordinates
         * @example
         * let edo = new EDO(12) //define context
         * edo.get.coordinates([0,3,7]) //minor triad
         * //returns
         * [
         *  [ 0, 0.56418958354776 ],
         *  [ 0.5043836053298857, -0.25279846688265545 ],
         *  [ 0.26388191608137657, -0.4986744635020088 ]
         * ]
         */
        coordinates: (pitch,circle_center = [0,0],r=0.56418958354776	) => {
            if(Array.isArray(pitch)) return pitch.map(p=>this.get.coordinates(p,circle_center,r))
            const angle_mult = 360/this.edo
            pitch = this.mod(pitch,this.edo)
            const angle = (pitch*angle_mult)*(Math.PI/180)
            const x = (r*Math.sin(angle))+circle_center[0]
            const y = (r*Math.cos(angle))+circle_center[1]
            return [x,y]
        },

        /** &lt;p>Returns a vector describing the contour of the given pitches.&lt;/p>
         *
         * &lt;p>If local is set to true, every cell in the vector will be
         * either 1 if note n is higher than n-1, 0 if note n is the same as n-1, and -1 if note n is lower than n-1
         * For instance &lt;code>[0,0,4,7,4,7,4,0]&lt;/code> will in local mode will return &lt;code>[0,1,1,-1,1,-1,-1]&lt;/code>&lt;/p>
         *
         * &lt;p>If local is set to false (default), the contour of the line is expressed such that the actual pc class of the
         * note is removed but its relative position in regards to the entire line is kept.
         * &lt;code>[0,4,7,12,16,7,12,16]&lt;/code> (Bach prelude in C) has 5 distinct note heights, so it will return
         * &lt;code>[0,1,2,3, 4, 2,3, 4]&lt;/code> indicating the relative height of each note in the entire phrase&lt;/p>
         * @param  {Array&lt;Number>} pitches - a given array of pitches
         * @param  {Boolean} [local=false] - if set to false, function will only return subsets that have consecutive members
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.contour([0,4,7,12,16,7,12,16])
         * //returns [0, 1, 2, 3, 4, 2, 3, 4]
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.contour([0,4,7,12,16,7,12,16],true)
         * //returns [1, 1, 1, 1,-1, 1, 1]
         */
        contour: (pitches, local = false) => {


            if (local) {
                let vector = []
                for (let i = 1; i &lt; pitches.length; i++) {
                    if (pitches[i] > pitches[i - 1]) vector.push(1)
                    else if (pitches[i] == pitches[i - 1]) vector.push(0)
                    else vector.push(-1)
                }
                return vector
            } else {
                let catalog = {}
                let unique_pitches = this.get.unique_elements(pitches)
                unique_pitches = unique_pitches.sort((a, b) => a - b)
                for (let i = 0; i &lt; unique_pitches.length; i++) {
                    catalog[unique_pitches[i]] = i
                }

                let vector = pitches.map((pitch) => catalog[pitch])
                return vector
            }

        },

        /**
         * &lt;p>Extracts every possible contour motive from a given melody. &lt;/p>
         * &lt;p>The function extracts every contour  subset appearing in the given melody.
         * The function also keeps track of the number of times each motive appeared.&lt;/p>
         * @param  {Array&lt;Number>} melody - a collection of pitches to find (in order)
         * @param  {Boolean} [allow_skips=false] - if false, the search will only be done on consecutive items
         * @param  {Number} [maximal_length=8] - Do not look for motives longer than this value.
         * @return {Array&lt;motives>}
         * @memberOf EDO#get
         * @function
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.contour_motives([7,6,7,6,7,2,5,3,0]).slice(0,4) //get first 3 motives
         * //returns
         * [
         *   { motive: [ -1, 1 ], incidence: 2 }, //going a half-step down, then up appears twice
         *   { motive: [ -1 ], incidence: 2 }, //going a half-step down appears twice
         *   { motive: [ 1 ], incidence: 2 } //going a half-step up appears twice
         * ]
         */
        contour_motives: (melody, allow_skips = false,maximal_length=8) => {
            let motives = []
            let all_subsets = this.get.subsets(melody, allow_skips).map((subset) => this.get.contour(subset)).filter((contour) => contour.length > 1)
            all_subsets = all_subsets.filter(sub=>sub.length&lt;=maximal_length)

            let unique_subsets = this.get.unique_elements(all_subsets)
            motives = unique_subsets.map((subset) => {
                let count = 0
                for (let i = 0; i &lt; all_subsets.length; i++) {
                    if (this.is.same(subset, all_subsets[i])) count++
                }
                return {motive: subset, incidence: count}
            })
            motives = motives.sort((a, b) => b.incidence - a.incidence || b.motive.length - a.motive.length)
            return motives

        },

        /**
         * &lt;p>From a given set of pitches, returns every combination (order specific) of size k&lt;/p>
         * &lt;p>(For a similar function where the order doesn't matter use [EDO.get.n_choose_k()]{@link EDO#get.n_choose_k})
         * @param  {Array&lt;Number>} set - The array from which to extract combinations
         * @param  {Number} k - The number of elements per set returned
         * @return {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         * @example
         * edo.get.combinations([1,3,5,7],2)
         * //returns
         * [
         *   { motive: [ -1, 1 ], incidence: 2 }, //going a half-step down, then up appears twice
         *   { motive: [ -1 ], incidence: 2 }, //going a half-step down appears twice
         *   { motive: [ 1 ], incidence: 2 } //going a half-step up appears twice
         * ]
         */
        combinations: (set, k) => {
            let combs = this.get.n_choose_k(set,k)
            combs = combs.map(e=>this.get.permutations(e))
            combs = combs.flat()
            combs = this.get.unique_elements(combs)
            return combs
        },

        /** &lt;p>Returns the complementary interval (needed to complete the octave) for a given an interval class.&lt;/p>
         * @param {Number} interval - Some interval class
         * @returns {Number}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.complementary_interval(3) //returns 9
         *
         */
        complementary_interval: (interval) => {
            return this.edo - interval
        },

        /** &lt;p>Returns all the PCs of the EDO that the scale does not use.&lt;/p>
         * @param {boolean} [from_0=false] - when true, the output will be normalized to 0.
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.complementary_set([0,2,4,5,7,9,11])
         * //returns [1, 3, 6, 8, 10]
         *
         * edo.get.complementary_set([0,2,4,5,7,9,11],true)
         * //returns [0, 2, 5, 7, 9]
         */
        complementary_set: (pitches, from_0) => {
            let PCs = Array.from(Array(this.edo).keys())
            pitches.forEach((PC) => {
                (PCs.indexOf(PC) != -1) ? PCs.splice(PCs.indexOf(PC), 1) : true
            })
            if (from_0) PCs = this.scale(PCs).pitches
            return PCs
        },

        /** &lt;p>Returns a chord progression of length &lt;code>num_of_chords&lt;/code> using only &lt;code>allowed_qualities&lt;/code>, with at least &lt;code>common_notes_min&lt;/code> notes in common between every chord.&lt;/p>
         * @param {Array&lt;Array&lt;Number>>} allowed_qualities - A list of allowed chord qualities (regardless of transposition)
         * @param {Array&lt;Number>} starting_chord - The first chord in the progression (using exact pitches and voicing)
         * @param {Number} [num_of_chords=4] - The number of chords the final progression shuold include.
         * @param {Number} [common_notes_min=2] - The minimal number of notes in common between every two succeeding chords in the progression.
         * @returns {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.harmonic_progression([[0,3,7],[0,4,7]],[1,4,7])
         * //returns e.g. [ [ 1, 4, 7 ], [ 11, 4, 7 ], [ 11, 2, 7 ], [ 10, 2, 7 ] ]
         */
        harmonic_progression: (allowed_qualities, starting_chord,num_of_chords=4, common_notes_min=2) => {
            let progression = [starting_chord]
            let escape=100
            while(progression.length&lt;num_of_chords &amp;&amp; escape>0) {
                let last_chord = progression[progression.length-1]
                let possibilities = []
                for(let quality of allowed_qualities) {
                    for (let i = 0; i &lt; this.edo; i++) {
                        let trans = quality.map(n=>(n+i)%this.edo)

                        let in_common = this.count.common_tones(trans,last_chord)
                        if(in_common>=common_notes_min &amp;&amp; in_common!=last_chord.length) possibilities.push(trans)
                    }
                }
                possibilities = this.get.unique_elements(possibilities)
                if(possibilities.length==0) {
                    escape--
                    continue
                }

                progression.push(this.shuffle_array(possibilities)[0])
            }
            for (let i = 1; i &lt; progression.length; i++) {

                progression[i]=this.get.minimal_voice_leading(progression[i-1],progression[i])

            }
            return progression

        },

        /** &lt;p>Returns a chord progression to harmonize a given melodies with given possible chord qualities.&lt;/p>
         * @param {&lt;Array&lt;Number>} melody - The melody
         * @param {Array&lt;Array&lt;Number>>} allowed_qualities - A list of allowed chord qualities (regardless of transposition)
         * @param {Array&lt;Number>} starting_chord - The first chord in the progression (using exact pitches and voicing)
         * @param {Number} [common_notes_min=1] - The minimal number of notes in common between every two succeeding chords in the progression.
         * @returns {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.harmonized_melody([7,4,5,2,4,0,2],[[0,4,7],[0,3,7]])
         * //returns e.g.
         * [
         *  [ 4, 7, 11 ],
         *  [ 4, 9, 0 ],
         *  [ 5, 9, 2 ],
         *  [ 7, 11, 2 ],
         *  [ 7, 0, 4 ],
         *  [ 9, 0, 4 ],
         *  [ 9, 2, 5 ]
         * ]
         */
        harmonized_melody: (melody,allowed_qualities,starting_chord, common_notes_min=1) => {
            let harmony = []
            let melody_copy = [...melody]
            let last_chord = starting_chord
            allowed_qualities = allowed_qualities.map(q=>this.scale(q).get.modes()).flat()

            melody_copy = melody_copy.map((note,i)=>{

                let options = allowed_qualities.map(q=>q.map(n=>(n+note)%this.edo).sort((a,b)=>a-b))
                if(last_chord &amp;&amp; i==0) {
                    harmony.push(last_chord)
                    return last_chord
                }
                if(last_chord) {
                    options = options.filter(option => {
                        let in_common = this.count.common_tones(option,last_chord)
                        return in_common>=common_notes_min &amp;&amp; in_common!=last_chord.length
                    })
                }
                let chord = this.shuffle_array(options)[0]
                harmony.push(chord)
                last_chord=chord
                return last_chord
            })

            for (let i = 1; i &lt; harmony.length; i++) {
                if(harmony[i]==undefined || harmony[i-1]==undefined) continue
                harmony[i] = this.get.minimal_voice_leading(harmony[i-1],harmony[i])
            }

            console.log(harmony)

            return harmony

        },


        // /** &lt;p>Returns all of the possible combinations of pitches on a harp (through pedaling).&lt;/p>
        //  * @param {Boolean} [as_intervals=false] - When true, the returned values are of the interval relationships between the pitches, and not the pitch classes.
        //  * @param {&lt;Array&lt;Number>} [strings_in_octave=[0,2,4,5,7,9,11]] - The tuning of the strings
        //  * @param {Array&lt;Number>} [pedal_shift=[-1,0,1]] - The possible configurations of every pedal (how much does a configuration raise/lower the pitch)
        //  * @returns {Array&lt;Array&lt;Number>>}
        //  * @memberOf EDO#get
        //  * @example
        //  * let edo = new EDO(12) // define a tuning system
        //  * edo.get.harp_configurations()
        //  */
        // harp_configurations: (as_intervals=false,strings_in_octave=[0,2,4,5,7,9,11],pedal_shift = [-1,0,1],with_quality) => {
        //     strings_in_octave = strings_in_octave.map(s=>pedal_shift.map(p=>this.mod(s+p,this.edo)))
        //     let configurations = this.get.partitioned_subsets(strings_in_octave)
        //     if(with_quality) {
        //         configurations = configurations.filter(c=>this.scale(c).count.chord_quality(with_quality)>0)
        //     }
        //     if(as_intervals) {
        //         configurations = this.get.unique_elements(configurations.map(c=> {
        //             let min_index = c.indexOf(Math.min(...c))
        //             c = this.get.rotated(c,min_index)
        //             // console.log(c)
        //             let steps = this.convert.to_steps(c).map(c=>(this.edo-c&lt;c)?c-this.edo:c)
        //             steps = steps.map(s=>{
        //                 if(s&lt;-(this.edo/2)) return this.edo+s
        //                 else return s
        //             })
        //             return steps
        //         }))
        //
        //     }
        //     return configurations
        //
        // },

        /** &lt;p>Returns all of the possible ways to achieve a certain chord quality on a harp.&lt;/p>
         * @param {Array&lt;Number>} quality - The desired chord quality
         * @param {Array&lt;Number>} [scordatura=[0,2,4,5,7,9,11]] - The tuning of the strings
         * @param {Array&lt;Number>} [pedal_shift=[-1,0,1]] - The possible configurations of every pedal (how much does a configuration raise/lower the pitch)
         * @returns {Array&lt;Object>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.harp_position_of_quality([0,1,2,3]) //find all possible chromatic tetrachord on a harp
         * //returns
         * [
         *  {
         *      strings: [ 6, 1, 7, 2 ], //the strings to be plucked
         *      pedals: [ 1, -1, 1, -1 ], //the pedals corresponding to the aforementioned strings
         *      pitches: [ 10, 11, 0, 1 ] //the resultant pitches
         *  },
         *  {
         *      strings: [ 5, 6, 7, 1 ],
         *      pedals: [ 1, 0, -1, -1 ],
         *      pitches: [ 8, 9, 10, 11 ]
         *  },
         *  {
         *      strings: [ 3, 4, 5, 6 ],
         *      pedals: [ 1, 1, 0, -1 ],
         *      pitches: [ 5, 6, 7, 8 ]
         *  },
         *  {
         *      strings: [ 2, 3, 4, 5 ],
         *      pedals: [ 1, 0, 0, -1 ],
         *      pitches: [ 3, 4, 5, 6 ]
         *  },
         *  {
         *      strings: [ 2, 4, 3, 5 ],
         *      pedals: [ 1, -1, 1, -1 ],
         *      pitches: [ 3, 4, 5, 6 ]
         *  },
         *  {
         *      strings: [ 6, 7, 1, 2 ],
         *      pedals: [ 1, 0, 0, -1 ],
         *      pitches: [ 10, 11, 0, 1 ]
         *  },
         *  {
         *      strings: [ 1, 2, 3, 4 ],
         *      pedals: [ 1, 0, -1, -1 ],
         *      pitches: [ 1, 2, 3, 4 ]
         *  },
         *  {
         *      strings: [ 7, 1, 2, 3 ],
         *      pedals: [ 1, 1, 0, -1 ],
         *      pitches: [ 0, 1, 2, 3 ]
         *  }
         * ]
         *
         */
        harp_position_of_quality: (quality,scordatura=[0,2,4,5,7,9,11],pedal_shift = [-1,0,1]) =>{
            let results = []
            let strings_in_octave_norm = scordatura.map(s=>pedal_shift.map(p=>this.mod(s+p,this.edo)))
            let configurations = this.get.partitioned_subsets(strings_in_octave_norm)
            configurations = configurations.map(c=>{
                for (let i = 0; i &lt; this.edo; i++) {
                    let qual = quality.map(q=>(q+i)%this.edo)
                    if(this.is.subset(qual,c)) {
                        let positions = []
                        let transpositions = []
                        let pitches = []
                        qual.forEach(qu=>positions.push(c.indexOf(qu)+1))
                        positions.forEach(pos=>{

                            let res = -scordatura[pos-1]+c[pos-1]
                            if(!pedal_shift.includes(res)) {
                                if(res&lt;0) res = this.mod(res+this.edo,this.edo)
                                else if (res>0) res = res-this.edo
                            }
                            pitches.push(c[pos-1])
                            transpositions.push(res)
                        })
                        results.push({strings:positions,pedals:transpositions,pitches:pitches})
                    }
                }

            })
            results = this.get.unique_elements(results)
            results = results.sort((a,b)=>{
                let ap = a['pitches']
                let bp = b['pitches']
                let len = ap.length
                for (let i = 0; i &lt; len; i++) {
                    if(ap[i]!=bp[i]) return ap[i]-bp[i]
                }
            })
            return results
        },

        /** &lt;p>Returns the pitches produced given a list of harp pedal transpositions (in ascending order, not harp pedal order).&lt;/p>
         * @param {Array&lt;Number>} pedals - The configuration / transposition set be each pedal (e.g. [-1,0,0,0,1,0,0]) for Cb and G# in 12EDO
         * @param {Array&lt;Number>} [scordatura=[0,2,4,5,7,9,11]] - The tuning of the strings
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.harp_pedals_to_pitches([0,0,0,0,0,1,-1]) 6th string sharpened, 7th string flattened
         * //returns
         * [0, 2, 4, 5, 7, 10, 10]
         *
         */
        harp_pedals_to_pitches: (pedals,scordatura=[0,2,4,5,7,9,11])=>{
            return scordatura.map((note,i)=>this.mod(note+pedals[i],this.edo))
        },

        harp_least_pedals_passage: (pitches,scordatura=[0,2,4,5,7,9,11],pedal_shift = [-1,0,1]) => {
            let strings_in_octave = scordatura.map(s=>pedal_shift.map(p=>this.mod(s+p,this.edo)))
            let configurations = this.get.partitioned_subsets(strings_in_octave)
            let paths = []

            let recurrent = (pitches,path=[]) => {
                let ml,mr
                let options
                for (let i = 0; i &lt; pitches.length; i++) {
                    ml = pitches.slice(0,pitches.length-i)
                    mr = pitches.slice(pitches.length-i)
                    let unique = this.get.unique_elements(ml.map(n=>this.mod(n,this.edo)))
                    let uniquel = unique.length
                    if(uniquel>scordatura.length) continue
                    options = configurations.filter(conf=>this.is.subset(unique,conf))
                    if(options.length>0) break
                }
                if(!options) return
                options.forEach(opt=>{
                    if(mr.length==0) paths.push([...path,opt])
                    else recurrent(mr,[...path,opt])
                })





            }
            recurrent(pitches)


            let distances = paths.map((path)=>{
                return path.map((p,i)=>{
                    if(i==path.length-1) return 0
                    let ar1=path[i]
                    let ar2 = path[i+1]
                    let dist = 0
                    for (let j = 0; j &lt; ar2.length; j++) {
                        if(ar1[j]!=ar2[j]) dist++
                    }
                    return dist
                })






            }).map(path=>path.reduce((ag,e)=>ag+e,0))
            let min = Math.min(...distances)
            let indexes = []
            distances.forEach((dist,i)=>{
                if(dist==min) indexes.push(i)
            })

            paths = paths.filter((path,i)=>indexes.includes(i))
            return {paths:paths,pedals:min}

        },

        /** &lt;p>Fills in the missing pedals to the output of [EDO.get.harp_position_of_quality()]{@link EDO#get.harp_position_of_quality}.&lt;/p>
         * @param {Array&lt;Object>} qualities - The output of @link EDO#get.harp_position_of_quality
         * @param {Array&lt;Number>} [harp_default=[-1,-1,-1,-1,-1,-1,-1]] - The default configuration of the pedals
         * @param {Array&lt;Number>} [scordatura=[0,2,4,5,7,9,11]] - The tuning of the strings when all pedals are not flattened nor sharpened.
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         */
        fill_partial_harp_pedaling: (qualities,harp_default=[-1,-1,-1,-1,-1,-1,-1],scordatura=[0,2,4,5,7,9,11])=> {
            qualities = qualities.map(q=>{
                let new_pedals = [...harp_default]
                q.strings.forEach((str,i)=>{
                    new_pedals[str-1]=q.pedals[i]
                })
                q.pedals=new_pedals

                return q
            })
            return qualities
        },





        /** &lt;p>Returns the interval-class between two pitch classes.&lt;/p>
         * @param {Number} PC1 - The first pitch class
         * @param {Number} PC2 - The second pitch class
         * @returns {Array&lt;Number>}
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.interval_class(1,8) //returns 5
         */
        interval_class: (PC1,PC2) => {
            let diff = Math.abs(PC1-PC2)
            return (diff&lt;Math.ceil(this.edo/2))? diff : this.edo-diff

        },

        /** &lt;p>Returns all combinations of size k from an array.&lt;/p>
         * @param {Array} arr - An array with elements
         * @param {Number} k=2 - The number of elements in each returned permutation
         * @returns {Array&lt;Number>}
         * @memberOf Scale#get
         * @example
         * edo.get.n_choose_k([1,3,5,7],k=3)
         * //returns [ [ 1, 3, 5 ], [ 1, 3, 7 ], [ 1, 5, 7 ], [ 3, 5, 7 ] ]
         */
        n_choose_k: (arr,k=2) =>{
            let results = []
            const combinations = (arr,len,start_pos=0,result=Array(len)) =>{
                if(len==0) {
                    results.push([...result])
                    return
                }
                for (let i = start_pos; i &lt;= arr.length-len ; i++) {
                    result[result.length-len] = arr[i]
                    combinations(arr,len-1,i+1,result)
                }
            }
            combinations(arr,k)
            return results
        },

        /** &lt;p>Returns the ROUGHNESS OF SINE-PAIRS based on algorithm from Vassilakis, 2001 &amp; 2005 .&lt;/p>
         * @param {Number} freq1 - the frequency of the 1st sine
         * @param {Number} freq2 - the frequency of the 2nd sine
         * @param {Number} [amp1=1] - the amplitude of the 1st sine
         * @param {Number} [amp2=1] - the amplitude of the 2nd sine
         * @returns {Number}
         * @memberOf Scale#get
         * @example
         * edo.get.sine_pair_dissonance(440,475) //returns 0.17190984235878704
         * @see http://www.acousticslab.org/learnmoresra/moremodel.html
         * @see Vassilakis, P. (2001). "Auditory roughness estimation of complex spectra—Roughness degrees and dissonance ratings of harmonic intervals revisited." The journal of the Acoustical Society of America 110(5): 2755-2755.
         */
        sine_pair_dissonance: (freq1,freq2,amp1=1,amp2=1) => {
            const f_min = Math.min(freq1,freq2)
            const f_max = Math.max(freq1,freq2)
            const a_min = Math.min(amp1,amp2)
            const a_max = Math.max(amp1,amp2)
            const X = a_min*a_max
            const Y = 2*a_min/(a_min+a_max)
            const b1 = 3.5
            const b2=5.75
            const s1 = 0.0207
            const s2 = 18.96
            const s = 0.24/(s1*f_min+s2)
            const Z = Math.pow(Math.E,-1*b1*s*(f_max-f_min)) - Math.pow(Math.E,(-1*b2*s*(f_max-f_min)))
            const R = (X^0.1)*0.5*(Y^3.11)*Z
            return R

        },

        // /** &lt;p>Returns the measure of dissonance of a given input based on Sethares' algorithm.&lt;/p>
        //  * @param {Array&lt;Number>} ratios - An (ordered) array of ratios with root=1 (e.g. [1,1.5,1.66,2])
        //  * @param {Array&lt;Number>} [amplitudes=[1,1...]] - An (ordered) array of corresponding amplitudes to each ratio (0&lt;=amp&lt;=1)
        //  * @param {Number} [base_freq=440] - The frequency to use as the basis for the calculation
        //  * @returns {Number} a number value of the measure of dissonance of the given input
        //  * @memberOf Scale#get
        //  * @example
        //  * let edo = new EDO(12) // define a tuning system
        //  * edo.get.dissonance_measure([1,2]) //returns 0.000009198921497239643
        //  *
        //  * edo.get.dissonance_measure([1,2],[1,0.5],110) //returns 0.029873544106178103
        //  *
        //  * @see https://sethares.engr.wisc.edu/consemi.html
        //  */
        // dissonance_measure: (ratios,amplitudes=Array.from(new Array(ratios.length).fill(1)),base_freq=440) => {
        //     ratios = ratios.map(r=>r*base_freq)
        //     const Dstar=0.24, S1=0.0207, S2=18.96, C1=5, C2=-5,
        //     A1=-3.51, A2=-5.75, firstpass=1, N=ratios.length
        //     let D=0
        //     for (let i = 2; i &lt;= N; i++) {
        //         let Fmin = ratios.slice(0,N-i+1)
        //         let S = Fmin.map(e=>Dstar/(S1*e+S2))
        //         let slice1 = ratios.slice(i-1,N)
        //         let slice2 = ratios.slice(0,(N-i+1))
        //         let Fdif = []
        //         for (let j = 0; j &lt; slice1.length; j++) {
        //             Fdif.push(slice1[j]-slice2[j])
        //         }
        //
        //         let aslice1 = amplitudes.slice(i-1,N)
        //         let aslice2 = amplitudes.slice(0,(N-i+1))
        //         let a = (aslice1.reduce((a,b)=>a+b,0)&lt;aslice2.reduce((a,b)=>a+b,0))?aslice1:aslice2
        //
        //
        //         let calc1= Fdif.map((el,ind)=>Math.exp(el*S[ind]*A1)*C1)
        //         let calc2 = Fdif.map((el,ind)=>Math.exp(el*S[ind]*A2)*C2)
        //         let calcsum = calc1.map((el,ind)=>el+calc2[ind])
        //         let Dnew = calcsum.map((el,ind)=>el*a[ind])
        //         let Dnewsum = Dnew.reduce((a,b)=>a+b,0)
        //         D+=Dnewsum
        //     }
        //     return D
        //
        // },

        // /** &lt;p>Returns mean (Sethares) dissonance value for every rotation of a given set.&lt;/p>
        //  * @param {Array&lt;Number>} set - A set of pitches
        //  * @param {Boolean} normalize - when true, the value is divided by the number of pitches to make it easier to compare roughness of scales with different number of pitches
        //  * @returns {Number} a number value of the measure of dissonance of the given input
        //  * @memberOf Scale#get
        //  * @example
        //  * let edo = new EDO(12) // define a tuning system
        //  * edo.get.mean_set_dissonance([0,2,4,5,7,9,11]) //returns 4.846261636284487
        //  *
        //  * @see EDO#get.dissonance_measure
        //  */
        // mean_set_dissonance: (set,normalize=false)=>{
        //     set = set.sort((a,b)=>a-b)
        //     let modes = this.get.modes(set)
        //     let ratios = modes.map(m=>this.convert.interval_to_ratio(m))
        //     let dis = ratios.map(r=>this.get.dissonance_measure(r))
        //     let mean = dis.reduce((a,e)=>a+e,0)/dis.length
        //     if(normalize) mean = mean/set.length
        //     return mean
        // },

        /** &lt;p>Expends / contracts the intervals between pitches of a melody.&lt;/p>
         * @param {Array&lt;Number>} melody - The melody to be modified
         * @param {Number} resize_by - The amount by which the melody will be modified (can be positive/negative/fraction)
         * @param {String} [method="multiply"] - "add" to add resize by to any interval. "multiply" to multiply the intervals by the value.
         * @returns {Array&lt;Number>}
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.resize_melody([0,2,4,5,7,5,4,2,-1,0],2)
         * //returns [0, 4, 8, 10, 14, 10, 8, 4, -2, 0]
         *
         * edo.get.resize_melody([0,2,4,5,7,5,4,2,-1,0],-1)
         * //[0,-2,-4,-5,-7,-5,-4,-2,1,0]
         *
         * edo.get.resize_melody([0,2,4,5,7,5,4,2,-1,0],-1,method='add')
         * //returns
         * [0,1,2,2,3,2,2,1,-1,-1]
         */
        resize_melody: (melody, resize_by = 2, method = "multiply") => {
            let note1 = melody[0]
            melody = edo.convert.to_steps(melody)
            if (method == "add") {
                melody = melody.map((interval) => {
                    if (interval > 0) return (interval + resize_by > 0) ? interval + resize_by : 0
                    else if (interval &lt; 0) return (interval - resize_by &lt; 0) ? interval - resize_by : 0
                    else return 0
                })
            } else if (method == "multiply") melody = melody.map((interval) => Math.round(interval * resize_by))

            melody = edo.convert.intervals_to_pitches(melody)
            return edo.get.transposition(melody, note1, false)


        },

        /** &lt;p>Returns a generated scale generated by a given generator, with a given cardinality.&lt;/p>
         * @param {Number} [generator=7] - The generator
         * @param {Number} [cardinality=7] - The cardinality (number of pitches)
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.generated_scale(7,5) // returns [0,2,4,7,9]
         * @see Balzano, G. J. (1980). "The group-theoretic description of 12-fold and microtonal pitch systems." Computer music journal 4(4): 66-84.
         * @see Carey, N. (2007). "Coherence and sameness in well-formed and pairwise well-formed scales." Journal of Mathematics and Music 1(2): 79-98.
         * @see Carey, N. and D. Clampitt (1989). "Aspects of well-formed scales." Music Theory Spectrum 11(2): 187-206.
         */
        generated_scale: (generator=7,cardinality=7,return_object=false) =>{
            let scale = []
            for (let i = 0; i &lt; cardinality ; i++) {
                scale.push(this.mod(generator*i,this.edo))
            }
            scale = this.get.normal_order(scale.sort((a,b)=>a-b))
            return scale
        },

        /** &lt;p>Returns every IC that by iteratively adding it to 0, produces all of the pitches of the tuning space.&lt;/p>
         * @see Balzano, G. J. (1980). "The group-theoretic description of 12-fold and microtonal pitch systems." Computer music journal 4(4): 66-84.
         * @param {Boolean} [with_complement_interval=false] - When true the complementary intervals will be included (e.g. in 12EDO IC>6)
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.generators()
         * //returns [1,5]
         *
         * edo.get.generators(true)
         * //returns [[1,11],[5,7]]
         */
        generators: (with_complement_interval = false) => {
            let generators = []
            for (let i = 1; i &lt; Math.ceil(this.edo / 2); i++) {

                let arr = Array.from(Array(this.edo).keys()).map((ind) => this.mod(ind * i, this.edo))
                arr = this.get.unique_elements(arr)
                if (arr.length == this.edo) generators.push(i)
            }
            if (with_complement_interval) generators = generators.map((el) => [el, this.get.complementary_interval(el)])
            return generators
        },

        /** &lt;p>Returns the elements that are found in all given sets&lt;/p>
         * @param {...Array&lt;Number>} collections - Any number of arrays containing pitches
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.intersection([1,2,3,4],[3,4,5,6])
         * //returns [3,4]
         *
         * edo.get.intersection([1,2,3,4],[3,4,5,6],[2,4])
         * //returns [4]
         */
        intersection: (...collections) => {
            let first = collections[0]
            for (let i = 1; i &lt; collections.length; i++) {
                first = first.filter(value => collections[i].includes(value))
            }
            return first

        },

        /** Gets a melody represented as intervals, and returns the interval traversed by the end.
         * @param  {Array&lt;Number>} intervals - Melody represented in intervals
         * @returns {Number} the interval traversed by the melody
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.interval_traversed([2,-3,4,-1])
         * //returns 2 (moving up 2, then down 3, then up 4, then down 1 will get you +2 above where you started)
         */
        interval_traversed: (intervals) => {
            /*Gets an array of intervals in order, and returns the interval traversed by the end*/
            return intervals.reduce((t, e) => t + e)
        },

        /** &lt;p>Makes every stacking combination of intervals from 'intervals' up to 'height' stack_size.&lt;/p>
         *
         * &lt;p>For instance, given the &lt;code>intervals = [2,3]&lt;/code> and &lt;code>stack_size = 3&lt;/code>, the function will return a list of lists
         * such that every list will be of &lt;code>length = 3&lt;/code> (&lt;code>stack_size&lt;/code>) containing an exhaustive list of every
         * combination using the intervals 2 and 3 (in this case).
         * As such, it will return  &lt;code>[[2, 2, 2], [2, 2, 3], [2, 3, 2], [3, 2, 2], [2, 3, 3], [3, 2, 3],
         * [3, 3, 2], [3, 3, 3]]&lt;/code> which represents every combination or 2s and 3s in any order of length 3.&lt;/p>
         *
         * &lt;p>if &lt;code>as_pitches = true&lt;/code>, instead of returning the list of intervals classes of length 3, it
         * will return a list of pitches starting from 0 (which can go above 11). If set to true the function
         * will return  &lt;code>[[0, 2, 4, 6], [0, 2, 4, 7], [0, 2, 5, 7], [0, 3, 5, 7], [0, 2, 5, 8], [0, 3, 5, 8],
         * [0, 3, 6, 8], [0, 3, 6, 9]]&lt;/code>&lt;/p>
         * @param  {Array&lt;Number>} intervals - the intervals be used
         * @param  {Number} [stack_size=3] - the size of the stack of pitches.
         * @param  {Boolean} [as_pitches=false] - Indicates whether the returned result represents interval classes or pitches
         * @return {Array&lt;Number>} a list of interval classes or pitches
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // create a tuning context
         * edo.get.interval_stack([3,2],3)
         * //returns
         *      [
         *       [ 2, 2, 2 ],
         *       [ 3, 2, 2 ],
         *       [ 2, 3, 2 ],
         *       [ 2, 2, 3 ],
         *       [ 3, 3, 2 ],
         *       [ 3, 2, 3 ],
         *       [ 2, 3, 3 ],
         *       [ 3, 3, 3 ]
         *      ]
         *
         * @example
         * edo.get.interval_stack([3,2],3,true)
         * //returns
         * [
         *  [ 0, 2, 4, 6 ],
         *  [ 0, 3, 5, 7 ],
         *  [ 0, 2, 5, 7 ],
         *  [ 0, 2, 4, 7 ],
         *  [ 0, 3, 6, 8 ],
         *  [ 0, 3, 5, 8 ],
         *  [ 0, 2, 5, 8 ],
         *  [ 0, 3, 6, 9 ]
         * ]
         * */
        interval_stack: (intervals, stack_size = 3, as_pitches = false) => {
            const decToBase = (n, b) => {
                if (n == 0) return [0]
                let digits = []
                while (n) {
                    digits.push(n % b)
                    n = Math.floor(n / b)
                }
                digits.reverse()
                return digits
            }

            let all_perm = []
            intervals = this.get.unique_elements(intervals)
            let base = intervals.length
            let mapping = {}
            let result = []
            for (let i = 0; i &lt; intervals.length; i++) mapping[i] = intervals[i]
            let max = base ** stack_size
            for (let i = 0; i &lt; max; i++) {
                let res = decToBase(i, base)
                let fill_in = stack_size - res.length
                fill_in = Array(fill_in).fill(0)
                all_perm.push([...fill_in, ...res])
            }
            for (let vector of all_perm) {
                result.push(vector.map((el) => mapping[el]))
            }
            result.sort((a, b) => a.reduce((t, e) => t + e) - b.reduce((t, e) => t + e))
            if (as_pitches) {
                let pitches = []
                for (let l of result) {
                    let ls = [0]
                    for (let item of l) {
                        ls.push(ls[ls.length - 1] + item)
                    }
                    pitches.push(ls)
                }
                result = pitches
            }
            return result
        },

        /** Returns the inversion of a given set of pitches
         *
         * @param  {Array&lt;Number>} scale - a collection of pitches (not necessarily PCs)
         * @param  {Boolean} cache - if true, the result will be cached for faster retrival
         * @return {Array&lt;Number>} The inverted input
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.inversion([0,2,4,5,7,9,11])
         * //returns [0, 2,  4, 6, 7, 9, 11]*/
        inversion: (scale, cache = false) => {

            if (!this.catalog[String(scale)]) this.catalog[String(scale)] = {}
            if (this.catalog[String(scale)]['inverted']) return this.catalog[String(scale)]['inverted']

            let steps = this.convert.to_steps(scale)
            let r_steps = [...steps]
            r_steps.reverse()

            let i_scale = this.convert.intervals_to_scale(r_steps)
            if (cache) this.catalog[String(scale)]['inverted'] = i_scale
            return i_scale
        },

        /** &lt;p>Returns a lattice from the pitches in the scale&lt;/p>

         * @param {Number} [hor=3] - the gap between numbers horizontally
         * @param {Number} [ver=4] - the gap between numbers vertically
         * @param {Boolean} [as_notes=false]
         * @example
         * let edo = new EDO(12) //define tuning
         * edo.get.lattice()
         * //returns
         //0  3  6  9  0  3  6  9  0  3  6  9
         //
         //8  11 2  5  8  11 2  5  8  11 2  5
         //
         //4  7  10 1  4  7  10 1  4  7  10 1
         //
         //0  3  6  9  0  3  6  9  0  3  6  9
         //
         //8  11 2  5  8  11 2  5  8  11 2  5
         //
         //4  7  10 1  4  7  10 1  4  7  10 1
         //
         //0  3  6  9  0  3  6  9  0  3  6  9
         * @memberOf EDO#get*/
        lattice: (hor = 3, ver = 4, as_notes = false) => {
            let lattice = ""
            for (let i = this.edo; i >= -this.edo; i -= ver) {
                let line = ""
                for (let j = 0; j &lt; this.edo; j++) {
                    let num = this.mod(i + (j * hor), this.edo)
                    let note
                    if (as_notes) note = this.convert.pc_to_name(num)
                    else note = String(num)
                    line += note + " ".repeat(3 - note.length)
                }
                lattice += line + "\n\n"
            }
            return lattice
        },

        /** &lt;p>Returns the Levenshtein distance from one collection of pitches to another&lt;/p>
         * @param {Array&lt;Number>} collection1 - A collection of pitches
         * @param {Array&lt;Number>} collection1 - Another collection of pitches
         * @param {Boolean} [ratio_calc=false] - When true, the function computes the
         * levenshtein distance ratio of similarity between two collections
         * @returns {Number}
         * @example
         * let edo = new EDO(12) //define tuning
         * edo.get.levenshtein([0,2,4,7,9],[0,2,4,5,7,9,11]) //returns 1
         *
         * @example
         * edo.get.levenshtein([0,2,4,7,9],[0,2,4,5,7,9,11],true) //returns 0.9230769230769231
         * @memberOf EDO#get*/
        levenshtein: (collection1,collection2, ratio_calc = false) => {



            let s = collection1
            let t = collection2

            //initialize matrix with 0

            let rows = s.length + 1
            let cols = t.length + 1
            let distance = Array.from({length: rows}, e => Array(cols).fill(0));
            let col
            let row
            //Populate matrix of zeros with the indices of each character of both strings
            for (let i = 1; i &lt; rows; i++) {
                for (let k = 1; k &lt; cols; k++) {

                    distance[i][0] = i
                    distance[0][k] = k
                }
            }

            // Iterate over the matrix to compute the cost of deletions,insertions and/or substitutions
            let cost = 0
            for (col = 1; col &lt; cols; col++) {
                for (row = 1; row &lt; rows; row++) {
                    if (s[row - 1] == t[col - 1]) cost = 0 //If the characters are the same in the two strings in a given position [i,j] then the cost is 0
                    else {
                        // In order to align the results with those of the Python Levenshtein package, if we choose to calculate the ratio
                        // the cost of a substitution is 2. If we calculate just distance, then the cost of a substitution is 1.
                        if (ratio_calc) cost = 2
                        else cost = 1
                    }
                    let res = Math.min.apply(Math, [distance[row - 1][col] + 1, distance[row][col - 1] + 1, distance[row - 1][col - 1] + cost])
                    distance[row][col] = res
                }
            }
            if (ratio_calc) {
                let Ratio = ((s.length + t.length) - distance[row - 1][col - 1]) / (s.length + t.length)

                return Ratio
            } else {
                return distance[s.length][t.length]
            }
        },

        // /** &lt;p>Returns a "likely" root from a collection of pitches&lt;/p>
        //  *  &lt;p>Given a set of pitches, the algorithm returns the pitch that contains the other pitches in lower positions in its overtone series.&lt;br>
        //  *      E.g. If we consider C-E-G &lt;code>(0,4,7)&lt;/code>, E and G appear as overtones of C at lower positions than C and G appear as overtones of E, and C and E as overtones of G.&lt;/p>
        //  *      &lt;p>Note: a root can be highly dependent on context, therefore this algorithm at its current state cannot provide a decisive answer.&lt;/p>
        //  * @param  {Array&lt;Number>} pitches - a collection of pitch classes
        //  * @param  {Array&lt;Number>} [limit=19] - The overtone limit by which PCs are approximated
        //  * @return {Number} The pitch-class of the likely root.
        //  * @memberOf EDO#get
        //  * @example
        //  * let edo = new EDO(12) // define a tuning system
        //  * edo.get.likely_root([0,5,9])
        //  * //returns 5*/
        // likely_root: (pitches, limit = 17) => {
        //     pitches = this.get.unique_elements(pitches).sort((a, b) => a - b)
        //     let catalog = {}
        //     let ratios = this.get.modes(pitches)
        //         .map((mode) =>
        //             mode.filter((interval) => interval != 0)
        //                 .map((interval) => this.get.ratio_approximation(interval, limit).octave)
        //                 .reduce((a, e) => a + e)
        //         )
        //
        //     let min = Math.min.apply(Array, ratios)
        //     let pos = ratios.indexOf(min)
        //     return pitches[pos]
        // },

        // likely_root2: (pitches) => {
        //     let scale = this.scale(pitches)
        //     let modes = scale.get.modes()
        //     modes = modes.map((mode,i)=>{
        //         // mode.tiers = {
        //         //     1:[], //has a 5th, has a 3rd, can be stacked in 3rds
        //         //     2:[], //has a 5th, has a 3rd, has no contradictions [1,2,3,5]
        //         //     3:[], //has a 5th, has a 3rd, has contradictions but not with 5th and 3rd [1,2,2,3,5]
        //         //     4:[], //has a 5th, has a 3rd, has contradictions but not with BOTH 5ths and 3rds [1,2,3,3,5] / [1,2,3,5,5]
        //         //     5:[], //has a 5th, has a 3rd, has contradictions with both 5ths and 3rds [1,2,3,3,5,5]
        //         //     6:[], //has a 5th, has NO 3rd, has no contradictions [1,5,7]
        //         //     7:[], //has a 5th, has NO 3rd, has contradictions [1,5,5,7] / [1,5,7,7]
        //         //     8:[], //has no 5th, has no contradictions [1,2,3,4,6,7]
        //         //     9:[] //has no 5th, has contradiction [1,2,3,3,6,7]
        //         // }
        //         // let roles = this.scale(mode).get.scale_degree_roles()
        //         // mode.tiers[1].push(...roles.filter(r=>(r.indexOf(5)!=-1 &amp;&amp; r.indexOf(3)!=-1 &amp;&amp; this.get.unique_elements(r).length==r.length)))
        //         // edo.get.stacked(set1.pitches,[3,4])
        //         // console.log(mode.tiers)
        //         // return mode
        //         console.log(this.get.stacked(mode,[3,4]))
        //     })
        // },



        /** Returns the Maximal number of differences for a a scale of cardinality N
         * @param  {Number} N - The cardinality of the scale (how many pitches it has)
         * @return {Number}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO() // create a tuning context
         * edo.get.maximal_rahn_difference(7) //maximal rahn difference for a scale of length 7
         * //returns 126
         * @see Rahn, J. (1991). "Coordination of interval sizes in seven-tone collections." Journal of Music Theory 35(1/2): 33-60.
         * @see Carey, N. (2007). "Coherence and sameness in well-formed and pairwise well-formed scales." Journal of Mathematics and Music 1(2): 79-98.
         * */
        maximal_rahn_difference: (N) => {
            return (N*(N-1)*(N-1))/2
        },

        /** Returns the Maximal number of coherence failures as described in the paper by Carey (see citation)
         * This agrees with Balzano coherency and Rothenberg Propriety, but provides a continues measure rather than a discrete one.
         * @param  {Number} N - The cardinality of the scale (how many pitches it has)
         * @return {Number}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO() // create a tuning context
         * edo.get.maximal_carey_coherence_failures(7) * //returns 140

         * @see Carey, N. (2007). "Coherence and sameness in well-formed and pairwise well-formed scales." Journal of Mathematics and Music 1(2): 79-98.
         * @see Rahn, J. (1991). "Coordination of interval sizes in seven-tone collections." Journal of Music Theory 35(1/2): 33-60.
         * */
        maximal_carey_coherence_failures: (N) => {
            return (N*(N-1)*(N-2)*((3*N)-5))/24
        },

        /**
         * &lt;p>Returns the disposition of &lt;code>chord2&lt;/code> that minimizes movement from &lt;code>chord1&lt;/code>.&lt;/p>
         * &lt;p>Note: &lt;code>chord1&lt;/code> and &lt;code>chord2&lt;/code> must have the same number of pitches&lt;/p>
         * @param  {Array&lt;Number>} chord1 - an origin chord in some disposition
         * @param  {Array&lt;Number>} chord2 - an destination chord
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.minimal_voice_leading([7,0,3],[4,8,11])
         * //returns [8,11,4]
         * */
        minimal_voice_leading: (chord1, chord2) => {
            let permutations = this.get.permutations(chord2)
            let dist = permutations.map(perm=>{
                perm = perm.map((n,i)=>{
                    let res = Math.abs(perm[i]-chord1[i])
                    res = (res>Math.ceil(this.edo/2))?this.edo-res:res
                    return res
                }).reduce((a,el)=>a+el,0)
                return perm
            })
            let min = dist.reduce((min,el)=>(el&lt;min)?el:min,Infinity)
            let pos = dist.indexOf(min)

        return permutations[pos]






        },

        /** Returns the normal order of a given set of pitches
         * @param  {Array&lt;Number>} scale - a collection of PCs
         * @param  {Boolean} cache - if true, the result will be cached for faster retrieval
         * @return {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // create a tuning context
         * edo.get.modes([0,2,4,5,7,9,11]) //Major scale
         * //returns
         * [
         *  [0,2,4,5,7,9,11], //Ionian
         *  [0,2,3,5,7,9,10], //Dorian
         *  [0,1,3,5,7,8,10], //Phrigian
         *  [0,2,4,6,7,9,11], //Lydian
         *  [0,2,4,5,7,9,10], //Mixolydian
         *  [0,2,3,5,7,8,10], //Aeolian
         *  [0,1,3,5,6,8,10]  //Locrian
         * ]
         * */
        modes: (scale, cache = false, avoid_duplications = true) => {
            let edo = this.edo
            if (!this.catalog[String(scale)]) this.catalog[String(scale)] = {}
            if (this.catalog[String(scale)]['modes']) return this.catalog[String(scale)]['modes']


            let length = scale.length
            let doubled = scale.concat(scale)


            let modes = []

            for (let i = 0; i &lt; length; i++) {
                let shift = this.edo - doubled[i]
                let mode = doubled.slice(i, i + length)
                mode = mode.map((el) => (el + shift) % this.edo)
                modes.push(mode)
            }
            if (avoid_duplications) modes = this.get.unique_elements(modes)
            if (cache) this.catalog[String(scale)]['modes'] = modes

            return modes
        },

        /**
         * &lt;p>Extracts every possible "motive" from a given melody.&lt;/p>
         * &lt;p>A motive can be intervalic (default) such that it looks at the intervals rather than the pitch classes.
         * The function also keeps track of the number of times each motive appeared.&lt;/p>
         * @param  {Array&lt;Number>} melody - a collection of pitches to find (in order)
         * @param  {Boolean} [intervalic=true] - looks at the intervals rather than the pitch classes.
         * @param  {Boolean} [allow_skips=true] - if false, the search will only be done on consecutive items
         * @param  {Number} [maximal_length=8] - Do not look for motives longer than this value
         * @return {Array&lt;motives>}
         * @memberOf EDO#get
         * @function
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.motives([7,6,7,6,7,2,5,3,0]).slice(0,4) //get first 3 motives
         * //returns
         * [
         *   { motive: [ -1, 1 ], incidence: 2 }, //going a half-step down, then up appears twice
         *   { motive: [ -1 ], incidence: 2 }, //going a half-step down appears twice
         *   { motive: [ 1 ], incidence: 2 } //going a half-step up appears twice
         * ]
         */
        motives: (melody, intervalic = true, allow_skips = false,maximal_length=8) => {
            let motives = []
            if (!intervalic) {
                let all_subsets = this.get.unique_elements(this.get.subsets(melody, allow_skips).filter(s=>s.length&lt;=maximal_length))
                all_subsets.forEach((subset) => {
                    let incidence = this.get.subset_indices(subset, melody, allow_skips).length
                    motives.push({motive: subset, incidence: incidence})
                })
            } else {
                let all_subsets = this.get.subsets(melody, allow_skips).filter(s=>s.length&lt;=maximal_length).map((subset) => this.convert.to_steps(subset))
                let unique_subsets = this.get.unique_elements(all_subsets)

                motives = unique_subsets.map((subset) => {
                    let count = 0
                    for (let i = 0; i &lt; all_subsets.length; i++) {
                        if (this.is.same(subset, all_subsets[i])) count++
                    }
                    return {motive: subset, incidence: count}
                })
            }


            motives = motives.filter((motive) => motive.motive.length > 0)
            motives = motives.sort((a, b) => b.incidence - a.incidence || b.motive.length - a.motive.length)

            return motives
        },

        /** Returns all necklaces from a given set of steps
         * @param  {Array&lt;Number>} lst - a set of intervals
         * @return {Array&lt;Array&lt;Number>>} Necklaces
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12)
         * edo.get.necklace([2,2,1,2,2,2,1])
         * //returns
         * [ //These are the 3 unique orderings of the intervals in the input
         *  [2, 2, 2, 1, 2, 2, 1], //any other combination would be some rotation of
         *  [2, 2, 2, 2, 1, 2, 1], //one of these
         *  [2, 2, 2, 2, 2, 1, 1]
         * ]
         * @see {@link https://en.wikipedia.org/wiki/Necklace_(combinatorics)}
         * */
        necklace: (lst) => {
            let necklaces = []
            let unique_steps = this.get.unique_elements(lst)
            let map = {}
            let n = []
            unique_steps.forEach((step, i) => {
                map[i] = step
                let count = lst.reduce((t, el) => {
                    return (el == step) ? t + 1 : t
                }, 0)
                n.push(count)
            })
            let mynecklace = new FixedContentNecklace(n)

            let result = Array.from(mynecklace.execute('fast'))

            result.forEach((entry) => {
                let new_arr = entry.map((el) => map[el])
                necklaces.push(new_arr)
            })
            return necklaces
        },

        /** Returns the pitch and its position where it first appeared in a melody
         * @param  {Array&lt;Number>} melody - a melody to be analyzed
         * @param  {Boolean} as_PC - when true, the algorithm views all notes as similar if they belong to the same PC
         * @return {Array&lt;Array&lt;Number>>} a "tuple" of [pitch,position]
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12)
         * edo.get.new_pitches([2,1,0,5,4,3,0,2,8,4,1,0,9,1])
         * //returns
         * [
         *  [2, 0],
         *  [1, 1],
         *  [0, 2],
         *  [5, 3],
         *  [4, 4],
         *  [3, 5],
         *  [8, 8],
         *  [9, 12],
         * ]
         * */
        new_pitches: (melody, as_PC = true) => {
            let result = []
            let seen = []

            for (let i = 0; i &lt; melody.length; i++) {
                if (as_PC) {
                    if (seen.indexOf(this.mod(melody[i], this.edo)) == -1) {
                        seen.push(melody[i])
                        result.push([melody[i], i])
                        if (seen.length == this.edo) break
                    }
                } else {
                    if (seen.indexOf(melody[i]) == -1) {
                        seen.push(melody[i])
                        result.push([melody[i], i])
                    }
                }
            }
            return result
        },

        /** Returns all the ngrams up to a given n from a given melody.
         * @param  {Array&lt;Number>} melody - a melody to be analyzed
         * @param  {Number} [n=3] - The maximal length ngram to be generated
         * @return {Array&lt;Object>} A dictionary that given an ngram key, returns the prediction.
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.ngrams([4,4,5,7,7,5,4,2,0,0,2,4,4,2,2])
         * //returns
         * {
         *  '0': [ 0, 2 ],
         *  '2': [ 0, 4, 2 ],
         *  '4': [ 4, 5, 2, 4, 2 ],
         *  '5': [ 7, 4 ],
         *  '7': [ 7, 5 ],
         *  '4 4': [ 5, 2 ],
         *  '4 5': [ 7 ],
         *  '5 7': [ 7 ],
         *  '7 7': [ 5 ],
         *  '7 5': [ 4 ],
         *  '5 4': [ 2 ],
         *  '4 2': [ 0, 2 ],
         *  '2 0': [ 0 ],
         *  '0 0': [ 2 ],
         *  '0 2': [ 4 ],
         *  '2 4': [ 4 ]
         * }
         * */
        ngrams: (melody, n = 3) => {
            let ngrams = {}
            for (; n > 1; n--) {
                for (let i = 0; i &lt; melody.length - (n - 1); i++) {
                    let key = []
                    for (let j = i; j &lt; i + (n - 1); j++) {
                        key.push(melody[j])
                    }
                    key = key.join(' ')
                    if (Array.isArray(ngrams[key])) ngrams[key].push(melody[i + (n - 1)])
                    else ngrams[key] = [melody[i + (n - 1)]]
                }
            }
            return ngrams
        },

        /** Returns the normal order of a given set of pitches
         * @param  {Array&lt;Number>} lst - a collection of PCs
         * @param  {Boolean} cache - if true, the result will be cached for faster retrival
         * @return {Array&lt;Number>} The normal order of the input
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.normal_order([0,2,4,5,7,9,11])
         * //returns [0, 1, 2, 3, 5, 6, 8, 10]*/
        normal_order: (lst, cache = false) => {
            if (lst.length == 0) return []
            let edo = this.edo
            if (!this.catalog[String(lst)]) this.catalog[String(lst)] = {}
            if (this.catalog[String(lst)]['normal_order']) return this.catalog[String(lst)]['normal_order']


            let pitches = []
            lst.forEach((pitch) => {
                pitches.push(pitch % this.edo)
            })


            pitches = this.get.unique_elements(pitches)

            pitches.sort((a, b) => a - b)
            let modes = this.get.modes(pitches)
            let organize = function (modes) {
                let smallest = edo
                let filtered_modes = []
                modes.forEach(mode => {
                    if (mode[mode.length - 1] &lt; smallest) smallest = mode[mode.length - 1]
                })
                modes.forEach(mode => {
                    if (mode[mode.length - 1] == smallest) filtered_modes.push(mode)
                })
                if (filtered_modes.length == 1) return filtered_modes[0]
                else {
                    let last = filtered_modes[0][filtered_modes[0].length - 1]
                    let truncated_modes = filtered_modes.map((mode) => {
                        return mode.slice(0, -1)
                    })
                    let normal_order = organize(truncated_modes)
                    normal_order.push(last)
                    return normal_order
                }
                return 0
            }

            let result = organize(modes)
            if (cache) {
                this.catalog[String(lst)]['normal_order'] = result
            }
            return result
        },

        /** Returns the given pitches, stacked with the given intervals
         * @param  {Array&lt;Number>} pitches - a collection of pitches
         * @param  {Array&lt;Number>} intervals - The intervals with which to stack
         * @param  {Boolean} transposed_to_0 - When true, the returned sets will be transposed to start from 0
         * @return {Array&lt;Array&lt;Number>>} All the stacks that can be created with the given pitches using the given intervals
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.stacked([0,2,4,6,9],[3,4])
         * //returns [ [ 2, 6, 9, 12, 16 ] ]
         *
         * edo.get.stacked([0,2,4,6,9],[3,4,5],true)
         * //returns [ [ 0, 4, 9, 14, 18 ], [ 0, 4, 7, 10, 14 ] ]
         * */
        stacked: (pitches, intervals,transposed_to_0=false) => {
            let perms = this.get.permutations(pitches)
            let available =[]
            for (let perm = 0; perm &lt; perms.length; perm++) {
                let p = perms[perm]
                for (let i = 0; i &lt;p.length; i++) {
                    if(i==0) 1+1
                    let multiplier =1
                    while(p[i]&lt;p[i-1]) {
                        p.splice(i,1,p[i]+(this.edo*multiplier))
                        multiplier++
                    }
                    if(intervals.indexOf(p[i]-p[i-1])==-1 &amp;&amp; i!=0) {
                        p=false
                        continue
                    }
                }
                if(p) {
                    if(transposed_to_0) available.push(this.get.transposition(p,p[0]*-1,false))
                    else available.push(p)
                }
            }
            return available
        },

        /** Returns the elements of array1, but not if they are found in array 2
         * @param  {Array&lt;Number>} array1 - a collection of PCs
         * @param  {Array&lt;Number>} array2 - a collection of PCs
         * @param  {Boolean} [normal=false] - when true, the returned set will be in normal order
         * @return {Array&lt;Number>} All of the elements of array1 that are not in array2
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.without([0,1,3,4,6,7,9,10],[0,4,9])
         * //returns [1,3,6,7,10]
         *
         * edo.get.without([0,1,3,4,6,7,9,10],[0,4,9],true)
         * //returns [0,2,5,6,9]*/
        without: (array1, array2, normal = false) => {
            let copy = [...array1]
            array2.forEach((note) => {
                do {
                    var index = copy.indexOf(note);
                    if (index != -1) copy.splice(index, 1);
                } while (index!=-1)

            })
            if (normal) copy = this.get.normal_order(copy)

            return copy
        },

        /**
         * &lt;p>Gets an array with element-wise possibilities, and returns every subset given these possibilities&lt;/p>
         * &lt;p>For instance, given &lt;code>[4,[7,8],[9,10,11]]&lt;/code> the function will return every set starting with 4, with EITHER 7 or 8 in the 2nd position, and EITHER 9, 10, or 11 in the 3rd. &lt;/p>
         * @param  {Array&lt;Number>} arr - element-wise possibilities
         * @example
         * edo.get.partitioned_subsets([4,[7,8],[10,11]])
         * //returns
         * [ [ 4, 7, 10 ], [ 4, 7, 11 ], [ 4, 8, 10 ], [ 4, 8, 11 ] ]
         * @return {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         */
        partitioned_subsets: (arr) => {
            arr = arr
                .map((el) => !Array.isArray(el) ? [el] : el)

            let findings = []
            const recur = function (sub) {

                for (let i = 0; i &lt; sub.length; i++) {
                    if (sub[i].length > 1) {
                        sub[i].forEach((el) => {
                            if (i &lt; sub.length - 1) {
                                let thing = [...sub.slice(0, i), [el], ...sub.slice(i + 1)]
                                recur(thing)
                            } else {
                                findings.push([...sub.slice(0, i), [el]])
                            }
                        })
                        break
                    } else {
                        if (i == sub.length - 1) findings.push(sub)
                    }
                }
            }

            recur(arr)
            findings = findings.map((subset) => subset.map((el) => el[0]))
            return findings


        },

        /** Returns all the ways to reach a destination pitch by providing a set of motives and a number of steps
         *
         * @example
         * // returns [3,3,-3]
         * get.path_n_steps(3,[[3],[-3]],3)
         * @param  {Number} destination - the destination note. This is an int that represents some interval away from 0.
         * @param  {Array&lt;Array&lt;Number>>} motives - a list of motives to be used
         * @param  {Number} n_steps - The exact number of pitches needed
         * @return {Array&lt;Array&lt;Number>>} An array of all the ways possible.
         * @memberOf EDO#get*/
        path_n_steps: (destination, motives = [], n_steps = 8) => {
            const up_motives = motives.filter((m) => this.get.interval_traversed(m) > 0)
            const down_motives = motives.filter((m) => this.get.interval_traversed(m) &lt; 0)
            const static_motives = motives.filter((m) => this.get.interval_traversed(m) == 0)
            let success = []
            const run_it = function (used = []) {
                let sum = used.flat().reduce((t, e) => t + e, 0)
                let length = used.flat().length
                if (length > n_steps || (length == n_steps &amp;&amp; sum != destination)) return null
                if (length == n_steps &amp;&amp; sum == destination) return used
                if (sum &lt; destination) {
                    for (let i = 0; i &lt; up_motives.length; i++) {
                        let result = run_it(used.concat([up_motives[i]]))

                        if (result != null) success.push(result)
                    }
                } else if (sum > destination) {
                    for (let i = 0; i &lt; down_motives.length; i++) {
                        let result = run_it(used.concat([down_motives[i]]))
                        if (result != null) success.push(result)
                    }
                }
                for (let i = 0; i &lt; static_motives.length; i++) {
                    let result = run_it(used.concat([static_motives[i]]))
                    if (result != null) success.push(result)
                }

            }
            run_it()

            return this.get.unique_elements(success)
        },

        /** &lt;p>Returns the path taken (as pitches) after climbing up a interval "fractal" tree.&lt;/p>
         *
         * &lt;p>In an interval tree where each branch adds (or subtracts) an interval recursively.
         * For instance, such a tree could have 2 interval branches. One "on the left" adding -3 to the current
         * pitch, and the one "on the right" adding +2 to the current pitch.
         * If you climbed this tree using some path, for instance "left, left, right, left, right, right", you
         * will in essence move &lt;code>[-3, -3, +2, -3, +2, +2]&lt;/code> such that if you start with pitch class 0 you get:
         * &lt;code>[0, -3, -6, -4, -7, -5, -3]&lt;/code> which if we ignore octave (i.e. indicate pitch classes) we get: &lt;code>[0, 9, 6, 8, 5, 7, 9]&lt;/code>.&lt;/p>
         *
         *
         * @param  {Array&lt;Number>} intervals - the "branches" coming out of each node on the tree. For instance, &lt;code>[3,-3,2]&lt;/code>
         * would represent a tree with three branches coming out of each node, the leftmost is +3 the middle one is -3,
         * and the rightmost one is +2.
         *
         * @param  {Array&lt;Number>} path - the indication of how to traverse the tree. The list contains the indexes of
         * the branch to be climbed at each iteration. so &lt;code>[0,0,1,1,2]&lt;/code> would mean go up the leftmost branch twice,
         * then go up the middle branch twice, finally go up the rightmost branch once (Note, this example uses
         * three branches, but there could be any number of branches).
         *
         * @param  {Number} [starting_pitch=0] - Indicates the starting pitch of the tree
         * (the pitch to be added to rather than starting at 0).
         *
         * @return {Array&lt;Number>} the path
         * @memberOf EDO#get*/
        path_on_tree: (intervals, path, starting_pitch = 0) => {
            let result = [starting_pitch]
            for (let branch of path) {
                result.push(result[result.length - 1] + intervals[branch]) //adds the interval at index=branch to the last value stored.
            }
            return result
        },

        /**
         * Gets an array and returns every possible ordering of that array.
         * @param  {Array&lt;Number>} pitches - (usually) a collection of pitches, but could be used with any type of array
         * @example
         * edo.get.permutations([0, 2, 3])
         * // [[ 0, 2, 3 ],[ 0, 3, 2 ],[ 2, 0, 3 ],[ 2, 3, 0 ],[ 3, 0, 2 ],[ 3, 2, 0 ]]
         * @return {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         */
        permutations: (inputArr) => {

            let result = [];

            const do_it = (arr, m = []) => {
                if (arr.length === 0) {
                    result.push(m)
                } else {
                    for (let i = 0; i &lt; arr.length; i++) {
                        let curr = arr.slice();
                        let next = curr.splice(i, 1);
                        do_it(curr.slice(), m.concat(next))
                    }
                }
            }

            do_it(inputArr)

            return result;
        },

        /** Returns the distribution (as fractions adding up to 1) of the pitches in a set of pitches
         *
         * @param  {Array&lt;Number>} pitches - a given array of pitches
         * @param  {Boolean} as_PC - When true, the distribution tallies notes based on their PC rather than their absolute pitch.
         * @returns {Array&lt;distribution>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // create a tuning context
         * edo.get.pitch_distribution([8,7,7,8,7,7,8,7,7,15,15,14,12,12,10,8,8,7,5,5]) //Mozart Sym. 40
         * //returns
         * [
         *  { note: 7, rate: 0.35 },
         *  { note: 8, rate: 0.25 },
         *  { note: 15, rate: 0.1 },
         *  { note: 12, rate: 0.1 },
         *  { note: 5, rate: 0.1 },
         *  { note: 14, rate: 0.05 },
         *  { note: 10, rate: 0.05 }
         * ]
         *
         * edo.get.pitch_distribution([0,12,0,12,7,0])
         * //returns
         * [
         *  { note: 0, rate: 0.8333333333333334 },
         *  { note: 7, rate: 0.16666666666666666 }
         * ]
         *
         */
        pitch_distribution: (pitches, as_PC = false) => {
            if (as_PC) pitches = pitches.map((pitch) => this.mod(pitch, this.edo))
            let unique = this.get.unique_elements(pitches)

            let dist = unique.map((el) => {
                return {note: el, rate: pitches.filter(x => x == el).length / pitches.length}
            })
            dist = dist.sort((a, b) => b.rate - a.rate)
            return dist
        },

        /** Returns all the pitches available in windows of size &lt;code>size&lt;/code>
         *
         * @param  {Array&lt;Number>} pitches - a given array of pitches
         * @param  {Number} [size=8] - The size of the window.
         * @param  {Boolean} [as_PC=true] - When true, notes that belong to the same PC will be counted as the same.
         * @param  {Boolean} [unique=false] - When true, the function does not count pitches if they are already in the window.
         * @param  {Boolean} [avoid_duplicate_windows=false] - When true, if two or more succeeding windows have the same content, the function will only return one of them.
         * @returns {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // create a tuning context
         * edo.get.pitch_fields([8,7,7,8,7,7,8,7,7,15,15,14,12,12,10,8,8,7,5,5]) //Mozart Sym. 40
         *[
         *  [ 7, 8 ],
         *  [ 7, 8 ],
         *  [ 3, 7, 8 ],
         *  [ 3, 7, 8 ],
         *  [ 2, 3, 7, 8 ],
         *  [ 0, 2, 3, 7, 8 ],
         *  [ 0, 2, 3, 7, 8 ],
         *  [ 0, 2, 3, 7, 10 ],
         *  [ 0, 2, 3, 7, 8, 10 ],
         *  [ 0, 2, 3, 8, 10 ],
         *  [ 0, 2, 3, 7, 8, 10 ],
         *  [ 0, 2, 5, 7, 8, 10 ],
         *  [ 0, 5, 7, 8, 10 ]
         *]
         *
         * edo.get.pitch_fields([8,7,7,8,7,7,8,7,7,15,15,14,12,12,10,8,8,7,5,5],5,false,true,true) //as_PC=false, unique=true,avoid_duplicate_windows=true
         * [
         *  [ 7, 8, 12, 14, 15 ],
         *  [ 7, 10, 12, 14, 15 ],
         *  [ 8, 10, 12, 14, 15 ],
         *  [ 7, 8, 10, 12, 14 ],
         *  [ 5, 7, 8, 10, 12 ],
         *  [ 5, 7, 8, 10 ]
         * ]
         */
        pitch_fields: (pitches,size=8,as_PC=true, unique=false,avoid_duplicate_windows=false) => {
            if(unique) {
                let partitions = []
                loop1:
                    for (let i = 0; i &lt; pitches.length-size; i++) {
                        let window = [(as_PC)?this.mod(pitches[i],this.edo):pitches[i]]
                        loop2:
                            for (let j = i+1; j &lt; pitches.length; j++) {
                                if(window.length==size) break loop2
                                let el
                                if(as_PC) el = this.mod(pitches[j],this.edo)
                                else el = pitches[j]
                                if(window.indexOf(el)==-1) window.push(el)
                            }
                        window = window.sort((a,b)=>a-b)
                        if(avoid_duplicate_windows) {
                            if(!this.is.same(partitions[partitions.length-1],window)) partitions.push(window)
                        } else partitions.push(window)


                    }
                return partitions
            }
            else {
                let partitions = []
                for (let i = 0; i &lt;= pitches.length-size; i++) {
                    partitions.push(pitches.slice(i,i+size))
                }
                partitions = partitions.map((p)=>{
                    if(as_PC) p = p.map((note)=>this.mod(note,this.edo))
                    p = this.get.unique_elements(p).sort((a,b)=>a-b)

                    return p
                }).filter((el,i,arr)=>{
                    if(i+1!=arr.length) {
                        return !this.is.same(arr[i],arr[i+1])
                    } else return true
                })
                return partitions
            }
        },

        /** Returns an array of (length) (pseudo)random pitches, with lowest note not lower than range[0],
         * and highest note not higher than range[1].
         *
         * @param  {Number} [length=8] - The number of pitches in the melody
         * @param  {Array&lt;number>} [range=[0, 12]] - the lower and upper limits (inclusive) for the melody
         * @param  {Number} [repetition_minimal_gap=0] - number of intervening notes before a note can repeat (the same PC across different octave is not considered the same note)
         * @param  {Array&lt;number>} [mode] - If mode is provided, the pitches returned will be only ones
         * that appear in the mode provided.
         * @param  {Number} [avoid_leaps_over=5] - The generator will attempt to avoid returning melodies that leap beyond the this IC.
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.random_melody(4,[-3,2]) //returns e.g. [ -3, 0, 2, -2 ]
         * edo.get.random_melody(4, [-3, 2],1) //returns e.g. [ 1, -3, 2, -3 ]
         * edo.get.random_melody(6, [0, 17], 6,[0, 2, 4, 5, 7, 9, 11]) // returns e.g. [ 16, 12, 14, 7, 11, 5 ]
         * edo.get.random_melody(6, [0, 17], 3,[0, 2, 4, 5, 7, 9, 11],3) // returns e.g. [ 14, 16, 12, 9, 11, 14 ]
         */
        random_melody: (length = 8, range = [0, 12], repetition_minimal_gap = 4, mode, avoid_leaps_over = 5) => {
            let counter = 0
            let melody = []
            let pitch_pool = []
            for (let i = range[0]; i &lt;= range[1]; i++) {
                if (mode) {
                    if (mode.indexOf(this.mod(i, this.edo)) == -1) continue
                }
                pitch_pool.push(i)
            }
            while (melody.length &lt; length &amp;&amp; counter &lt; 1000) {
                counter++
                let submelody = melody.slice(Math.max(melody.length - repetition_minimal_gap, 0), melody.length)
                // if(!allow_pc_repetition &amp;&amp; submelody.length>0) submelody = this.get.normal_order(submelody) //normal order

                let allow_pitches = pitch_pool.filter((pitch) => {
                    if (submelody.indexOf(pitch) == -1) return true
                    else return false
                })
                if (melody.length > 0) {
                    let leapless = []
                    do {
                        leapless = allow_pitches.filter((pitch) => {
                            if (Math.abs(pitch - melody[melody.length - 1]) &lt;= avoid_leaps_over) return true
                            return false
                        })
                        avoid_leaps_over++
                    } while (leapless.length == 0)
                    allow_pitches = leapless
                }

                let ind = Math.floor(Math.random() * (allow_pitches.length));
                melody.push(allow_pitches[ind])

            }
            return melody

        },

        /** Returns an array of (length) (pseudo)random pitches, with lowest note not lower than range[0],
         * and highest note not higher than range[1].
         *
         * @param  {Array&lt;Number>} contour - The contour. For instance [0,2,1,2,0] = [low high mid high low] but you can have as many "heights" as you'd like.
         * @param  {Array&lt;number>} [range=[0, 12]] - the lower and upper limits (inclusive) for the melody
         * @param  {Array&lt;number>} [mode] - If mode is provided, the pitches returned will be only ones
         * that appear in the mode provided.
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.random_melody_from_contour([0,3,1,3,2],[0,12],[0,2,4,5,7,9,11]); //returns e.g. [ 2, 11, 7, 11, 9 ]
         */
        random_melody_from_contour: (contour, range = [0, 12], mode) => {
            let available_pitches = []
            let used_pitches = []
            let contour_ordered_unique = this.get.unique_elements([...contour]).sort((a, b) => a - b)
            let len = contour_ordered_unique.length - used_pitches.length
            for (let i = range[0]; i &lt;= range[1]; i++) {
                if (mode) {
                    if (mode.indexOf(this.mod(i, this.edo)) != -1) available_pitches.push(i)
                } else {
                    available_pitches.push(i)
                }
            }
            while (used_pitches.length &lt; len) {
                let item_i = Math.floor(Math.random() * available_pitches.length)
                let item = available_pitches.splice(item_i, 1)[0]
                used_pitches.push(item)
                len = contour_ordered_unique.length
            }
            used_pitches = used_pitches.sort((a, b) => a - b)

            let lexicon = {}
            for (let i = 0; i &lt; contour_ordered_unique.length; i++) {
                lexicon[contour_ordered_unique[i]] = used_pitches[i]
            }
            contour = contour.map((el) => lexicon[el])
            return contour
        },

        /** Returns an array of (length) based on an ngram analysis of a given input.
         *
         * @param  {Array&lt;Object>} ngrams - A list of ngrams (as returned from [EDO.get.ngrams()]{@link EDO#get.ngrams})
         * @param  {Array&lt;number>} [start=[0]] - The starting pitch / phrase (multiple pitches) of the melody
         * @param  {Array&lt;number>} [length=16] - The length of the output melody
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * let ngrams = edo.get.ngrams([4,4,5,7,7,5,4,2,0,0,2,4,4,2,2],4)
         * edo.get.random_melody_from_ngram(ngrams);
         * //returns
         * [0, 2, 4, 4, 2, 2, 4, 4, 2, 2, 0, 0, 2, 4, 4, 2]
         * @see EDO#get.ngrams
         */
        random_melody_from_ngram: (ngrams, start = [0], length = 16) => {
            let melody = [...start]
            let escape = 100 + length
            loop1:
                while (melody.length &lt; length &amp; escape > 0) {
                    loop2:
                        for (let i = melody.length; i > 0; i--) {
                            let sub = melody.slice(melody.length - i)
                            let entry = ngrams[sub.join(" ")]
                            if (Array.isArray(entry)) {
                                let random_pitch = entry[Math.floor(Math.random() * entry.length)]
                                melody.push(random_pitch)
                                break loop2;
                            }
                        }
                    escape--
                }
            return melody
        },

        /** Returns a random melody of length based on a distribution (as generated by [EDO.get.pitch_distribution()]{@link EDO#get.pitch_distribution}).
         *
         * @param  {Array&lt;Object>} dist - A stratistical distribution of pitches (as returned from [EDO.get.pitch_distribution()]{@link EDO#get.pitch_distribution})
         * @param  {Array&lt;number>} [length=8] - The length of the output melody
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * let dist = edo.get.pitch_distribution([4,4,5,7,7,5,4,2,0,0,2,4,4,2,2])
         * edo.get.random_melody_from_distribution(dist);
         * //returns
         * [4, 4, 2, 2, 0, 2, 2, 7]
         * @see EDO#get.pitch_distribution
         */
        random_melody_from_distribution: (dist, length = 8) => {
            let melody = []
            dist = dist.sort((a, b) => a.rate - b.rate)
            let multiplier = Math.floor(1 / dist[0].rate)
            dist = dist.map((el) => [...new Array(Math.ceil(multiplier * el.rate)).fill(el.note)])
            dist = dist.flat()
            while (melody.length &lt; length) {
                let ind = Math.floor(Math.random() * (dist.length))
                melody.push(dist[ind])
            }
            return melody
        },

        /** Returns the closest ratio (within a given limit) for any interval class.
         * @param  {Number} interval - An interval class
         * @param  {Number} [limit=17] - The harmonic limit
         * @param  {Boolean} cache - if true, the result will be cached for faster retrival
         * @return {Object}
         * @returns {approximation}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // create a tuning context
         * edo.get.ratio_approximation(7)
         * //returns { ratio: '3/2', cents_offset: -1.955000865387433, decimal: 1.5 }
         *
         * let edo = new EDO(17) // Notice this is 17 divisions
         * console.log(edo.get.ratio_approximation(3))
         * //returns {ratio: '17/15', cents_offset: -4.921988887832043, decimal: 1.1333333333333333}
         *
         */
        ratio_approximation: (interval, limit = 17) => {
            let closest_ratio = 0
            let closest_name = ""
            let numeric = 0
            let interval_in_cents = this.convert.interval_to_cents(interval)
            let ratios = this.get.simple_ratios(limit = limit)
            for (let ratio in ratios) {
                let side_a = Math.abs(ratios[ratio]['cents'] - interval_in_cents)
                let side_b = Math.abs(interval_in_cents - closest_ratio)
                if (side_a &lt; side_b) {
                    closest_ratio = ratios[ratio]['cents']
                    closest_name = ratio
                    numeric = ratios[ratio]['value']
                }
            }
            let num_den = closest_name.split('/')
            let numerator = num_den[0]
            let denominator = num_den[1]
            return {
                ratio: closest_name,
                cents_offset: interval_in_cents - closest_ratio,
                decimal: numeric,
                octave: Math.log2(parseInt(denominator)),
                log_position: Math.log2(numeric)
            }
        },

        /** Returns the retrograde of a given set of pitches (their reversed order)
         *
         * @param  {Array&lt;Number>} scale - a collection of pitches (not necessarily PCs)
         * @return {Array&lt;Number>} The reversed input
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.retrograde([0,2,4,5,7,9,11])
         * //returns [11,9,7,5,4,2,0]*/
        retrograde: (pitches) => {
            return pitches.reverse()
        },

        /**
         * &lt;p>Returns a given collection of pitches, rotated n times.
         * @param  {Array&lt;Number>} pitches - a collection of pitches (not necessarily PCs, not necessarily unique)
         * @param  {Number} n - Number of rotations
         * @return {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.rotations([0,2,4,5,7],2) //returns [4,5,7,0,2]
         * edo.get.rotations([0,2,4,5,7],-1) //returns [7,0,2,4,5]
         * */
        rotated: (pitches,n) => {
            n=this.mod(n,pitches.length)
            return [...pitches.slice(n),...pitches].slice(0,pitches.length)
        },


        /**
         * &lt;p>Returns all the rotations (inversions) of an array of pitches&lt;/p>
         * @param  {Array&lt;Number>} pitches - a collection of pitches (not necessarily PCs, not necessarily unique)
         * @return {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.get.rotations([0,4,7,4])
         * //returns [ [ 0, 4, 7, 4 ], [ 4, 7, 4, 0 ], [ 7, 4, 0, 4 ], [ 4, 0, 4, 7 ] ]
         * */
        rotations: (pitches) => {
            let rotations = []
            for (let i = 0; i &lt; pitches.length; i++) {
                rotations.push([...pitches.slice(i, pitches.length), ...pitches.slice(0, i)])
            }
            return rotations
        },

        /**
         * &lt;p>Returns all the melodies that can be constructed without any leaps (regardless of how many notes in the melody need to be skipped until next scalar note is found)&lt;/p>
         * @param  {Array&lt;Number>} melody - a collection of pitches (not necessarily PCs, not necessarily unique)
         * @param  {Array&lt;Number>} [steps=[1,2]] - which PCs to consider as steps
         * @param  {Boolean} [look_back=true] - When true, the algorithm creates alternate paths to already resolves melodies. When false, resolved melodies will not be considered and a new path will begin.
         * @return {Array&lt;Object>} object with property &lt;code>pitch&lt;/code> indicating the pitch, and property &lt;code>index&lt;/code> representing its original position in the melody.
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * let melody = [2,2,4,2,7,6,2,2,4,2,9,7] //happy birthday song
         * edo.get.scalar_melodies(melody)
         * //returns
         * [
         *  [
         *      { pitch: 2, index: 0 },
         *      { pitch: 2, index: 1 },
         *      { pitch: 4, index: 2 },
         *      { pitch: 2, index: 3 },
         *      { pitch: 2, index: 6 },
         *      { pitch: 2, index: 7 },
         *      { pitch: 4, index: 8 },
         *      { pitch: 2, index: 9 }
         *  ],
         *  [
         *      { pitch: 7, index: 4 },
         *      { pitch: 6, index: 5 },
         *      { pitch: 4, index: 8 },
         *      { pitch: 2, index: 9 }
         *  ],
         *  [
         *      { pitch: 7, index: 4 },
         *      { pitch: 9, index: 10 },
         *      { pitch: 7, index: 11 }
         *  ],
         * ]
         * */
        scalar_melodies: (melody,steps=[1,2],look_back=true)=> {
            steps.push(0)
            let melodies = []
            melody.forEach((note,ind)=> {
                let in_any=false
                for (let i = 0; i &lt; melodies.length; i++) {
                    let mel = melodies[i]
                    let last_note = mel[mel.length-1].pitch
                    let step_size = Math.abs(note-last_note)
                    let scalar = this.is.element_of(step_size,steps)
                    if(scalar) {
                        melodies[i].push({pitch:note,index:ind})
                        in_any=true
                    }
                }
                if(!in_any) {
                    let possible = []
                    if(look_back) {
                        let look_for=[]
                        steps.forEach(s=>{
                            look_for.push(note+s)
                            look_for.push(note-s)
                        })
                        look_for=this.get.unique_elements(look_for)
                        look_for.forEach((n)=>{
                            melodies.map(m=>m.map(el=>el.pitch)).forEach((m,index1)=>{
                                if(m.includes(n)) {
                                    let last = m.lastIndexOf(n)
                                    possible.push([note,ind,index1,last])
                                    // possible.push([m,m.lastIndexOf(n)])
                                }
                            })
                        })
                        possible = possible.map(el=>{
                            let mel = melodies[el[2]].slice(0,el[3]+1)
                            mel = [...mel,{pitch:el[0],index:el[1]}]
                            return mel
                        })
                        melodies = [...melodies,...possible]
                    }
                    if(possible.length==0) melodies.push([{pitch:note,index:ind}])

                }
            })
            return melodies
        },

        /** Generates all possible necklaces (unique scales without their modes) based on input parameters.
         *
         * @param  {Number} min_step - The smallest step size that can be used to form scales. If min_step=3, no scale will contain
         * intervals smaller than 3 (so no intervals of size 2, or 1 will be found in any scale)
         * @param  {Number} max_step - The largest step that can be used to form scales. If max_step=3, no scale will contain
         * intervals larger than 3 (so no intervals of size >3 will be found in any scale)
         * @param  {Number} min_sizes - The minimal amount of variety in step size needed to make a scale. if min_sizes=2,
         * then scales with step sizes that belong to fewer than 2 interval classes will not be included.
         *
         * In the case of min_sizes=2, the following scales will be excluded: [0,1,2,3,4,5,6,7,8,9,10,11],
         * [0,2,4,6,8,10], [0,3,6,9], etc.
         *
         * * @param  {Number} max_sizes - The maximal amount of variety in step size allowed to make a scale.
         * if max_sizes=2, then scales that use more than 2 step sizes will be excluded.
         *
         * In the case of max_sizes=2, the following scale will be excluded: [0,1,4,5,7,10,11], because it has >2 (3)
         * step sizes. step size=1 between 0 and 1, step size=2 between 5 and 7, and step size = 3 between 1 and 4.
         * @return {Array&lt;Scale>} all the scales that abide by the criteria given
         * @memberOf EDO#get*/
        scales: (min_step = 1, max_step = this.edo - 1, min_sizes = 1, max_sizes = this.edo, max_num_of_pitches=this.edo,EDO = this,) => {

            //get all unique combinations of size s from set of intervals set
            const calc_comb = (s, set) => {
                let solutions = []
                for (let i = 0; i &lt; set.length; i++) {
                    let n = set[i]
                    let m = Math.floor(s / n) //Max times n fits in s
                    if (s / n == m &amp;&amp; set.length == 1) solutions.push(Array(m).fill(n))
                    let new_set = [...set]
                    new_set.splice(i, 1)
                    if (new_set.length > 0) {
                        for (let k = m; k != 0; k--) {
                            let new_sum = s - (k * n)
                            if (new_sum > 0) {
                                let new_result = calc_comb(new_sum, new_set)
                                if (new_result.length > 0) {
                                    for (let r = 0; r &lt; new_result.length; r++) {
                                        let solution = Array(k).fill(n).concat(new_result[r].flat())
                                        solution.sort((a, b) => a - b)
                                        solutions.push(solution)
                                    }
                                }
                            }
                        }
                    }


                }
                return this.get.unique_elements(solutions)
            }

            //returns all possible step sizes based on the min_step and max_step parameters
            const get_step_sizes = function (min_step, max_step) {
                let step_sizes = []
                for (let i = max_step; i != min_step - 1; i--) {
                    step_sizes.push(i)
                }
                return step_sizes
            }

            //returns all possible step combination between min_sizes and max_sized from step_sizes
            const get_interval_combinations = function (min_sizes, max_sizes, step_sizes) {
                let step_combinations = []
                for (let window_size = min_sizes; window_size &lt;= max_sizes; window_size++) {
                    step_combinations = step_combinations.concat(combinations(step_sizes, window_size))
                }
                return step_combinations
            }

            //get the unique interval partitions for each set of possible interval combinations
            const unique_for_all = function (interval_combinations) {
                let collection = []
                interval_combinations.forEach((combo) => {
                    let unique_step_combination = calc_comb(EDO.edo, combo)
                    if (unique_step_combination.length > 0) {
                        collection = collection.concat(unique_step_combination)
                    }
                })
                return collection
            }

            //make all possible necklaces out of interval combinations given in [combos]
            const make_all_necklaces = function (combos) {
                let all_necklaces = []
                for (let i = 0; i &lt; combos.length; i++) {
                    let combo = combos[i]
                    let necklaces = EDO.get.necklace(combo)
                    all_necklaces = all_necklaces.concat(necklaces)
                }
                return all_necklaces

            }

            const get_all_scales = (all_necklaces) => {
                let all_scales = []

                all_necklaces.forEach((necklace) => {
                    all_scales.push(EDO.convert.intervals_to_scale(necklace))
                })
                return all_scales
            }

            let step_sizes = get_step_sizes(min_step, max_step)

            let interval_combinations = get_interval_combinations(min_sizes, max_sizes, step_sizes)
            let combos = unique_for_all(interval_combinations).filter(combo=>combo.length&lt;=max_num_of_pitches)
            let all_necklaces = make_all_necklaces(combos)

            let _scales = get_all_scales(all_necklaces)
            let scales = []
            _scales.forEach((scale) => scales.push(new Scale(scale, this).normal()))
            scales = this.sort_scales(scales)


            return scales


        },

        /** &lt;p>Finds the required operation to get to a destination note using given intervals&lt;/p>
         *
         * &lt;p>Finds the shortest path towards a given note (destination) by starting on note 0 and moving using the
         * intervals provided.
         * For instance, for &lt;code>destination = -4&lt;/code> and &lt;code>intervals = [-7,3]&lt;/code> (reaching -4, by only moving up by minor 3rds (3) and down by perfect
         * 5ths (-7)), the function will return &lt;code>[3,3,3,3,3,3,-7,-7]&lt;/code> which is the shortest way to get from 0
         * to -4 using only these intervals.&lt;/p>
         *
         * &lt;p>Note: the order of the intervals is mutable and can be jumbled up at will without harming the
         * result. In the example given, as long as there are six 3s and two -7s. the sum will be -4. So
         * there is potential for permutations.&lt;/p>
         *
         *
         * @param  {Number} destination - the destination note. This is an int that represents some interval away from 0.
         * @param  {Array&lt;Number> | Number} intervals - the interval classes to be used (usually at least one positive interval to move up and one negative to move down)
         * @return {Array&lt;Array&lt;Number>>} an sorted array of the intervals needed to reach the destination starting from 0.
         * @memberOf EDO#get
         * @example
         * //The quickest way to get to E (from 0) moving up with P5s and down with m3s
         * let path = edo.get.shortest_path(7,[5,-3]) // returns [ -3, 5, 5 ]
         * let all = edo.get.permutations(path) //all permutation of the result
         * //returns
         * [
         *  [ -3, 5, 5 ],
         *  [ -3, 5, 5 ],
         *  [ 5, -3, 5 ],
         *  [ 5, 5, -3 ],
         *  [ 5, -3, 5 ],
         *  [ 5, 5, -3 ]
         * ]
         * all = all.map((path)=>edo.convert.intervals_to_pitches(path)) //convert the intervals into pitches
         * let as_pitches = all.map((path)=>edo.convert.midi_to_name(path,60)) //convert the pitches into pitch names
         * //returns
         * [
         *  [ 'C4', 'A3', 'D4', 'G4' ],
         *  [ 'C4', 'A3', 'D4', 'G4' ],
         *  [ 'C4', 'F4', 'D4', 'G4' ],
         *  [ 'C4', 'F4', 'Bb4', 'G4' ],
         *  [ 'C4', 'F4', 'D4', 'G4' ],
         *  [ 'C4', 'F4', 'Bb4', 'G4' ]
         * ]
         *
         * */
        shortest_path: (destination, intervals = [5, -3], used = [], life_span = 10) => {

            let up_interval = []
            let down_interval = []
            for (let int of intervals) {
                if (int > 0) up_interval.push(int)
                else if (int &lt; 0) down_interval.push(int)
            }

            let paths = []
            const shortest_path_array = function (destination, up_interval = [3, 4], down_interval = [-1, -2], used = [], life_span = 10) {
                if (life_span &lt; 0) return null

                let sum = used.reduce((a, b) => a + b, 0)
                if (sum == destination &amp;&amp; (paths.length == 0 || paths.length > used.length)) {
                    paths = [...used]
                    return
                } else if (sum == destination &amp;&amp; (paths.length != 0 || paths.length &lt;= used.length)) {
                    return
                }

                if (sum &lt; destination) {
                    for (let num of up_interval) {
                        shortest_path_array(destination, up_interval, down_interval, used.concat([num]), life_span - 1)
                    }
                } else if (sum > destination) {
                    for (let num of down_interval) {
                        shortest_path_array(destination, up_interval, down_interval, used.concat([num]), life_span - 1)
                    }
                }

            }


            shortest_path_array(destination, up_interval, down_interval, used, life_span)
            paths = paths.sort((a, b) => a - b)
            return paths

        },

        /** Returns simple ratios in fraction form, decimal form, and their representation in cents with a given limit.
         * @param  {Number} [limit=17] - the limit
         * @param  {Boolean} cache - if true, the result will be cached for faster retrival
         * @return {Object}
         * @memberOf EDO#get
         */
        simple_ratios: (limit = 17, cache = false) => {
            let primes = this.get.primes_in_range(limit)
            let ratios = {}
            for (let i = 2; i &lt; limit + 1; i++) {
                for (let j = 1; j &lt; i; j++) {
                    if (((primes.indexOf(i) &lt; 0) &amp;&amp; (primes.indexOf(j) &lt; 0)) || (i % 2 == 0 &amp;&amp; j % 2 == 0) || (i % j == 0 &amp;&amp; j > 2)) continue
                    ratios[String(i) + '/' + String(j)] = {cents: this.convert.ratio_to_cents(i / j), value: i / j}
                }
            }
            return ratios
        },

        /** Returns the given pitches, such that they are shifted to start from &lt;code>start_at&lt;/code>.
         * @param  {Array&lt;Number>} pitches - an array of pitches (or PCs)
         * @param  {Number} start_at - The number to which everything will be shifted
         * @param  {Boolean} [as_PCs=true] - when false the shift will respect the octave, when true, the array will be returned containing only Pitch Classes
         * @return {Array&lt;Number>}
         * @memberOf EDO#get
         *
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.starting_at([1,5,8],0)
         * //returns [0,4,7] //Everything shifted such that the starting pitch is 0
         * @example
         * edo.get.starting_at([5,1,8],2,false)
         * //returns [2,-2,5] //Everything shifted such that the starting pitch is 2, and octave is respected
         */
        starting_at: (pitches, start_at = 0, as_PCs = true) => {
            let shift_by = (pitches[0] * -1) + start_at
            let result = pitches.map((pitch) => (as_PCs) ? this.mod(pitch + shift_by, this.edo) : pitch + shift_by)
            return result
        },

        /**
         * Gets a subset to find and returns the indices from a given array (arr) that form that subset
         * @param  {Array&lt;Number>} find - a collection of pitches to find (in order)
         * @param  {Array&lt;Number>} arr - a bigger collection where we search
         * @param  {Boolean} [allow_skips=true] - if false, the search will only be done on consecutive items
         * @example
         * get.subset_indices([0, 2, 3], [0, 0, 2, 0, 2, 3, 3])
         * // returns [[ 0, 2, 5 ], [ 0, 2, 6 ],[ 0, 4, 5 ], [ 0, 4, 6 ],[ 1, 2, 5 ], [ 1, 2, 6 ],[ 1, 4, 5 ], [ 1, 4, 6 ],[ 3, 4, 5 ], [ 3, 4, 6 ]]
         * @return {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         */
        subset_indices: (find, arr, allow_skips = true) => {
            let paths = []

            const run_it_with_skips = function (find, arr, path = [], ind = 0) {
                if (find.length == 0) return path
                let find_this = find[0]
                for (let i = ind; i &lt; arr.length; i++) {
                    if (arr[i] == find_this) {
                        let res = run_it_with_skips(find.slice(1), arr, [...path, i], i + 1)
                        if (res) paths.push(res)
                    }
                }
            }

            const run_it_no_skips = function (find, arr) {
                loop1:
                    for (let i = 0; i &lt; arr.length - (find.length - 1); i++) {
                        loop2:
                            for (let j = 0; j &lt; find.length; j++) {
                                if (find[j] != arr[i + j]) continue loop1
                                if (j == find.length - 1) {
                                    let arr = new Array(find.length).fill(0)
                                    arr.forEach((el, ind) => arr[ind] = i + ind)
                                    paths.push(arr)

                                }
                            }
                    }

            }
            if (allow_skips) run_it_with_skips(find, arr)
            else run_it_no_skips(find, arr)

            return paths
        },

        /** Returns all the subsets (in order) from a given array of pitches.
         * @param  {Array&lt;Number>} pitches - a given array of pitches
         * @param  {Boolean} [allow_skips=true] - if set to false, function will only return subsets that have consecutive members
         * @param  {Boolean} [normal=true] - When true, the returned subsets are converted to normal order
         * @example
         * //returns [[0], [2], [3], [0, 2], [0, 3], [2, 3], [0, 2, 3]]
         * get.subsets([0,2,3],true)
         * @example
         * //returns [[0], [2], [3], [0, 2], [2, 3], [0, 2, 3]]
         * edo.get.subsets([0,2,3],false)
         * @returns {Array&lt;Array&lt;Number>>}
         * @memberOf EDO#get
         */
        subsets: (pitches, allow_skips = true, normal = false) => {
            if (allow_skips) {
                pitches = pitches.reduce(
                    (subsets, value) => subsets.concat(
                        subsets.map(set => [...set, value])
                    ),
                    [[]]
                )
            } else {
                let subsets = []
                for (let window = 1; window &lt; pitches.length + 1; window++) {
                    for (let i = 0; i &lt; pitches.length - window + 1; i++) {
                        subsets.push(pitches.slice(i, i + window))
                    }
                }
                pitches = subsets
            }

            pitches = pitches.filter((el) => el.length > 0)
            if (normal) {
                pitches = pitches.map((subset) => this.get.normal_order(subset))
                pitches = this.get.unique_elements(pitches)
            }
            return pitches
        },

        /** Transposes the input by a given amount
         *
         * @param  {Array&lt;Number>} pitches - a given array of pitches
         * @param  {Number} [amount=0] - the interval by which to transpose
         * @param  {Boolean} [as_PC=true] - if true, the intervals returns will conform to a single octave
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.transposition([0,2,4,5,7,9,11],7)
         * //returns [7, 9, 11, 0, 2, 4,  6]
         */
        transposition: (pitches, amount = 0, as_PC = true) => {
            pitches = pitches.map((pitch) => pitch + amount)
            if (as_PC) pitches = pitches.map((pitch) => this.mod(pitch, this.edo))
            return pitches
        },

        /** Returns the union of two sets
         *
         * @param  {...Array&lt;Number>} collections - Any number of arrays of pitches.
         * @returns {Array&lt;Number>}
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.union([0,1,2],[3,4,5],[6])
         * //returns [0,1,2,3,4,5]
         */
        union: (...collections) => {
            let union = []
            return union.concat(...collections)
        },

        /** Gets an array that may have duplications and returns the array without duplications
         *
         * @param  {Array&lt;number|Array&lt;Number>>} list - an array with duplications
         * @returns {Array&lt;Number>} an array without duplications
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.unique_elements([1,[2,3],2,[2,3],2]) //notice that it accepts nested elements as well
         * //returns [ 1, [ 2, 3 ], 2 ]
         */
        unique_elements: (list) => {

            let unique = new Set(list.map(JSON.stringify));
            unique = Array.from(unique).map(JSON.parse);

            return unique
        },

        /** Generates a well-formed scale in the current EDO with a given cardinality.
         * @param  {Number} [cardinality=7] - The number of pitches in the scale
         * @returns {Array&lt;Number>} A well formed scale
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * edo.get.well_formed_scale(5) //returns [0,2,4,7,9]
         * @see Clough, J. and J. Douthett (1991). "Maximally even sets." Journal of Music Theory 35(1/2): 93-173.
         */
        well_formed_scale: (cardinality=7) => {
            let scale = [...Array(cardinality).keys()].map(n=>Math.floor((n*this.edo)/cardinality))
            return scale
        },

        /** Gets a melody, and attempts to remove chromatic passing tones
         *
         * @param  {Array&lt;number>} melody - an array representing a melody
         * @returns {Array&lt;Number>} The array without the chromatic passing tones
         * @memberOf EDO#get
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * let melody = [12,10,9,8,7,6,8,10,11,12,10,9,8,7,6,8,10,11,12,14,19,15] //syrinx
         * edo.get.without_chromatic_notes(melody)
         * //returns [0, 12, 6, 8, 12, 6, 8, 12, 14, 19, 15]
         */
        without_chromatic_notes: (melody)=> {
            melody = melody.filter((n,i,m)=>{
                let adder = 0
                if(i>0) {
                    if(m[i-1]>m[i]) adder=-1
                    else if(m[i-1]&lt;m[i]) adder=1
                }
                if(m[i]+adder==m[i+1]) return false
                return true

            })

            return melody
        },

        primes_in_range: (upper = 17, lower = 2) => {
            let primes = []
            for (let num = lower; num &lt;= upper; num++) {
                if (num > 1) {
                    for (let i = 2; i &lt; num; i++) {
                        if (num % i == 0) break
                        else primes.push(num)
                    }
                }
            }
            return primes
        },
        divisors: (n) => {
            let divisors = []
            for (let i = 2; i &lt; Math.ceil(n / 2); i++) {
                if (n % parseInt(i) == 0) divisors.push(i)
            }
            return divisors
        },


    }

    /**A collection of functions to import and manipulate a midi file
     * @namespace EDO#midi*/
    midi = {
        /** &lt;p>Imports a midi file&lt;/p>
         *
         * @param  {String} file_path - The path of the file
         * @returns {JSON} the midi file as JSON
         * @memberOf EDO#midi
         */
        import: (file_path) => {
            if (environment != 'server') return alert("This is currently supported only on server-side")
            let midi = load_file(file_path)
            midi = midiParser.parse(midi);
            midi.track = midi.track.map(track=>{
                track.event = track.event.map((e,i,all)=>{
                    if(i==0) e.onset = e.deltaTime
                    else {
                        e.onset = all[i-1].onset+e.deltaTime
                    }
                    return e
                })
                return track
            })


            return midi
        },

        /** &lt;p>Gets a midi file and returns only the note on events from all tracks in correct order as one big array&lt;/p>
         *
         * @param  {JSON} parsed_midi - The returned JSON from [EDO.midi.import()]{@link EDO#midi.import}
         * @returns {Array&lt;Number|Array&lt;Number>>} Returns an array of pitches (or arrays of pitches if there's more than one note played simultaneously)
         * @memberOf EDO#midi
         * @see EDO#midi.import
         * @example
         * let edo = new EDO(12) // define a tuning system
         * let bach = edo.midi.import('midi/Bach - Prelude1.mid') //parsing Bach prelude in C major midi file which has multiple tracks
         * edo.midi.strip(bach) //returns all tracks as one array of pitches
         * [
         *     60, 64, 67, 72, 76, 67, 72, 76, 60, 64, 67, 72,
         *     76, 67, 72, 76, 60, 62, 69, 74, 77, 69, 74, 77,
         *     60, 62, 69, 74, 77, 69, 74, 77, 59, 62, 67, 74,
         *     77, 67, 74, 77, 59, 62, 67, 74, 77, 67, 74, 77,
         *     60, 64, 67, 72, 76, 67, 72, 76, 60, 64, 67, 72,
         *     76, 67, 72, 76, 60, 64, 69, 76, 81, 69, 76, 81,
         *     60, 64, 69, 76, 81, 69, 76, 81, 60, 62, 66, 69,
         *     74, 66, 69, 74, 60, 62, 66, 69, 74, 66, 69, 74,
         *     59, 62, 67, 74,
         *     ... 441 more items
         * ]
         */
        strip: (parsed_midi) =>{
            let p = parsed_midi
            let all_times = []
            p.track = p.track.map(t=>{
                t.event = t.event.filter(e=>{
                    return e.type==9
                }).map(e=>{
                    let el = {pitch:e.data[0],onset:e.onset}
                    return el
                }).map((e,i,all)=>{
                    let onset = e.onset
                    if (all_times.indexOf(onset)==-1) all_times.push(onset)

                    return all.filter((element)=>element.onset==onset)
                })
                t.event = this.get.unique_elements(t.event)
                return t
            })
            all_times.sort((a,b)=>a-b)
            p.track = p.track.map(t=>{
                t.event = t.event.map(e=>{
                    e = e.map(ev=>{
                        ev.onset = all_times.indexOf(ev.onset)
                        return ev
                    })
                    return e
                })
                return t
            })
            p.track = p.track.map(t=>{
                t = t.event.reduce((a,e)=>{
                    e.forEach(n=>{
                        if(a[n.onset]==undefined) a[n.onset] = [n.pitch]
                        else a[n.onset].push(n.pitch)
                    })
                    return a
                },[])
                return t
            })
            p.track = p.track
            //     .map(t=>{
            //     t = t.map(n=>{
            //         return (n.length==1)? n[0]: n
            //     })
            //     return t
            // })
                .filter(t=>{
                return t.length>0
            })
                // .map(t=>{
                //     console.log(this.convert.midi_to_name(t))
                //     return t
                // })
            let all_tracks = []
            p.track.forEach((t)=>{
                t.forEach((n,i)=>{
                    if(all_tracks[i]==undefined) all_tracks[i]=[...n]
                    else all_tracks[i] = [...all_tracks[i],...n]
                })

            })
            all_tracks=all_tracks.map(e=>(e.length==1)?e[0]:e)
            return all_tracks

        },

        /** &lt;p>Gets a midi file and chunks all notes to partitions of a certain timeframe&lt;/p>
         *
         * @param  {JSON} parsed_midi - The returned JSON from [EDO.midi.import()]{@link EDO#midi.import}
         * @param  {Number} [ticks=480] - The number of ticks for each partition (the "harmonic rhythm")
         * @param  {Boolean} [unique=true] - When true, even if a note is repeated within a given timeframe it will appear once.
         * @param  {Boolean} [as_PC=false] - When true, instead of returning the midi note number, the pitches will be returned as pitch classes
         * @param  {Boolean} [ordered=false] - When true, each chord will be sorted by pitch height (rather than the order in which it appeared in the midi file)
         * @returns {Array&lt;Array&lt;Number>>} The midi file returns as array of chords corresponding the to the given timeframe
         * @example
         * let edo = new EDO(12) // define a tuning system
         * let bach = edo.midi.import('midi/Bach - Prelude1.mid') //parsing Bach prelude in C major midi file
         * bach = edo.midi.chordify(bach,960,true,false,true) //chordifying
         * edo.convert.midi_to_name(bach) //replacing the midi values with note names
         * //returns
         * [
         *  [ 'C4', 'E4', 'G4', 'C5', 'E5' ],
         *  [ 'C4', 'D4', 'A4', 'D5', 'F5' ],
         *  [ 'B3', 'D4', 'G4', 'D5', 'F5' ],
         *  [ 'C4', 'E4', 'G4', 'C5', 'E5' ],
         *  [ 'C4', 'E4', 'A4', 'E5', 'A5' ],
         *  [ 'C4', 'D4', 'F#4', 'A4', 'D5' ],
         *  [ 'B3', 'D4', 'G4', 'D5', 'G5' ],
         *  [ 'B3', 'C4', 'E4', 'G4', 'C5' ],
         *  [ 'A3', 'C4', 'E4', 'G4', 'C5' ],
         *  [ 'D3', 'A3', 'D4', 'F#4', 'C5' ],
         *  [ 'G3', 'B3', 'D4', 'G4', 'B4' ],
         *  [ 'G3', 'Bb3', 'E4', 'G4', 'C#5' ],
         *  [ 'F3', 'A3', 'D4', 'A4', 'D5' ],
         *  [ 'F3', 'Ab3', 'D4', 'F4', 'B4' ],
         *  [ 'E3', 'G3', 'C4', 'G4', 'C5' ],
         *  [ 'E3', 'F3', 'A3', 'C4', 'F4' ],
         *  [ 'D3', 'F3', 'A3', 'C4', 'F4' ],
         *  [ 'G2', 'D3', 'G3', 'B3', 'F4' ],
         *  [ 'C3', 'E3', 'G3', 'C4', 'E4' ],
         *  [ 'C3', 'G3', 'Bb3', 'C4', 'E4' ],
         *  [ 'F2', 'F3', 'A3', 'C4', 'E4' ],
         *  [ 'F#2', 'C3', 'A3', 'C4', 'Eb4' ],
         *  [ 'Ab2', 'F3', 'B3', 'C4', 'D4' ],
         *  [ 'G2', 'F3', 'G3', 'B3', 'D4' ],
         *  [ 'G2', 'E3', 'G3', 'C4', 'E4' ],
         *  [ 'G2', 'D3', 'G3', 'C4', 'F4' ],
         *  [ 'G2', 'D3', 'G3', 'B3', 'F4' ],
         *  [ 'G2', 'Eb3', 'A3', 'C4', 'F#4' ],
         *  [ 'G2', 'E3', 'G3', 'C4', 'G4' ],
         *  [ 'G2', 'D3', 'G3', 'C4', 'F4' ],
         *  [ 'G2', 'D3', 'G3', 'B3', 'F4' ],
         *  [ 'C2', 'C3', 'G3', 'Bb3', 'E4' ],
         *  ['C2', 'C3', 'D3', 'F3', 'A3', 'C4', 'F4'],
         *  ['C2', 'B2', 'D4', 'E4', 'F4', 'G4', 'B4', 'D5', 'F5'],
         *  [ 'C2', 'C3', 'E4', 'G4', 'C5' ]
         * ]
         *
         * @memberOf EDO#midi
         * @see EDO#midi.import
         */
        chordify: (parsed_midi,ticks=480,unique=true,as_PC=false,ordered=false) =>{
            let p = parsed_midi
            let max = 0
            p = p.track.map(t=>{
                t.event = t.event.filter(e=>e.type==9) // return only note on events
                t.event.map(e=>(e.onset>max)?max=e.onset:max=max) //gets duration of file
                return [...t.event]
            }).flat().sort((a,b)=>a.onset-b.onset)
            let partitions = Array.from(Array(Math.ceil(max/ticks)).keys())
                .map(e=>e*ticks)
                .map((e,i,arr)=> {
                    if(arr.length-1>i) return p.filter(el=>el.onset>=arr[i] &amp;&amp; el.onset&lt;arr[i+1])
                    else return p.filter(el=>el.onset>=arr[i])
                })
                .map(e=>{
                    e = e.map(n=>{
                        if(as_PC) return this.mod(n.data[0],this.edo)
                        return n.data[0]
                    })
                    if(ordered) e.sort((a,b)=>a-b)
                    if(unique) e=this.get.unique_elements(e)
                    return e
                })
            return partitions
        }

    }

    /**A collection of functions to import and manipulate a midi file
     * @namespace EDO#xml*/
    xml = {
        /** &lt;p>Imports a music xml file and loads it as a JSON.&lt;/p>
         *
         * @param  {String} file_path - The path of the file
         * @returns {JSON}
         * @memberOf EDO#import
         */
        import: (file_path) => {
            if (environment != 'server') return alert("This is currently supported only on server-side")

            var xml = load_file(file_path)
            let parsed
            parseXML(xml, function (err, result) {
                parsed = result
            });
            return parsed
        }
    }

    /**A collection of functions that return a boolean
     * @namespace EDO#is*/
    is = {

        /**
         * Returns True if arr is an element in an array of arrays (bigger_arr)
         * @param  {Array&lt;Number>} arr - a collection of pitches (not necessarily pitch classes)
         * @param  {Array&lt;Array&lt;Number>>} bigger_arr - an array of arrays containing a collection of pitches (not necessarily pitch classes)
         * @return {Boolean}
         * @memberOf EDO#is
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.is.subset([2,4],[[1,2,3,4],[1,2,4]])
         * //returns false (the set [2,4] is NOT equal to [1,2,3,4] or to [1,2,4])
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.is.subset([2,4],[[1,2,3,4],[1,2,4],[2,4]])
         * //returns true
         */
        element_of: (arr, bigger_arr) => {
            if (arr.length == 0 || bigger_arr.length == 0) return false
            arr = JSON.stringify(arr)
            let arr2 = JSON.stringify(bigger_arr)
            return arr2.indexOf(arr) != -1
        },

        /**
         * Returns true the two given collections of pitches are a rotation of one another.
         * @param  {Array&lt;Number>} collection1 - a collection of pitches (not necessarily pitch classes)
         * @param  {Array&lt;Number>} collection2 - a collection of pitches (not necessarily pitch classes)
         * @return {Boolean}
         * @memberOf EDO#is
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.is.transposition([0,2,4,5,7,9,11],[2,4,5,7,9,11,0])
         * //returns true
         */
        rotation:(collection1,collection2)=> {
            let double = [...collection2,...collection2]
            for (let i = 0; i &lt; collection2.length; i++) {
                if(this.is.same(collection1,double.slice(i,i+collection2.length))) return true
            }
            return false
        },

        /**
         * Returns True if arr1 equals arr2 in contents and in order.
         * @param  {Array&lt;Number>} arr1 - a collection of pitches (not necessarily pitch classes)
         * @param  {Array&lt;Number>} arr2 - a collection of pitches (not necessarily pitch classes)
         * @return {Boolean}
         * @memberOf EDO#is
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.is.same([2,4],[4,2]])
         * //returns false
         *
         * @example
         * //Also supports more complicated structures
         * let edo = new EDO(12) // define a tuning system
         * edo.is.same([2,[4,[1,2,3]]],[2,[4,[1,2,3]]])
         * //returns true
         */
        same: (arr1, arr2) => {
            arr1 = JSON.stringify(arr1)
            arr2 = JSON.stringify(arr2)
            return arr1 == arr2
        },

        /**
         * Returns true if some collection of pitches (thing) is a subset of another collection of pitches (thing2)
         * @param  {Array&lt;Number>} thing - a collection of pitches (not necessarily pitch classes)
         * @param  {Array&lt;Number>} thing2 - a collection of pitches (not necessarily pitch classes)
         * @return {Boolean}
         * @memberOf EDO#is
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.is.subset([2,4],[1,2,3,4,5])
         * //returns true (the set [2,4] IS a subset of [1,2,3,4,5])
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.is.subset([2,4],[1,2,3,5])
         * //returns false (the set [2,4] is NOT a subset of [1,2,3,5])
         */
        subset: (thing, thing2) => {

            for (let note of thing) {
                if (!thing2.includes(note)) return false
            }
            return true
        },

        /**
         * Returns true the two given collections of pitches are a transposition of one another.
         * @param  {Array&lt;Number>} collection1 - a collection of pitches (not necessarily pitch classes)
         * @param  {Array&lt;Number>} collection2 - a collection of pitches (not necessarily pitch classes)
         * @return {Boolean}
         * @memberOf EDO#is
         * @example
         * let edo = new EDO(12) // define a tuning system
         * edo.is.transposition([0,2,4,5,7,9,11],[5,7,9,10,0,2,4]) //C major and F major
         * //returns true
         */
        transposition: (collection1,collection2) => {
            let c1 = collection1
            let c2 = collection2
            return this.is.same(c1,c2.map(n=>this.mod(n-c2[0]-c1[0],this.edo)))
        }
    }

    /**&lt;p>A collection of functions that make visual representations&lt;/p>
     * &lt;p>Note: EDO.show can only be used client-side&lt;/p>
     * @namespace EDO#show
     * */
    show = {

        /**
         * &lt;p>Plots the contour of a given melody.&lt;/p>
         * &lt;img src = "img/contour.png">
         * @param  {String} container_id - The ID of a DOM element in which the contour will be shown.
         * @param  {Array&lt;Number>} pitches - The melody.
         * @param  {Boolean} [replace=false] - When false, any time the function is called a new contour will be appended to the object. When true, it will replace the contents of the container.
         * @param  {Number|Array&lt;Number,Number>} [size] - Size (in px) of the plot. When no values are passed, the plot will take the size of the container. If 1 value is passed, it will be used for both dimensions. Otherwise pass data as [width,height].
         *
         * @example
         * &lt;script src="edo.js">&lt;/script>
         * &lt;script src="raphael.min.js">&lt;/script>
         * &lt;div id="container" style="width:900px;height:600px; margin:0 auto;">&lt;/div>
         * &lt;script>
         * let edo = new EDO(12)
         * perms = edo.get.permutations([1,2,3,4])
         * perms.sort((a,b)=>b[0]-a[0] || b[b.length-1]-a[a.length-1])
         * for(let perm of perms) {
         *      edo.show.contour('container', perm,false,150)
         *  }
         * &lt;/script>
         * @see /demos/contour_plotter.html
         * @memberOf EDO#show
         */
        contour: (container_id, pitches, replace = false, size) => {
            let container = document.getElementById(container_id)
            let width, height
            if (!size) {
                width = container.offsetWidth
                height = container.offsetHeight
            } else {
                if (Array.isArray(size)) {
                    width = size[0]
                    height = size[1]

                } else {
                    width = size
                    height = size
                }
            }

            let div = document.createElement('div')
            div.style.width = width + "px";
            div.style.height = height + "px";
            div.style.display = "inline"
            let div_id = div.setAttribute("id", "paper_" + Date.now());

            if (replace) container.innerHTML = ""
            container.appendChild(div)
            const paper = new Raphael(div, width, height);
            let background = paper.rect(0, 0, width, height).attr('fill', '000').attr('stroke', 'white')

            const scale = (num, in_min, in_max, out_min, out_max) => {
                return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
            }

            let max_pitch = Math.max.apply(Math, pitches)
            let min_pitch = Math.min.apply(Math, pitches)
            let margin = 15
            let scaled_pitches = pitches.map((pitch) => Math.floor(scale(pitch, min_pitch, max_pitch, height - margin, margin)))
            let pos = margin
            let pos_shift = Math.floor((width - (margin * 2)) / (pitches.length - 1))
            let path_str = "M" + margin + "," + scaled_pitches[0]
            let circle_set = paper.set()
            let circle_r = height / 45
            circle_set.push(paper.circle(margin, scaled_pitches[0], circle_r))
            for (let i = 1; i &lt; scaled_pitches.length; i++) {
                pos += pos_shift
                path_str += "L" + pos + "," + scaled_pitches[i]
                circle_set.push(paper.circle(pos, scaled_pitches[i], circle_r))
            }
            let path = paper.path(path_str).attr('stroke', 'red').attr('stroke-width', 2)
            circle_set.attr('fill', 'white')
            circle_set.toFront()
        },


        /**
         * Makes a fractal tree with branches diverging by given intervals
         * &lt;img src = "img/fractal_tree.png">
         * @param  {String} container_id - The ID of a DOM element in which the tree will be shown.
         * @param  {Number} [length=200] - The length (or height) or the tree's "trunk".
         * @param  {Number} [angle_span=90] - the angle between branches.
         * @param  {Array&lt;Number>} [mode=[0,2,4,5,7,9,11]] - If provided, the tree will conform to that mode.
         * @param  {Array&lt;Number>} [intervals=[-1,1]] - If mode is provided, each interval represents the number of scale degrees away from the current node. If mode is not provided, the intervals represent PCs away from the current node.
         * @param  {Number} [iterations=5] - The number of sub-branches on the tree
         * @param  {Number} [length_mul=0.7] - The factor by which every new sub-branch's length is to its parent.

         * @example
         * &lt;script src="edo.js">&lt;/script>
         * &lt;script src="raphael.min.js">&lt;/script>
         * &lt;div id="container" style="width:900px;height:600px; margin:0 auto;">&lt;/div>
         * &lt;script>
         *  let edo = new EDO()
         *  edo.show.interval_fractal_tree(container_id)
         * &lt;/script>


         * @see /demos/fractal_tree.html
         * @memberOf EDO#show
         */
        interval_fractal_tree: (container_id, length = 200, angle_span = 90, mode = [0, 2, 4, 5, 7, 9, 11], intervals = [-1, 1], iterations = 5, length_mul = 0.7) => {
            const self = this
            const container = document.getElementById(container_id)
            container.innerHTML = ""
            const edo = this.edo
            let width = container.offsetWidth
            let height = container.offsetWidth
            const paper = new Raphael(container, width, height);
            const point_on_circle = function (center = [0, 0], radius = 50, angle = 90) {
                /*Finding the x,y coordinates on circle, based on given angle*/

                //center of circle, angle in degree and radius of circle
                angle = angle * Math.PI / 180
                let x = Math.floor(center[0] + (radius * Math.cos(angle)))
                let y = Math.floor(center[1] + (radius * Math.sin(angle)))

                return [x, y]
            }

            const normalize = (num, in_min, in_max, out_min, out_max) => {
                return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
            }

            class Branch {
                constructor(length = 300, angle = 0, x = 0, y = 0, circle_r = 20, angle_span = 90, length_mul = 0.70, iterations = 5, intervals = [-1, 1], starting_pitch = 0, mode = null) {
                    if (mode) this.diatonic = true
                    else this.diatonic = false

                    this.mode = mode
                    this.iterations = iterations
                    this.length_mul = length_mul
                    this.angle_span = angle_span
                    this.length = length
                    this.angle = angle
                    this.circle_r = circle_r
                    this.circle_o = point_on_circle([x, y], length - (circle_r), angle - 90)
                    this.start = [x, y]
                    this.line_center = point_on_circle(this.start, (this.length - (this.circle_r * 2)) / 2, this.angle - 90)
                    this.line_end = point_on_circle(this.start, this.length - (this.circle_r * 2), this.angle - 90)
                    this.end = point_on_circle([x, y], length, angle - 90)
                    this.sub_branches = intervals.length
                    this.intervals = intervals
                    this.starting_pitch = starting_pitch
                }

                draw_branch() {
                    let start = this.start
                    let end = this.line_end
                    paper.path('M' + start.join(',') + 'L' + end.join(',')).attr('stroke', 'white')
                    let c_center = this.circle_o
                    let hue = Math.floor(normalize(this.starting_pitch, 0, edo - 1, 0, 360))
                    let rgb = Raphael.hsl2rgb(hue, 100, 50)
                    paper.circle(c_center[0], c_center[1], this.circle_r).attr('fill', rgb)
                    this.text = paper.text(c_center[0], c_center[1], this.starting_pitch)
                        .attr('fill', 'blue')
                        .attr('font-size', 25)

                    if (this.iterations > 0) {
                        let angle_span = Math.floor(this.angle_span / 2) - this.angle_span
                        let angle_add = this.angle_span / (this.sub_branches - 1)
                        let new_length = this.length * this.length_mul
                        for (let i = 0; i &lt; this.sub_branches; i++) {
                            let starting_pitch = 100
                            if (this.diatonic) {
                                let index = this.mode.indexOf(this.starting_pitch)
                                starting_pitch = this.mode[self.mod((index + this.intervals[i]), this.mode.length)]
                            } else {
                                starting_pitch = mod((this.starting_pitch + this.intervals[i]), edo)
                            }
                            let new_angle = this.angle + angle_span + (i * angle_add)
                            let new_x = this.end[0]
                            let new_y = this.end[1]
                            let new_branch = new Branch(new_length, new_angle, new_x, new_y, this.circle_r, this.angle_span, this.length_mul, this.iterations - 1, this.intervals, starting_pitch, this.mode)
                            new_branch.draw_branch()

                        }
                    }
                }
            }

            paper.clear()
            let background = paper.rect(0, 0, width, height).attr('fill', '000')
            let tree = new Branch(length = length,
                0,
                Math.floor(width / 2),
                height,
                20,
                angle_span,
                length_mul,
                iterations,
                intervals,
                0,
                mode)
            tree.draw_branch()
        },

        /**
         * Graphs a given necklace in a container.
         * &lt;img src='img/Necklace.png'>
         * @param  {Object} args - An object with the necklace arguments
         * @param  {Paper} args.paper - A Raphael Paper object on which the necklace will be drawn
         * @param  {Array&lt;Number>} args.pitches - The pitches of the necklace
         * @param  {Number} [args.cx] - The center x coordinate of the necklace (in relation to the paper object).
         * @param  {Number} [args.cy] - The center y coordinate of the necklace (in relation to the paper object).
         * @param  {Number} [args.radius] - The center y coordinate of the necklace (in relation to the paper object)
         * @param  {Boolean} [args.ring=true] - When false, the necklace ring will be hidden.
         * @param  {Boolean} [args.inner_strings=true] - When false, the necklace's inner strings will be hidden.
         * @param  {Number} [args.PC_at_midnight=0] - The PC starting the necklace at the very top (midnight)
         * @param  {Number} [args.string_width=1] - The width of the strings of the necklace.
         * @param  {Number} [args.node_radius] - The radius of each node on the necklace
         *
         *
         * @example
         * &lt;script src="edo.js">&lt;/script>
         * &lt;script src="raphael.min.js">&lt;/script>
         * &lt;div id="container" style="width:900px;height:600px; margin:0 auto;">&lt;/div>
         * &lt;script>
         *  let edo = new EDO(12)
         *  let paper = edo.make_DOM_svg('container',1200,1200,true).paper
         *  edo.show.necklace({paper:paper,pitches:[0,2,4,5,7,9,11]})
         * &lt;/script>
         * @see /demos/necklace.html
         * @memberOf EDO#show
         */
        necklace: (args) => {
            args.cx = args.cx || args.paper.width / 2
            args.cy = args.cy || args.paper.height / 2
            args.radius = args.radius || (args.paper.width / 2) - 30
            args.ring = (args.ring == undefined) ? true : args.ring
            args.inner_strings = (args.inner_strings == undefined) ? true : args.inner_strings
            args.outer_strings = (args.outer_strings == undefined) ? true : args.outer_strings
            args.PC_at_midnight = args.PC_at_midnight || 0
            args.string_width = args.string_width || 1
            args.node_color = args.node_color || "blue"
            args.node_radius = args.node_radius || (args.paper.height * Math.PI / (this.edo * 4)) / 2 - 5
            const parent = this

            class Necklace {
                constructor(parent, args) {
                    this.cx = args.cx
                    this.cy = args.cy
                    this.radius = args.radius
                    this.pitches = args.pitches
                    this.PC_at_midnight = args.PC_at_midnight
                    this.show_ring = args.ring
                    this.show_inner_strings = args.inner_strings
                    this.show_outer_strings = args.outer_strings
                    this.parent = parent
                    this.edo = parent.edo
                    this.nodes = []
                    this.strings = []
                    this.paper = args.paper
                    this.node_color = args.node_color
                    this.node_radius = args.node_radius
                    this.string_width = args.string_width
                    this.draw_all()


                }

                draw_all() {
                    if (this.show_ring) this.draw_ring()
                    this.draw_nodes()
                    this.draw_strings(this.string_width)
                    for (let node of this.nodes) {
                        node.drawing.toFront()
                        node.text.toFront()
                    }
                }

                draw_ring(color = 'red', stroke_width = 3) {
                    let paper = this.paper
                    //if already exists, remove the old one
                    if (this.ring) {
                        this.ring.remove()
                        this.ring = undefined
                    }

                    //draw the ring
                    this.ring = paper.circle(this.cx, this.cy, this.radius).attr('stroke', color)
                        .attr('stroke-width', stroke_width)
                }

                draw_nodes() {
                    //remove nodes
                    for (let node of this.nodes) {
                        node.drawing.remove()
                        node.text.remove()
                    }
                    this.nodes = []
                    let node_radius = this.node_radius
                    node_radius = Math.max(node_radius, 1)
                    //node parameters
                    for (let note of this.pitches) {
                        let angle = (note * (360 / this.edo)) - 90
                        let rad_angle = angle * Math.PI / 180
                        let cx = Math.floor(this.cx + (this.radius * Math.cos(rad_angle)))
                        let cy = Math.floor(this.cy + (this.radius * Math.sin(rad_angle)))
                        let node = new Node(this, node_radius, cx, cy, (note + this.PC_at_midnight) % this.edo)
                        this.nodes.push(node)
                    }


                    for (let node of this.nodes) node.draw()

                }

                draw_strings(stroke_width) {
                    //remove strings
                    for (let string of this.strings) {
                        string.drawing.remove()
                    }
                    this.strings = []

                    //draw outer strings
                    if (this.show_outer_strings) {
                        for (let i = 0; i &lt; this.nodes.length; i++) {
                            let node1 = this.nodes[i]
                            let node2 = this.nodes[(i + 1) % this.nodes.length]
                            let str = new Str(this, node1.cx, node1.cy, node2.cx, node2.cy, stroke_width)
                            this.strings.push(str)
                        }
                    }


                    //draw inner-strings
                    if (this.show_inner_strings) {
                        for (let i = 0; i &lt; this.nodes.length - 2; i++) {
                            for (let j = 2; j &lt; this.nodes.length; j++) {
                                let node1 = this.nodes[i]
                                let node2 = this.nodes[j]
                                let str = new Str(this, node1.cx, node1.cy, node2.cx, node2.cy, stroke_width)
                                this.strings.push(str)
                            }
                        }
                    }


                    for (let string of this.strings) {
                        string.draw()
                    }
                }
            }

            class Node {
                constructor(necklace, radius, cx, cy, name) {
                    this.necklace = necklace
                    this.radius = radius
                    this.cx = cx
                    this.cy = cy
                    this.name = name

                }

                draw() {
                    let paper = this.necklace.paper
                    //if already exists, remove the old one
                    if (this.drawing) {
                        this.drawing.remove()
                        this.drawing = undefined
                    }

                    this.drawing = paper.set()

                    this.circle = paper.circle(this.cx, this.cy, this.radius)
                        .attr('stroke', 'red')
                        .attr('fill', this.necklace.node_color)
                    this.drawing.push(this.circle)
                    this.text = paper.text(this.cx, this.cy, this.name)
                        .attr('fill', 'white')
                        .attr('font-size', this.radius)

                    this.drawing.push(this.text)

                }
            }

            class Str {
                constructor(necklace, x1, y1, x2, y2, stroke_width) {
                    this.necklace = necklace
                    this.x1 = x1
                    this.y1 = y1
                    this.x2 = x2
                    this.y2 = y2
                    this.length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
                    this.stroke_width = stroke_width

                }

                draw() {
                    let paper = this.necklace.paper
                    //if already exists, remove the old one
                    if (this.drawing) {
                        this.drawing.remove()
                        this.drawing = undefined
                    }

                    let hue = Math.floor(rescale(this.length, 0, this.necklace.radius * 2, 0, 360))
                    let rgb = Raphael.hsl2rgb(hue, 100, 50)
                    this.drawing = paper.path("M" + this.x1 + "," + this.y1 + "L" + this.x2 + "," + this.y2)
                        .attr('stroke', rgb.hex)
                        .attr('stroke-width', this.stroke_width)

                }

            }

            let neck = new Necklace(parent, args)
            return neck
        },

        /**
         * Graphs nested necklaces.
         * &lt;img src='img/nested_necklaces.png'>
         *
         * @param  {String} container_id - The ID of a DOM element in which the contour will be shown.
         * @param  {Array&lt;Array&lt;Number>>} necklaces - The necklaces to be drawn
         * @param  {Boolean} [replace=false] - When true, the contents of the container will be replaced by the function. When false, it will be appended.
         * @param  {Number} [radius = 600] - Radius (in px) of the ring.
         * @param  {Boolean} [ring = false] - When true, the ring of the scale will be drawn
         * @param  {Number} [min_node_radius] - When passed, the radius of each node won't be smaller than the value passed
         *
         * @example
         * &lt;script src="edo.js">&lt;/script>
         * &lt;script src="raphael.min.js">&lt;/script>
         * &lt;div id="container" style="width:900px;height:900px; margin:0 auto;">&lt;/div>
         * &lt;script>
         * const divisions = 12
         * let edo = new EDO(divisions)
         * let scale = edo.scale([0,2,4,5,7,9,11])
         * let necklaces = scale.get.scale_degree_transpositions().map((trans)=>trans[0])
         * edo.show.nested_necklaces("container",necklaces,true,900)
         * //Graphs all of the common tone transpositions of the major scale
         * &lt;/script>
         * @see /demos/necklace.html
         * @memberOf EDO#show
         */
        nested_necklaces: (container_id, necklaces, replace = true, radius = 600, ring = false, min_node_radius, strings = true) => {
            let parent = this
            let height = radius
            let width = radius
            let new_necklace_radius = height / 2 - (height / 20)
            let num_of_necklaces = necklaces.length
            let necklace_radius_offset = Math.min(new_necklace_radius / (num_of_necklaces))

            const SVG = this.make_DOM_svg(container_id, width, height, replace)
            const paper = SVG.paper

            let node_radius = Math.min((paper.height * Math.PI / (this.edo * 4)) / 2 - 5, paper.height * Math.PI / (num_of_necklaces * num_of_necklaces * 2), (paper.height * Math.PI / (this.edo * num_of_necklaces)) / 2 - 5)
            if (min_node_radius) node_radius = Math.max(node_radius, min_node_radius)

            for (let necklace of necklaces) {
                let args = {
                    paper: paper,
                    pitches: necklace,
                    radius: new_necklace_radius,
                    ring: ring,
                    inner_strings: false,
                    node_radius: node_radius,
                    outer_strings: strings
                }
                this.show.necklace(args)
                new_necklace_radius -= necklace_radius_offset
            }

        },

        /**
         * Graphs necklaces on every node of a parent necklace recursively.
         * &lt;img src='img/necklace_fractal.png'>
         * @param  {Object} args - The arguments of the necklaces
         * @param  {String} args.container_id - The ID of a DOM element in which the necklaces will be shown.
         * @param  {Array&lt;Array&lt;Number>>} args.necklaces - The necklaces to be drawn
         * @param  {Number} [args.canvas_width=900] - The width of the drawable area
         * @param  {Number} [args.canvas_height=900] - The height of the drawable area
         * @param  {Number} [args.initial_radius=250] - The radius of the top-level necklace
         * @param  {Number} [args.radius_multiplier=0.5] - The rate of change in radius size for every new level of necklace.
         * @param  {Number} [args.offset_x=0] - Initial necklace's x offset from the center
         * @param  {Number} [args.offset_y=50] - Initial necklace's y offset from the center
         * @param  {Number} [args.minimum_node_radius=20] - The smallest radius a node can have
         * @param  {Boolean} [args.ring=true] - When false, the necklace's ring will be hidden
         * @param  {Boolean} [args.replace=false] - When true, the contents of the container will be replaced by the function. When false, it will be appended.
         *
         * @example
         * &lt;script src="edo.js">&lt;/script>
         * &lt;script src="raphael.min.js">&lt;/script>
         * &lt;div id="container" style="width:900px;height:900px; margin:0 auto;">&lt;/div>
         * &lt;script>
         * const divisions = 12
         * let edo = new EDO(divisions)
         * edo.show.necklace_fractal({container_id:'container',necklaces:[[0,3,6],[0,4,8],[0,6]]})
         * &lt;/script>
         * @memberOf EDO#show
         */
        necklace_fractal: (args) => {

            const container_id = args.container_id
            const necklaces = args.necklaces
            const offset_x = args.offset_x
            const offset_y = args.offset_y || 50
            const radius_multiplier = args.radius_multiplier || 0.5
            const initial_radius = args.initial_radius || 250
            const minimum_node_radius = args.minimum_node_radius || 20
            const show_ring = (args.ring == undefined) ? true : args.ring
            const canvas_width = args.canvas_width || 900
            const canvas_height = args.canvas_height || 900
            const replace = (args.replace == undefined) ? false : args.replace

            const SVG = this.make_DOM_svg(container_id, canvas_width, canvas_height, replace)
            const paper = SVG.paper
            const parent = this
            const necklace_nester = function (necklaces, nodes, new_radius = initial_radius) {
                let new_necklaces = [...necklaces]
                let necklace = new_necklaces.splice(0, 1)[0]
                if (nodes) {
                    nodes.forEach((node) => {
                        let neck = parent.show.necklace({
                            paper: paper,
                            ring: show_ring,
                            radius: new_radius,
                            pitches: necklace,
                            cx: node.cx,
                            cy: node.cy + new_radius,
                            PC_at_midnight: node.name,
                            node_radius: Math.max(new_radius / 8, minimum_node_radius)
                        })
                        if (new_necklaces.length > 0) necklace_nester(new_necklaces, neck.nodes, neck.radius * radius_multiplier)
                    })
                } else {
                    let neck = parent.show.necklace({
                        cx: paper.width / 2 + offset_x,
                        ring: show_ring,
                        paper: paper,
                        radius: new_radius,
                        pitches: necklace,
                        cy: new_radius + offset_y,
                        node_radius: Math.max(new_radius / 8, minimum_node_radius)
                    })

                    if (new_necklaces.length > 0) necklace_nester(new_necklaces, neck.nodes, neck.radius * radius_multiplier)
                }
            }

            necklace_nester(necklaces)
        },


    }

    mod(n, m) {
        return ((n % m) + m) % m;
    }


}

/** &lt;p>Class representing a set of pitch classes within an EDO system&lt;/p>
 * &lt;p>(This class should have been called "Set" but because Set is a reserved work in JavaScript (as in most languages), "Scale" was selected as a compromise).&lt;/p> */
class Scale {
    /**
     * &lt;p>Creates a set of pitch classes within the context of the edo system.&lt;/p>
     * &lt;p>Unlike the [EDO Class]{@link EDO}, this class mostly contains methods which are more directed at manipulating a set of pitch classes (regardless of their octave) or for methods which necessitate the context of a scale (like sequences).
     * At the center of this class stand 6 collections (see "Namespaces" below) of functions.&lt;/p>
     * &lt;ul>
     *  &lt;li> [Scale.to]{@link Scale#to} is a set of functions used to change between equivalent representations of the set.&lt;/li>
     *  &lt;li> [Scale.count]{@link Scale#count} is a set of functions used to count stuff.&lt;/li>
     *  &lt;li> [Scale.get]{@link Scale#get} is a set of functions used to manipulate and track, and generate stuff.&lt;/li>
     *  &lt;li> [Scale.is]{@link Scale#is} is a set of functions used for boolean truth statements.&lt;/li>
     *  &lt;li> [Scale.export]{@link Scale#export} is a set of functions used to export files.&lt;/li>
     *  &lt;li> [Scale.show]{@link Scale#show} is a set of functions used to visualize various things.&lt;/li>&lt;/ul>
     *  &lt;p>
     *      In addition to the namespaces, Scale also has 5 methods that can be chained together:
     * &lt;ul>
     *  &lt;li> [Scale.invert()]{@link Scale#invert} returns the inversion of the original Scale object as a new Scale object.&lt;/li>
     *  &lt;li> [Scale.mode(n)]{@link Scale#mode} returns the nth mode of the original Scale object as a new Scale object.&lt;/li>
     *  &lt;li> [Scale.normal()]{@link Scale#normal} returns the normal order of the original Scale object as a new Scale object.&lt;/li>
     *  &lt;li> [Scale.prime()]{@link Scale#prime} returns the prime form of the original Scale object as a new Scale object.&lt;/li>
     *  &lt;li> [Scale.complement()]{@link Scale#complement} returns the complement of the scale in the current EDO.&lt;/li>
     *  &lt;/ul>
     *  &lt;/p>
     * @param {Array&lt;number>} pitches - The pitch classes of the set.
     * @param {EDO} parent - and EDO context
     *
     * @example
     * //Basic usage 1:
     * let edo = new EDO(12) //create a new EDO context with 12 divisions.
     * let scale = new Scale([0,2,4,5,7,9,11],edo) //pass the PCs and edo context to the scale
     *
     * //Basic usage 2 (preferred):
     * let edo = new EDO(12) //create a new EDO context with 12 divisions.
     * let scale = edo.scale([0,2,4,5,7,9,11]) //create an instance of Scale through the EDO.scale method rather than
     *
     * @example
     * //for scale [0, 2, 3, 5, 6, 8, 9, 11 ] //octatonic
     * scale.count.transpositions() //returns 3
     * scale.is.mode_of([0, 1, 3, 4, 6, 7, 9, 10]) //returns true
     * scale.to.cents() //returns [0, 200, 300, 500, 600, 800, 900, 1100]
     * scale.get.stacks(3,2) //returns [ [ 0, 5, 9 ], [ 0, 4, 9 ] ]
     *
     * @example
     * //chain functions
     * let scale = edo.scale([0,2,4,5,7,9,11])
     * scale.mode(2) //the 3rd mode (1st is 0)
     *      .normal() //in normal order
     *      .invert() //inverted
     *      .prime() //in prime form
     *      .get.pitches() //returns [0, 1, 3, 5, 6, 8, 10]
     */
    constructor(pitches, parent) {
        this.parent = parent
        this.catalog = {}

        let smallest = Math.min.apply(Math, pitches)
        let diff_from_zero = 0 - smallest

        this.pitches = pitches.map((pitch) => pitch + diff_from_zero)
        this.edo = this.parent.edo
        this.pitches = this.pitches.map((pitch) => pitch % parent.edo)
        this.pitches = this.parent.get.unique_elements(this.pitches)
        this.pitches.sort((a, b) => a - b)

        this.name = this.get.name()
    }

    /**A collection of functions that return an amount
     * @namespace*/
    count = {

        /**
         * &lt;p>Returns the number of times a certain chord (or interval) quality (specified in PCs above the root) exists in the scale.&lt;/p>
         * &lt;p>E.g. &lt;code>scale.count.chord_quality([4, 7, 11])&lt;/code> counts the number of times a major 7th (if in 12 TET) appears in a scale&lt;/p>
         * @param {Array&lt;Number|Array&lt;Number>>} intervals - intervals above 0
         * @return {Number}
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //define new scale (Major)
         * //Major 7th
         * scale.count.chord_quality([4, 7, 11]) //returns 2
         *
         * let scale = edo.scale([0,2,3,5,6,8,9,11]) //define new scale (Octatonic)
         * //diminished triad
         * scale.count.chord_quality([3, 6]) //returns 8
         *
         * @example
         * //(in 12-EDO) count how many major OR minor triads are in the diatonic scale
         * let scale = edo.scale([0,2,4,5,7,9,11]) //define new scale (Major)
         * //count how many times in the diatonic scale, the 1st interval is a PC3 OR PC4, and the 2nd interval a PC7
         * scale.count.chord_quality([[3,4], 7]) //returns 6
         * @memberOf Scale#count*/
        chord_quality: (intervals) => {
            let scale = this.pitches
            let count = 0
            intervals = this.parent.get.partitioned_subsets(intervals)

            //modes including repetitions
            let modes = this.parent.get.modes(this.pitches, false, false)

            modes.forEach((mode) => {
                intervals.forEach((subset) => {
                    subset = subset.map((note) => mode.indexOf(note) != -1)
                    if (subset.indexOf(false) == -1) count++
                })
            })

            return count
        },

        /**
         * Returns the maximal number of consecutive steps of size 'size' in the scale (and its rotations).
         * @param {Number} size - the size of the step
         * @returns {Number}
         * @memberOf Scale#count
         *
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //define new scale (Major)
         * scale.count.consecutive_steps(2) //returns 3
         * */
        consecutive_steps: (size,) => {
            let counts = []
            let steps = this.to.steps()
            steps = [...steps, ...steps]
            if (steps.indexOf(size) == -1) return 0
            let sequences = []
            let count = 0
            for (let step of steps) {
                if (step == size) count++
                else {
                    counts.push(count)
                    count = 0
                }
            }
            counts = counts.sort((a, b) => b - a)
            let result = counts[0]
            result = Math.min.apply(Math, [result, this.edo])
            return result

        },

        /**
         * Returns the number of imperfections (notes that do not have a P5 above them) in the scale.
         * @param {Number} [tolerance=10] - allowed tolerance in cents (away from pure P5)
         * @param {Boolean} [cache=false] - when true, the result will be cached for faster retrieval.
         * @return {Number}
         * @memberOf Scale#count
         *
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //define new scale (Major)
         * scale.count.imperfections() //returns 1
         * scale.count.imperfections(0) //returns 7
         */
        imperfections: (tolerance = 10, cache = false) => {

            if (this.catalog['# imperfections']) return this.catalog['# imperfections']

            let scale = this.pitches
            let imperfections = 0
            let valid_intervals = []
            let p5 = this.parent.convert.ratio_to_cents(3 / 2)
            for (let i = 1; i &lt; this.edo; i++) {
                if (Math.abs(this.parent.convert.interval_to_cents(i) - p5) &lt;= tolerance) valid_intervals.push(i)
                else if (valid_intervals.length > 0) break
            }
            let octavescale = scale.map((note) => note + this.edo)
            let doublescale = scale.concat(octavescale)
            scale.forEach((note) => {
                let valid = false

                valid_intervals.forEach((interval) => {
                    if (doublescale.indexOf(note + interval) != -1) valid = true

                })
                if (!valid) imperfections++
            })
            if (cache) this.catalog['# imperfections'] = imperfections
            return imperfections

        },

        /**
         * &lt;p>Returns the number of intervals of size IC in the scale.&lt;/p>
         * &lt;p>When an array is passed, the function returns total amount of intervals found from the array.&lt;/p>
         * @param {Number | Array&lt;Number>} interval - some interval class.
         * @return {Number}
         * @memberOf Scale#count
         *
         * @example
         * let edo = new EDO(12) //Create a tuning context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //define new scale (Major)
         * scale.count.interval([3,4]) //returns 7 (the amount of IC3 in the scale + the amount of IC4 in the scale)
         *
         * @see Scale#count.chord_quality

         * */
        interval: (interval) => {
            if (!Array.isArray(interval)) interval = [interval]
            let scale = this.pitches
            let count = 0
            for (let note of scale) {
                for (let int of interval) {

                    if (scale.indexOf((note + int) % this.edo) != -1) count++
                }
            }


            return count
        },

        /**
         * &lt;p>Returns the number of Major Thirds (with a tolerance of 20 cents) in the scale.&lt;/p>
         *
         * &lt;p>(To count other intervals or set a different tolerance use [Scale.count.ratio()]{@link Scale#count.ratio})&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         * @see Scale#count.ratio
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //new Scale object
         * scale.count.M3s() //returns 3 (C-E, F-A, G-B)
         */
        M3s: () => {
            return this.count.interval(this.parent.M3s)
        },

        /**
         * &lt;p>Returns the number of Minor Thirds (with a tolerance of 20 cents) in the scale.&lt;/p>
         *
         * &lt;p>(To count other intervals or set a different tolerance use [Scale.count.ratio()]{@link Scale#count.ratio})&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         * @see Scale#count.ratio
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //new Scale object
         * scale.count.m3s() //returns 4
         */
        m3s: () => {
            return this.count.interval(this.parent.m3s)
        },

        /**
         * &lt;p>Returns the number of major and minor (sounding) triads in the scale.&lt;/p>
         *
         * &lt;p>For other chord qualities use a combination of [Scale.count.chord_quality()]{@link Scale#count.chord_quality} and [EDO.convert.ratio_to_interval()]{@link EDO#convert.ratio_to_interval}&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //Major
         * scale.count.major_minor_triads() //returns 6
         * @see Scale#count.chord_quality
         * @see EDO#convert.ratio_to_interval*/
        major_minor_triads: () => {
            let major = this.count.chord_quality([[...this.parent.M3s], [...this.parent.P5s]])
            let minor = this.count.chord_quality([[...this.parent.m3s], [...this.parent.P5s]])

            return major + minor
        },

        /**
         * &lt;p>Returns the number of unique modes in the scale.&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //Major
         * scale.count.modes() //returns 7
         *
         * scale = edo.scale([0,2,4,6,8,10]) //Whole-tone
         * scale.count.modes() //returns 1
         * */
        modes: () => {
            return this.get.modes().length
        },

        /**
         * &lt;p>Returns the number of Perfect Fifths (with a tolerance of 5 cents) in the scale.&lt;/p>
         *
         * &lt;p>(To count other intervals or set a different tolerance use @Scale.count.ratio())&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //new Scale object
         * scale.count.P5s() //returns 6 (C-G, D-A, E-B, F-C, G-D, A-E)
         */
        P5s: () => {
            return this.count.interval(this.parent.P5s)
        },

        /**
         * &lt;p>Returns the number of pitches in the scale (its cardinality).&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         * @example
         * let scale = edo.scale([0,2,4,5,7,9,11]) //new Scale object
         * scale.count.pitches() //returns 7
         */
        pitches: () => {
            return this.pitches.length
        },

        /**
         * &lt;p>Returns the number of (Rahn's) differences in the scale.&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         * @example
         * let scale = edo.scale([0,2,4,5,7,9,11]) //The diatonic scale
         * scale.count.rahn_differences() //returns 56
         * @see Rahn, J. (1991). "Coordination of interval sizes in seven-tone collections." Journal of Music Theory 35(1/2): 33-60.
         * @see Scale#get.generic_intervals
         */
        rahn_differences: () => {
            let total = 0
            for (let i = 1; i &lt; this.count.pitches(); i++) {
                let gi = this.get.generic_intervals(i)
                gi = gi.map(a=>a.instances)
                let nck = this.parent.get.n_choose_k(gi,2)
                let product = nck.map(el=>el[0]*el[1]).reduce((ag,el)=>ag+el,0)
                total+=product
            }
            return total
        },

        /**
         * &lt;p>Returns the number of (Rahn's) contradictions in the scale.&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         * @example
         * let scale = edo.scale([0,2,4,5,7,9,11]) //The diatonic scale
         * scale.count.rahn_contradictions() //returns 0
         * @see Rahn, J. (1991). "Coordination of interval sizes in seven-tone collections." Journal of Music Theory 35(1/2): 33-60.
         */
        rahn_contradictions: () => {
            let total = 0
            let scale_degrees = [...Array(this.pitches.length).keys()]
            let combinations = this.parent.get.combinations(scale_degrees,2).sort((a,b)=>a[0]-b[0] || a[1]-b[1])
            let pairwise = combinations.map(c=>{
                let obj = this.get.pairwise_generic_specific_intervals(c[0],c[1])
                obj.scale_degs = c
                obj.pitches = [this.pitches[c[0]],this.pitches[c[1]]]
                return obj
            })
            for (let i = 0; i &lt; pairwise.length-1; i++) {
                let p1 = pairwise[i]
                for (let j =i+1; j &lt; pairwise.length; j++) {
                    let p2 = pairwise[j]
                    if((p1.generic&lt;p2.generic &amp;&amp; p1.specific>p2.specific) || (p2.generic&lt;p1.generic &amp;&amp; p2.specific>p1.specific)){
                        total++
                    }
                }
            }
            return total
        },

        /**
         * &lt;p>Returns the number of (Rahn's) ambiguities in the scale.&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         * @example
         * let scale = edo.scale([0,2,4,5,7,9,11]) //The diatonic scale
         * scale.count.rahn_ambiguities() //returns 1
         * @see Rahn, J. (1991). "Coordination of interval sizes in seven-tone collections." Journal of Music Theory 35(1/2): 33-60.
         * @see Scale#get.specific_intervals
         */
        rahn_ambiguities: () => {
            let total = 0
            let scale_degrees = [...Array(this.pitches.length).keys()]
            let combinations = this.parent.get.combinations(scale_degrees,2).sort((a,b)=>a[0]-b[0] || a[1]-b[1])
            let pairwise = combinations.map(c=>{
                let obj = this.get.pairwise_generic_specific_intervals(c[0],c[1])
                obj.scale_degs = c
                obj.pitches = [this.pitches[c[0]],this.pitches[c[1]]]
                return obj
            })
            for (let i = 0; i &lt; pairwise.length-1; i++) {
                let p1 = pairwise[i]
                for (let j =i+1; j &lt; pairwise.length; j++) {
                    let p2 = pairwise[j]
                    if((p1.generic&lt;p2.generic &amp;&amp; p1.specific==p2.specific) || (p2.generic&lt;p1.generic &amp;&amp; p2.specific==p1.specific)){
                        total++
                    }
                }
            }
            return total
        },

        /**
         * Counts how many times some ratio appears in the scale within a given tolerance.
         * @param {Number} ratio
         * @param {Number} [tolerance=10] - a tolerance in cents
         * @return {Number}
         * @function
         * @memberOf Scale#count*/
        ratio: (ratio, tolerance = 10) => {
            /**/
            let intervals = this.parent.convert.ratio_to_interval(ratio, tolerance)
            return this.count.interval(intervals)
        },

        /**
         * &lt;p>Returns the number of rotational symmetries in the scale.&lt;/p>
         * @return {Number}
         * @memberOf Scale#count
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,3,5,6,8,9,11]) //Octatonic
         * scale.count.rotational_symmetries() //returns 4
         */
        rotational_symmetries: () => {
            return this.edo / this.count.transpositions()
        },

        /**
         * Counts how many simple ratios appear in the scale.
         * @param {Number} [limit=17] - some harmonic limit
         * @param {Number} [tolerance=15] - a tolerance in cents
         * @returns simple_ratio
         * @memberOf Scale#count
         *
         * */
        simple_ratios: (limit = 17, tolerance = 15) => {
            let ratios = this.parent.get.simple_ratios(limit = limit)
            let unique = 0
            let total = 0
            for (let ratio in ratios) {
                let result = this.count.ratio(ratios[ratio]['value'], tolerance)
                if (result > 0) {
                    unique++
                    total += result
                }
            }
            return {discrete: unique, instances: total}
        },

        /**
         * &lt;p>Returns the number of unique tetrachords available in the scale.&lt;/p>
         * @return {Number}
         * @function
         * @memberOf Scale#count
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major
         * scale.count.tetrachords() //returns 20*/
        tetrachords: () => {
            return this.get.tetrachords().length
        },

        /**
         * &lt;p>Returns the number of Major and Minor Thirds (with a tolerance of 20 cents) in the scale&lt;/p>.
         *
         * &lt;p>(To count other intervals or set a different tolerance use [Scale.count.ratio()]{@link Scale#count.ratio})&lt;/p>
         * @return {Number}
         * @see Scale#count.ratio
         * @memberOf Scale#count
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //new Scale object
         * scale.count.thirds() //returns 7
         */
        thirds: () => {
            return this.count.interval(this.parent.M3s.concat(this.parent.m3s))
        },

        /**
         * Returns number of unique transpositions available for the scale.
         * @param {Boolean} [cache=false] - when true, the result will be cached for faster retrieval.
         * @return {Number}
         * @function
         * @memberOf Scale#count*/
        transpositions: (cache = false) => {
            if (this.catalog['# transpositions']) return this.catalog['# transpositions']
            let scale = this.pitches
            let scales = [scale]
            for (let i = 0; i &lt; this.parent.edo; i++) {
                let t_scale = []
                scale.forEach((note) => {
                    t_scale.push((note + i + 1) % this.edo)
                })
                t_scale.sort((a, b) => a - b)
                if (this.parent.is.element_of(t_scale, scales)) return scales.length
                scales.push(t_scale)

            }
            let result = scales.length
            if (cache) this.catalog['# transpositions'] = result
            return result
        },

        /**
         * &lt;p>Returns the number of unique trichords available in the scale.&lt;/p>
         * @return {Number}
         * @function
         * @memberOf Scale#count
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major
         * scale.count.trichords() //returns 15*/
        trichords: () => {
            return this.get.trichords().length
        }

    }

    /**A collection of functions that exports various file formats
     * @namespace*/
    export = {
        /**Generates a scala file with the current tuning of the scale
         * @param {String} [filename] - When not provided, the file name will be the name of the scale
         * @param {String} [dir=true] - The directory to which the file will be saved
         * @memberOf Scale#export
         *
         * @example
         * let edo = new EDO(17) //define context
         * let scale = edo.scale([0,1,4,5,7,13,16]) //some scale in 17-EDO
         * scale.export.scala("my_tuning.scl") //outputs /scala/my_tuning.scl
         */
        scala: (filename, dir = "scala/",) => {
            let scale_name = this.get.name()
            filename = filename || scale_name + ".scl"
            let file = "! " + filename + "\n"
            file += "!\n" + scale_name + " " + JSON.stringify(this.get.pitches()) + "\n"
            file += String(this.count.pitches() + 1) + "\n!\n"
            let scale_in_cents = this.to.cents()
            for (let pitch of scale_in_cents) {
                file += String(pitch) + "\n"
            }
            file += "2/1"
            save_file(filename, dir, file)
        }
    }

    /**A collection of functions manipulates the scale and returns diverse information about it
     * @namespace*/
    get = {

        /** Returns the area of the polygon created by the nodes of the set on the bracelet.
         * With radius left to its default value, the area of the entire bracelet is 1, so this function will return a value between 0 to 1.
         * @param  {Number} [r = 0.56418958354776] - The radius of the circle/bracelet. The default value is the radius of a circle with area=1
         * @returns {Number} The area of the polygon. with the default settings if also conveys the percentage of the circle being occupied. (0=0% - 1=100%)
         * @memberOf Scale#get
         * @see EDO#get.area
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,1,2,3,4,5,6,7,8,9,10,11]) //chromatic scale
         * scale.get.coordinates() //returns 0.9549296585513847
         *
         * scale = edo.scale([0,4,7]) //major triad
         * scale.get.coordinates() //returns 0.376564638493296
         */
        area: (r=0.56418958354776 /*radius of circle with area=1*/) => {
            const angle_discrete = 360/this.edo
            const coors = this.get.coordinates([0,0],r)
            let part_a=0
            let part_b=0
            for (let i = 0; i &lt; coors.length; i++) {
                part_a+=(coors[i][0]*coors[(i+1)%coors.length][1])
                part_b+=(coors[i][1]*coors[(i+1)%coors.length][0])
            }
            let area = Math.abs((part_a-part_b)/2)
            return area
        },

        /** Returns the [x,y] coordinates of the nodes of the scale.
         * @param  {Array&lt;Number>} [circle_center=[0,0]] - The center of the circle
         * @param  {Number} [r=0.56418958354776] - The radius of the circle. By default the radius is of a circle with area=1
         * @returns {Array&lt;Array&lt;Number,Number>>} An array with tuples each corresponding to the x,y position of every pitch
         * @memberOf Scale#get
         * @see EDO#get.coordinates
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,3,7]) //minor triad
         * scale.get.coordinates()
         * //returns
         * [
         *  [ 0, 0.56418958354776 ],
         *  [ 0.5043836053298857, -0.25279846688265545 ],
         *  [ 0.26388191608137657, -0.4986744635020088 ]
         * ]
         */
        coordinates: (circle_center=[0,0],r=0.56418958354776) => {
            return this.parent.get.coordinates(this.pitches,circle_center,r)
        },

        /** Returns all the transpositions of the scale that are constructed on the scale degrees of the original scale,
         * As well the the number of notes altered to get from the original scale to the new scale as a "Tuple"
         * @param  {Boolean} [normalize=true] - when true, all of the transpositions will be constructed by altering the original scale
         * @returns {Array&lt;Array&lt;Number>,Number>} An array containing all of the stacks
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,3,7]) //minor triad
         * scale.get.common_tone_transpositions()
         * //returns
         *
         * [
         *  [ [ 0, 3, 7 ], 0 ],
         *  [ [ 0, 4, 9 ], 2 ],
         *  [ [ 0, 5, 8 ], 2 ],
         *  [ [ 3, 6, 10 ], 2 ],
         *  [ [ 3, 8, 11 ], 2 ],
         *  [ [ 2, 7, 10 ], 2 ],
         *  [ [ 4, 7, 11 ], 2 ]
         * ]
         */
        common_tone_transpositions: (sort) => {
            let modes = this.get.modes()
            let result = []
            this.pitches.forEach((pitch) => {
                modes.forEach((mode, inversion) => {
                    let transposition = mode.map((note) => this.parent.mod(note + pitch, this.edo))
                    if(sort) transposition = transposition.sort((a, b) => a - b)
                    let CT = this.parent.count.common_tones(this.pitches, transposition)
                    result.push({
                        transposition: transposition,
                        common_tones: CT,
                        altered_tones: this.count.pitches() - CT,
                        common_tone: pitch,
                        as_scale_degree: inversion + 1
                    })
                })
            })
            result = this.parent.get.unique_elements(result)
            return result
        },

        /** &lt;p>Returns all the PCs of the EDO that the scale does not use.&lt;/p>
         * @param {boolean} [from_0=false] - when true, the output will be normalized to 0.
         * @returns {Array&lt;Number>}
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * let scale = edo.scale([0,2,4,5,7,9,11])
         * scale.get.complement()
         * //returns [1, 3, 6, 8, 10]
         *
         * scale.get.complement(true)
         * //returns [0, 2, 5, 7, 9]
         */
        complement: (from_0) => {
            return this.parent.get.complementary_set(this.pitches, from_0)
        },

        /** &lt;p>Returns the pitch classes of a chord "shape" on a given scale degree.&lt;/p>
         * &lt;p>for instance, in C major, the shape 1,2,3,5 on 1 gives C D E G, and starting on 2, gives D E F A.&lt;/p>
         * @param {Array&lt;Number>} shape - The "shape" starting from 1.
         * @param {Number} [scale_degree=1] - The scale degree on which to apply the shape (starting from 1)
         * @returns {Array&lt;Number>} - The resultant pitch classes from that shape on that scale degree.
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * let scale = edo.scale([0,2,4,5,7,9,11])
         * scale.get.chord_quality_from_shape([1,5,6],1)
         * //returns [0, 7, 9]
         *
         * scale.get.chord_quality_from_shape([1,3,4,5,7],7)
         * //returns [11, 2, 4, 6, 9]
         *
         * scale.get.chord_quality_from_shape([1,7,3,13,9],5) //Get a 7,9,13 (no 5) chord, on scale degree 5, in this specific voicing.
         */
        chord_quality_from_shape: (shape,scale_degree=1) =>{
            shape = shape.map(note=>{
                note = this.parent.mod(note,this.pitches.length)
                return (note==0)?this.pitches.length:note
            })
            return shape.map(note=>{
                let pos = this.parent.mod((note+scale_degree)-2,this.pitches.length)
                return this.pitches[pos]
            })
        },

        /** &lt;p>Given a generic interval ("scale degrees apart") returns all of the specific intervals.&lt;/p>
         * @param {Number} generic_interval_size- The generic interval
         * @returns {Array&lt;Object>}
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * let scale = edo.scale([0,2,4,5,7,9,11])
         * scale.get.generic_intervals(3) //3 scale-degrees apart (e.g 4ths)
         * //returns
         * [
         *  {"generic":3,"specific":5,"pitches":[[0,5],[2,7],[4,9],[7,0],[9,2],[11,4]],"instances":6},
         *  {"generic":3,"specific":6,"pitches":[[5,11]],"instances":1}
         * ]
         * @see Rahn, J. (1991). "Coordination of interval sizes in seven-tone collections." Journal of Music Theory 35(1/2): 33-60.
         * @see Scale#get.specific_intervals
         */
        generic_intervals: (generic_interval_size=1) => {
            let arr = []
            let g= generic_interval_size
            let mod = this.parent.mod
            let p =this.pitches
            let len = p.length
            let map = {}
            for (let i = 0; i &lt; len; i++) {
                let note1 = p[i]
                let note2 = p[mod(i+g,len)]
                let spec = mod(note2-note1,this.edo)
                if(!map[spec]) map[spec]=[[note1,note2]]
                else map[spec].push([note1,note2])
            }
            for(let key in map) {
                arr.push({generic:g,specific:parseInt(key),pitches:map[key],instances:map[key].length})
            }
            return arr
        },

        /** &lt;p>Given a specific interval (in semitones or whatever the smallest division is) returns all of the generic intervals.&lt;/p>
         * @param {Number} specific_interval_size- The specific interval size (in semitones or whatever the smallest division is)
         * @returns {Array&lt;Object>}
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) // define a tuning system
         * let scale = edo.scale([0,2,4,5,7,9,11])
         * scale.get.specific_intervals(6) //3 scale-degrees apart (e.g 4ths)
         * //returns
         * [
         *  {"generic":"3","specific":6,"pitches":[[5,11]],"instances":1},
         *  {"generic":"4","specific":6,"pitches":[[11,5]],"instances":1}
         * ]
         * @see Rahn, J. (1991). "Coordination of interval sizes in seven-tone collections." Journal of Music Theory 35(1/2): 33-60.
         * @see Scale#get.generic_intervals
         */
        specific_intervals: (specific_interval_size=1) => {
            let arr = []
            let s= specific_interval_size
            let mod = this.parent.mod
            let p =this.pitches
            let len = p.length
            let map = {}
            loop1:
            for (let i = 0; i &lt; len; i++) {
                loop2:
                for (let g = 1; g &lt; len; g++) {
                    let note1=p[i]
                    let note2 = p[mod(i+g,len)]

                    let diff =  mod(note2-note1,this.edo)
                    if(diff==s) {
                        if(!map[g]) map[g]=[[note1,note2]]
                        else map[g].push([note1,note2])
                        break loop2
                    } else if (diff>s) break loop2
                }
            }
            for(let key in map) {
                arr.push({generic:key,specific:s,pitches:map[key],instances:map[key].length})
            }
            return arr

        },

        /** Returns the interval vector of the scale.
         * @param  {Boolean} cache - When true, the result will be cached for faster retrieval
         * @returns {Array&lt;Number>} An array representing the vector
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.interval_vector() //returns [ 1, 5, 2, 3, 3, 1 ]
         */
        interval_vector: (cache = false) => {
            if (this.catalog['interval vector']) return this.catalog['interval vector']

            let scale_split = Math.floor(this.edo / 2)
            let vector = Array.from(new Array(scale_split).fill(0))
            let normal = this.get.normal_order()
            for (let i = 0; i &lt; normal.length - 1; i++) {
                for (let j = i + 1; j &lt; normal.length; j++) {
                    let IC = normal[j] - normal[i]
                    if (IC > scale_split) IC = this.edo - IC
                    if (IC == 0) IC = scale_split
                    vector[IC - 1]++
                }

            }

            if (cache) this.catalog['interval vector'] = vector
            return vector


        },

        /** &lt;p>Returns the scale's inversion&lt;/p>

         * @param {Boolean} [cache=false] - When true, the result will be cached for future retrieval
         * @returns {Array&lt;Number>} the inverted pitches
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.inversion() //returns [0, 2, 4, 6, 7, 9, 11]*/
        inversion: (cache = false) => {
            /*Inverts the intervals of the scale*/
            if (this.catalog['inverted']) return this.catalog['inverted']

            let scale = this.parent.get.inversion(this.pitches, cache = false)
            if (cache) this.catalog['inverted'] = scale

            return scale
        },

        /** &lt;p>Returns the smallest multiplier between the sizes of steps&lt;/p>
         * @returns {Number} The step sizes
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,1,4,5,7,8,11]) //define scale with 3 kinds of steps (1,2, and 3)
         * scale.get.least_step_multiplier()
         * //returns 1.5
         * //2 is a multiplier of 2 over 1. 3 is a multiplier of 3 over one and 1.5 over two.
         * //Therefore, the function will return 1.5.
         * @memberOf Scale#get*/
        least_step_multiplier: () => {

            let steps = this.get.step_sizes()
            if (steps.length == 1) return 1
            let size = this.edo
            for (let i = 0; i &lt; steps.length - 1; i++) {
                if (steps[i + 1] / steps[i] &lt; size) size = steps[i + 1] / steps[i]
            }
            return size
        },

        /** &lt;p>Calculates the attraction between note1 to note2 according to Lerdahl's formula in TPS&lt;/p>
         * @see Lerdahl, F. (2004). Tonal pitch space, Oxford University Press.
         * @param {Number} note1 - The first PC
         * @param {Number} note2 - The second PC
         * @returns {Number} The value of attraction between note1 and note2
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.lerdahl_attraction(1,0) //returns 4*/
        lerdahl_attraction: (note1, note2) => {
            if (note1 == note2) return 0
            note1 = {pitch: note1}
            note2 = {pitch: note2}

            // first we check which level each pitch belongs to:
            // 1 if C, 2 if E or G, and 3 for everything else

            const get_note_anchoring_strength = (note) => {
                if (note == 0) return 4
                else {
                    if (this.parent.P5s.indexOf(note) >= 0 || this.parent.M3s.indexOf(note) >= 0) return 3
                    else return 1
                }
            }

            note1.anchoring = get_note_anchoring_strength(note1.pitch)
            note2.anchoring = get_note_anchoring_strength(note2.pitch)

            let dist = Math.abs(note1.pitch - note2.pitch)
            if (dist > this.edo / 2) dist = this.edo - dist
            dist = dist * 12 / this.edo

            //if neither note is more stable
            if (note2.anchoring == note1.anchoring) return 0

            // original Lerdahl uses square of distance.
            // return (note2['anchoring']/note1['anchoring'])*(1/math.pow(dist,2))
            // I find that omitting the square generalizes better
            return (note2.anchoring / note1.anchoring) * (1 / dist)
        },

        /** &lt;p>Returns a graphic vector showing the tendencies of each note in the scale&lt;/p>
         * @returns {Array&lt;String>} The attraction vector
         * @see Scale.get.lerdahl_attraction()
         * @see Lerdahl, F. (2004). Tonal pitch space, Oxford University Press.
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.lerdahl_attraction_vector() //returns [*,&lt;>,*,&lt;>,*,&lt;&lt;,>>]
         * @memberOf Scale#get*/
        lerdahl_attraction_vector: () => {

            let vector = []
            for (let i = 0; i &lt; this.pitches.length; i++) {
                let note = this.pitches[i]
                let ln = this.pitches[this.parent.mod(i - 1, this.pitches.length)]
                let un = this.pitches[this.parent.mod(i + 1, this.pitches.length)]
                ln = this.get.lerdahl_attraction(note, ln)
                un = this.get.lerdahl_attraction(note, un)
                if (ln &lt; 1 &amp;&amp; un &lt; 1) vector.push('*')
                else if (ln &lt; 1 &amp;&amp; un >= 1) vector.push('>>')
                else if (ln >= 1 &amp;&amp; un &lt; 1) vector.push('&lt;&lt;')
                else if (ln >= 1 &amp;&amp; un >= 1) vector.push('&lt;>')
            }
            return vector

        },

        /** &lt;p>Returns the Levenshtein distance of the scale to another scale&lt;/p>
         * @param {Array&lt;Number>} t - Some collection of pitches to perferm the comparison with
         * @param {Boolean} [ratio_calc=false] - When true, the function computes the
         levenshtein distance ratio of similarity between two strings
         * @returns {Number}
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,7,9]) //a major pentatonic scale
         * scale.get.levenshtein([0,2,4,5,7,9,11] //returns 1
         *
         * @example
         * scale.get.levenshtein([0,2,4,5,7,9,11],true) //returns 0.9230769230769231
         * @memberOf Scale#get
         * @see EDO#get.levenshtein
         * */
        levenshtein: (t, ratio_calc = false) => {
           return this.parent.get.levenshtein(this.pitches,t,ratio_calc)
        },

        /** &lt;p>Returns true if a scale has the Myhill Property&lt;/p>
         * @param {Number} [constant=2] - The exact number of specific intervals necessary for each generic interval
         * @returns {Boolean}
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,7,9]) //a major pentatonic scale
         * scale.get.myhill_property() //true
         * @see Clough, J. and G. Myerson (1985). "Variety and multiplicity in diatonic systems." Journal of Music Theory 29(2): 249-270.
         * */
        myhill_property: (constant = 2)=>{
            let map = {}
            let mod = this.parent.mod
            let n = this.count.pitches()
            let p = this.pitches
            for (let i = 1; i &lt; n; i++) {
                map[i]=new Set()
                for (let j = 0; j &lt; n; j++) {
                    map[i].add(mod(p[mod(j+i,n)]-p[j],this.edo))
                    if(map[i].size>constant) return false
                }
            }
            for (let i = 1; i &lt;n ; i++) {
                if(map[i].size!=constant) return false
            }

            return true
        },

        /** Returns all the various modes (normalized to 0, that include all pitches) available from this scale
         * @param  {Boolean} cache - When true, the result will be cached for faster retrieval
         * @returns {Array&lt;Array&lt;Number>>} An array of the different modes
         * @memberOf Scale#get
         *
         * @see EDO#get.modes
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,7,9]) //pentatonic scale
         * scale.get.modes()
         * //returns
         * [
         *  [ 0, 2, 4, 7, 9 ],
         *  [ 0, 2, 5, 7, 10 ],
         *  [ 0, 3, 5, 8, 10 ],
         *  [ 0, 2, 5, 7, 9 ],
         *  [ 0, 3, 5, 7, 10 ]
         * ]
         */
        modes: (cache = false) => {
            if (this.catalog['modes']) return this.catalog['modes']

            let modes = this.parent.get.modes(this.pitches)
            if (cache) return this.catalog['modes'] = modes
            return modes
        },

        /**
         * &lt;p>Same as [EDO.get.motives()]{@link EDO#get.motives} only instead of considering pitches as pitch classes, it looks at them as scale degrees.&lt;/p>
         * &lt;p>As such, in the scale &lt;code>[0,2,4,5,7,9,11]&lt;/code>, &lt;code>[0,2,4]&lt;/code> and &lt;code>[2,4,5]&lt;/code> are considered the same motive
         * This is because while the former has steps of size &lt;code>[2,2]&lt;/code> and the latter &lt;code>[2,1]&lt;/code> they both represent moving
         * 2 scale degrees up step wise in the scale &lt;code>[1,1]&lt;/code>.&lt;/p>
         * @param  {Array&lt;Number>} melody - a collection of pitches to find (in order)
         * @param  {Boolean} [allow_skips=true] - if false, the search will only be done on consecutive items
         * @return {Array&lt;motive>}
         * @memberOf Scale#get
         * @see {@link EDO#get.motives}
         * @example
         * let edo = new EDO(12) // define a tuning system
         * let melody = [8,7,7,8,7,7,8,7,7,15,15,14,12,12,10,8,8,7,5,5] // Mozart Symphony no. 40
         * let scale = edo.scale([0,2,3,5,7,8,10]) //natural minor
         * scale.get.motives_diatonic(melody) // find diatonic motives in the melody
         *                      .slice(0,3) //show top 3
         * //returns (motives are represented in change in scale degrees)
         * [
         *  { motive: [ 0 ], incidence: 9 },
         *  { motive: [ -1 ], incidence: 6 },
         *  { motive: [ -1, 0 ], incidence: 5 }
         * ]
         */
        motives_diatonic: (melody, allow_skips = false,maximal_length=8) => {
            let scale = this.pitches
            let not_in_scale = melody.filter((note) => scale.indexOf(this.parent.mod(note, this.edo)) == -1)
            if (not_in_scale.length > 0) return null

            scale = this.parent.get.unique_elements(scale).sort((a, b) => a - b)

            let scale_degrees = melody.map((note) => scale.indexOf(note) + 1)
            let motives = this.parent.get.motives(scale_degrees, true, allow_skips,maximal_length)
            return motives

        },

        /** &lt;p>Returns every n_chord (bichord (&lt;code>n=2&lt;/code>), trichord (&lt;code>n=3&lt;/code>), tetrachord (&lt;code>n=4&lt;/code>), etc.) available in this scale&lt;/p>
         * @param  {Number} n - Number of pitches in every chord
         * @param  {Boolean} [normalize=true] - When true, the function will return n_chords in normal order. otherwise it will return them as they appear in the scale
         * @param  {Boolean} [cache=false] - When true, the result will be cached for faster retrieval
         * @returns {Array&lt;Number>} An array containing all n_chords
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,7,9]) //pentatonic scale
         * scale.get.n_chords(3) //same as scale.get.trichords()
         * [
         *  [ 0, 2, 4 ],
         *  [ 0, 2, 7 ],
         *  [ 0, 3, 5 ],
         *  [ 0, 4, 7 ],
         *  [ 0, 3, 7 ],
         *  [ 0, 2, 5 ]
         * ]
         *
         * @see Scale#get.trichords
         * @see Scale#get.tetrachords
         */
        n_chords: (n, normalize = true, cache = false) => {
            if (this.catalog['n_chords']) {
                if (Array.isArray(this.catalog['n_chords'][n])) return this.catalog['n_chords'][n]
            } else this.catalog['n_chords'] = {}

            let all = []
            let extended = [...this.pitches, ...this.pitches.slice(0, n - 1)]
            const run_it = (i = 0, n_chord = []) => {
                if (n_chord.length == n) {
                    if (this.parent.get.unique_elements(n_chord).length == n_chord.length) {
                        n_chord = n_chord.sort((a, b) => a - b)
                        if (normalize) n_chord = this.parent.get.normal_order(n_chord)
                        all.push(n_chord)
                    }
                    return
                }
                for (let j = i; j &lt; this.pitches.length + (n - 1); j++) {

                    run_it(j + 1, [...n_chord, this.pitches[this.parent.mod(j, this.pitches.length)]])

                }

            }
            run_it()
            all = this.parent.get.unique_elements(all)
            if (cache) this.catalog['n_chords'][n] = all
            return all
        },

        /** &lt;p>Return every quality available in the scale for a combination of &lt;code>n&lt;/code> scale degrees.&lt;/p>
         * @param  {Number} n - Number of pitches in every chord
         * @returns {Array&lt;steps_quality_obj>}
         * @memberOf Scale#get
         * @see Scale#get.steps_to_qualities
         */
        n_chords_diatonic: (n) => {
            let t_edo = new EDO(this.count.pitches())
            let t_scale = t_edo.scale(Array.from(Array(this.count.pitches()).keys()))
            let combinations = t_scale.get.n_chords(n)
            let modes = this.get.modes()
            let n_chords = combinations.map((combo) => {
                let steps = this.parent.convert.to_steps(combo)
                return this.get.steps_to_qualities(steps)
            })
            n_chords = n_chords.map((chord) => {
                chord.combos = chord.combos.sort((a, b) => a.positions.length - b.positions.length)
                return chord
            })
            return n_chords
        },

        /**
         * &lt;p>The name of the scale in the form EDO-Code, EDO being the number of divisions of the octave in the current
         * system, and code being the binary value of the scale (see example below).&lt;/p>
         * &lt;p>For simplicity consider a system with 4 divisions. Such a system has 4 possible pitches: &lt;code>[0,1,2,3]&lt;/code>.&lt;br>
         *     The scale vector is a binary representation of the PCs used in the scale in reversed order. So the scale
         *     [0,2] would have a representation of: &lt;code>[0,1,0,1]&lt;/code>&lt;br>
         *         As such, the name for this scale will be 4-5&lt;/p>
         * @memberOf Scale#get
         * */
        name: () => {

            let normal = this.get.normal_order()
            let total = 0
            normal.forEach((i) => {
                total += Math.pow(2, i)
            })
            return String(this.parent.edo) + "-" + String(parseInt(total))


        },

        /** &lt;p>Returns the scale's pitches in normal order&lt;/p>

         * @param {Boolean} [cache=false] - When true, the result will be cached for future retrieval
         * @returns {Array&lt;Number>} The pitches in normal order
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.normal_order() //returns [0, 1, 3, 5, 6, 8, 10] */
        normal_order: (cache = false) => {
            /*
            Returns the scale in normal order

            :param cache:
            :return:
            */
            if (this.catalog['normal_order']) return this.catalog['normal_order']

            let lst = this.pitches
            let result = this.parent.get.normal_order(lst, cache = false)

            if (cache) this.catalog['normal_order'] = result
            return result

        },

        /** &lt;p>Returns the generic and specific intervals for a pair of scale degrees&lt;/p>

     * @param {Number} SD1 - The first scale degree
     * @param {Number} SD2 - The second scale degree
     * @returns {Array&lt;Number>}
     * @memberOf Scale#get
     *
     * @example
     * let edo = new EDO(12) //define context
     * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
     * scale.get.pairwise_generic_specific_intervals() //returns [0, 1, 3, 5, 6, 8, 10]
     * @see Rahn, J. (1991). "Coordination of interval sizes in seven-tone collections." Journal of Music Theory 35(1/2): 33-60.
     * */
        pairwise_generic_specific_intervals: (SD1,SD2) => {
            let mod = this.parent.mod
            let p = this.pitches
            let len = p.length
            let specific = mod(p[mod(SD2,len)]-p[mod(SD1,len)],this.edo)
            let generic = mod(SD2 - SD1,len)
            return {specific:specific,generic:generic}
        },

        /** &lt;p>Returns every ordering (permutation) of notes in the scale&lt;/p>
         *
         * &lt;p>Uses [EDO.get.permutations()]{@link EDO#get.permutations}&lt;/p>
         * @returns {Array&lt;Array&lt;Number>>} The permutations of the scale
         * @memberOf Scale#get
         * @see EDO#get.permutations
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,3,7]) //minor triad
         * scale.get.permutations()
         * //returns
         * [
         *  [ 0, 4, 7 ],
         *  [ 0, 7, 4 ],
         *  [ 4, 0, 7 ],
         *  [ 4, 7, 0 ],
         *  [ 7, 0, 4 ],
         *  [ 7, 4, 0 ]
         * ]
         * */
        permutations: () => {
            return this.parent.get.permutations(this.pitches)
        },

        /** Returns the scale's pitches as pitch classes
         * @returns {Array&lt;Number>} The scale's pitches as PCs
         * @memberOf Scale#get
         */
        pitches: () => {
            return this.pitches
        },

        /** &lt;p>Gets a list of intervals above a root, and returns all the positions in the scale where this
         chord quality can be created&lt;/p>
         *
         * @returns {Array&lt;Number>} The PCs on which the quality can be built
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.position_of_quality([4,7]) (a major triad)
         * //returns [0,5,7] because you can construct a major triad on 0, 5, and 7*/
        position_of_quality: (intervals) => {
            let result = []
            let double_scale = [...this.pitches, ...this.pitches]

            for (let pitch of this.pitches) {
                let int = intervals.map((interval) => (interval + pitch) % this.edo)
                let s = [...int]
                if (this.parent.is.subset(s, double_scale)) result.push(pitch)
            }
            return result


        },

        /** &lt;p>Returns the scale's pitches in prime form&lt;/p>
         * (Notice, the prime form calculation conforms to Rahn's prime form rather than Forte's)
         * @param {Boolean} [cache=false] - When true, the result will be cached for future retrieval
         * @returns {Array&lt;Number>} The pitches in prime form
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.prime_form() //returns [0, 1, 3, 5, 6, 8, 10]*/
        prime_form: (cache = false) => {
            /*Returns the scale in prime form*/
            if (this.catalog['prime form']) return this.catalog['prime form']
            let i_self = this.parent.scale(this.get.inversion())
            let norm_ord = this.parent.scale(this.get.normal_order())
            let i_norm_ord = this.parent.scale(i_self.get.normal_order())
            let scale_steps = norm_ord.to.steps()
            let i_scale_steps = i_norm_ord.to.steps()
            let result = norm_ord.pitches
            for (let i = 0; i &lt; scale_steps.length; i++) {
                if (scale_steps[i] &lt; i_scale_steps[i]) {
                    result = norm_ord.pitches
                    break
                } else if (scale_steps[i] > i_scale_steps[i]) {
                    result = i_norm_ord.pitches
                    break
                }

            }
            if (cache) this.catalog['prime form'] = result
            return result
        },

        /** &lt;p>Returns the scale's pitches in prime form&lt;/p>

         * @param {Number} multiplier - The number by which to multiply the set
         * @param {Boolean} [sort=false] - When true, the returned result will be sorted
         * @returns {Array&lt;Number>} The pitches after multiplication
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,7,9]) //pentatonic scale
         * scale.get.product(2) //returns [ 0, 4, 8, 2, 6 ]
         * scale.get.product(5,true) //returns [ 0, 8, 9, 10, 11 ]*/
        product: (multiplier,sort=false) => {

            let res =  this.pitches.map(n=>this.parent.mod(n*multiplier,this.edo))
            if(sort) res = res.sort((a,b)=>a-b)
            return res
        },

        /** &lt;p>Returns note combination of a given length who are restricted to only using specified intervals within the scale&lt;/p>

         * @param {Array&lt;Number>} intervals - A list of allowed intervals
         * @param {Number} length - The length of the returned combinations. If not specific length will default to the length of the scale
         * @returns {Array&lt;Number>} The pitches after multiplication
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,7,9]) //pentatonic scale
         * scale.get.product(2) //returns [ 0, 4, 8, 2, 6 ]
         * scale.get.product(5,true) //returns [ 0, 8, 9, 10, 11 ]*/
        quality_with_intervals: (intervals=[7],length) => {
            let all = []
            let TET = this.edo
            let helper = function (scale, sizes,length,last) {
                if(!length) length= scale.length
                if(!last) last = [scale.shift()]
                if(last.length==length) return last

                let result = sizes.map(size=>{

                    let note = (last[last.length-1]+size)%TET
                    let ind = scale.indexOf(note)
                    if(ind==-1) return false
                    else {
                        let new_scale = [...scale]
                        new_scale.splice(ind,1)
                        let new_last = [...last,note]
                        return helper(new_scale,sizes,length,new_last)
                    }
                }).reduce((ag,el)=>el?[...ag,el]:ag,[]).flat()

                const chunk = function(array, size) {
                    if (!array.length) {
                        return [];
                    }
                    const head = array.slice(0, size);
                    const tail = array.slice(size);

                    return [head, ...chunk(tail, size)];
                };
                return chunk(result.flat(),length)
            }

            let modes = this.parent.get.rotations(this.pitches)
            for (let i = 0; i &lt; modes.length; i++) {
                all = all.concat(helper(modes[i],intervals,length))
            }


            return all
        },

        /** &lt;p>Returns all of the rotations of the scale (not normalized to 0).&lt;/p>
         *
         * &lt;p>To get the rotations normalized to zero (the modes) use [Scale.get.modes()]{@link Scale#get.modes}&lt;/p>
         * @returns {Array&lt;Array&lt;Number>>} The rotations of the scale
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,3,7]) //minor triad
         * scale.get.rotations()
         * //returns [[0,3,7],[3,7,0],[7,0,3]]*/
        rotations: () => {
            let rotations = []
            let rotate = [...this.pitches]
            while (!this.parent.is.element_of(rotate, rotations)) {
                rotations.push(rotate)
                rotate = [...rotate.slice(1), ...rotate.slice(0, 1)]
            }
            return rotations
        },

        /** &lt;p>Returns the Rothenberg Propriety value for this scale&lt;/p>
         * @see Rothenberg, D. (1977). "A model for pattern perception with musical applications part I: Pitch structures as order-preserving maps." Mathematical Systems Theory 11(1): 199-234.
         * @param {Boolean} [cache=false] - When true, the result will be cached for future retrieval.
         * @returns {('strictly proper'|'proper'|'improper')} The step sizes
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,7,9]) //a major pentatonic scale
         * scale.get.rothenberg_propriety()
         * //returns "strictly proper"
         * @memberOf Scale#get*/
        rothenberg_propriety: (cache = false) => {
            if (this.catalog['rothenberg']) return this.catalog['rothenberg']

            let scale = this.pitches
            let map = []
            let steps = Array(scale.length - 1).fill(0).map((el, i) => i + 1)
            let intervals = this.to.steps()
            steps.forEach((step) => {
                let double_intervals = intervals.concat(intervals)
                let interval_classes = []
                for (let i = 0; i &lt; intervals.length; i++) {
                    let sli = double_intervals.slice(i, i + step)
                    sli = sli.reduce((t, e) => t + e)
                    interval_classes.push(sli)
                }
                map.push({min: Math.min.apply(Math, interval_classes), max: Math.max.apply(Math, interval_classes)})
            })
            let strictly_proper = true
            let proper = true
            for (let i = 1; i &lt; map.length; i++) {
                if (map[i]['min'] &lt;= map[i - 1]['max']) strictly_proper = false
                if (map[i]['min'] &lt; map[i - 1]['max']) proper = false
            }

            let result = ""
            if (strictly_proper) result = "strictly proper"
            else if (proper) result = "proper"
            else result = "improper"
            if (cache) this.catalog['rothenberg'] = result
            return result
        },

        /** &lt;p>Returns the sum of the roughness of every pair in the set, averaged across all modes&lt;/p>
         * @param {Boolean} [all_modes=false] - When true, the algorithm returns the roughness value for all of the modes
         * @param {Number} [base_freq=440] - The frequency to associate with PC0
         * @returns Number
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,7,9]) //a major pentatonic scale
         * scale.get.roughness()
         * //returns 0.376424315400336
         * @memberOf Scale#get
         * @see EDO#get.sine_pair_dissonance
         * */
        roughness: (all_modes=false,base_freq=440) => {
            const get_scale_roughness =function (scale) {
                    let pairs = scale.parent.get.n_choose_k(scale.pitches,2)
                    pairs = pairs.map(p=>scale.parent.convert.midi_to_freq(p,69,base_freq))
                        .map(p=>scale.parent.get.sine_pair_dissonance(p[0],p[1],1,1))
                        .reduce((ag,e)=>ag+e,0)
                    return pairs
            }
            if(all_modes) {
                let roughness_arr = []
                for (let i = 0; i &lt; this.count.pitches(); i++) {
                    roughness_arr.push(get_scale_roughness(this.mode(i)))
                }
                return roughness_arr
            }
            else {
                return get_scale_roughness(this)
            }

        },

        /** &lt;p>Returns the sameness quotient according to Carey (2007) (see citation)&lt;/p>
         * @returns Number
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,6,8,10]) //a whole-tone scale
         * scale.get.sameness_quotient() //returns 1
         *
         * scale = edo.scale([0,2,4,5,7,9,11]) //the diatonic scale
         * scale.get.sameness_quotient() //returns 0.5555555555555556
         * @see Carey, N. (2007). "Coherence and sameness in well-formed and pairwise well-formed scales." Journal of Mathematics and Music 1(2): 79-98.
         * @memberOf Scale#get*/
        sameness_quotient: () => {
            let D_S = this.count.rahn_differences()
            let max_D = this.parent.get.maximal_rahn_difference(this.count.pitches())
            return 1-(D_S/max_D)
        },

        /** &lt;p>Returns the coherence quotient according to Carey (2007) (see citation)&lt;/p>
         * @returns Number
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,5,7,9,11]) //The diatonic scale
         * scale.get.coherence_quotient() //returns 1
         * @see Carey, N. (2007). "Coherence and sameness in well-formed and pairwise well-formed scales." Journal of Mathematics and Music 1(2): 79-98.
         * @memberOf Scale#get*/
        coherence_quotient: () => {
            let all_amb = this.count.rahn_ambiguities()
            let all_cont = this.count.rahn_contradictions()
            let total = all_amb + all_cont
            let maximal_failures = this.parent.get.maximal_carey_coherence_failures(this.count.pitches())
            return 1-(total/maximal_failures)
        },

        /** Returns all the transpositions of the scale that are constructed on the scale degrees of the original scale,
         * As well the the number of notes altered to get from the original scale to the new scale as a "Tuple"
         * @param  {Boolean} [normalize=true] - when true, all of the transpositions will be constructed by altering the original scale
         * @returns {Array&lt;Array&lt;Number>,Number>} An array containing all of the stacks
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.scale_degree_transpositions()
         * //returns
         *
         * [
         *  [ [0, 2, 4, 5, 7, 9, 11], 0 ],
         *  [ [0, 2, 4, 5, 7, 9, 10], 1 ],
         *  [ [0, 2, 4, 6, 7, 9, 11], 1 ],
         *  [ [1, 2, 4, 6, 7, 9, 11], 2 ],
         *  [ [1, 2, 4, 6, 8, 9, 11], 3 ],
         *  [ [1, 3, 4, 6, 8, 9, 11], 4 ],
         *  [ [1, 3, 4, 6, 8, 10, 11], 5 ]
         * ]
         */
        scale_degree_transpositions: (normalize = true) => {


            let transpositions = []
            let intervals = this.to.steps()
            intervals = intervals.slice(0, -1) //removing the last step because we don't need the octave completion
            for (let note of this.pitches) {
                let transposition = [note]
                for (let interval of intervals) {
                    let next_note = this.parent.mod(transposition.slice(-1)[0] + interval, this.edo)
                    transposition.push(next_note)
                }
                if (normalize) transposition.sort((a, b) => a - b)
                let CT = this.count.pitches() - this.parent.count.common_tones(this.pitches, transposition)
                transpositions.push([transposition, CT])
            }
            transpositions.sort((a, b) => a[1] - b[1])
            transpositions = this.parent.get.unique_elements(transpositions)
            return transpositions

        },

        /** Returns the scale as steps, broken to their repetitive segments.

         * @returns {Array&lt;Array&lt;Number>>} An array containing the scale's steps in segments
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.segments()
         * //returns [[2,2],[1],[2,2,2],[1]]
         */
        segments: () => {
            let steps = this.to.steps()
            let all = []
            while(steps.length>0) {
                let sub = steps.splice(0,1)
                while(steps[0]==sub[0]) sub.push(steps.splice(0,1)[0])
                all.push(sub)
            }
            return all
        },

        /** &lt;p>Transposes a melody within the scale by a given number of scale degrees&lt;/p>
         * @param {Array&lt;Number>} seq - The original melody / sequence to be "transposed"
         * @param {Number} transposition - The number of scale degrees (up or down) by which to shift the melody.
         * @returns {Array&lt;Number>} The transposed pitches
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,7,9]) //a major pentatonic scale
         * scale.get.sequence_transposition([0,2,4],1) //returns [ 2, 4, 7 ]*/
        sequence_transposition: (seq, transposition) => {
            let mod = this.parent.mod
            let new_seq = []
            for (let note of seq) {
                let scale_degree = this.pitches.indexOf(mod(note, this.edo))
                let octave_shift = Math.floor(note / this.edo)
                scale_degree = scale_degree + transposition
                octave_shift += Math.floor(scale_degree / this.pitches.length)
                scale_degree = mod(scale_degree, this.pitches.length)
                let pitch = this.pitches[scale_degree] + (this.edo * octave_shift)
                new_seq.push(pitch)
            }
            return new_seq
        },

        /** &lt;p>Same as {@link EDO.get.shortest_path()} but for diatonic cases.&lt;/p>
         * &lt;p>Instead of thinking in "intervals" it thinks in steps and scale degrees.
         so in the context of C major, moving from E to G is a move of size 3 (scale degrees),
         and from C to E is also 3 (scale degrees) even though in one case it's a minor third and in
         the other its a Major third.&lt;/p>

         &lt;p>In this function the starting point is scale_degree 1&lt;/p>

         * @param {Number} destination_scale_degree
         * @param {Number} up_steps
         * @param {Number} down_steps
         * @memberOf Scale#get
         * */
        shortest_path: (destination_scale_degree, up_steps = 1, down_steps = -1) => {
            /*same as EDO.shortest_path only for diatonic cases
            Instead of thinking in "intervals" it thinks in steps and scale degrees.
            so in the context of C major, moving from E to G is a move of size 3 (scale degrees),
            and from C to E is also 3 (scale degrees) eventhough in once case it's a minor third and in
            the other its a Major third.

            In this function the starting point is scale_degree 1
            */
            let temp_edo = new EDO(this.count.pitches())
            let result = temp_edo.get.shortest_path(destination_scale_degree - 1, up_steps, down_steps)
            console.log(result)

        },

        /** &lt;p>Returns a list of lists of size "levels" made out of scale degrees with "skip" steps skipped apart.&lt;/p>
         * @param  {Number} levels - The number of levels to the stack
         * @param  {Number} skip - The number of scale steps to skip between each level on the stack
         * @returns {Array&lt;Array&lt;Number>>} An array containing all of the stacks
         * @memberOf Scale#get
         * @example
         * [0,2,4,5,7,9,11] in 12-TET Scale.get.stacks(3,1)
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.stacks(3,1) //get all tercial stacks of 3
         * //returns [[0, 3, 6], [0, 3, 7], [0, 4, 7]]
         *
         * scale.get.stacks(5,2) //get all quartal stacks of 5
         * //returns
         * [
         *  [ 0, 5, 11, 4, 9 ],
         *  [ 0, 5, 10, 3, 9 ],
         *  [ 0, 5, 10, 3, 8 ],
         *  [ 0, 6, 11, 4, 9 ],
         *  [ 0, 5, 10, 4, 9 ]
         * ]
         */
        stacks: (levels, skip) => {
            let scale = this.pitches

            let diapason = ((skip + 1) * (levels - 1)) + 1
            let modes = this.get.modes()
            let stacks = []
            modes.forEach((mode) => {
                let notes = []
                for (let i = 0; i &lt; diapason; i += skip + 1) {
                    notes.push(mode[i % mode.length])
                }
                let temp = new Set(notes)
                if (temp.size == levels) stacks.push(notes)
            })
            stacks = this.parent.get.unique_elements(stacks)
            return stacks
        },

        /** &lt;p>Returns a list of unique step sizes that appear in the scale.&lt;/p>
         * @returns {Array&lt;Number>} The step sizes
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.step_sizes()
         * //returns [1,2]
         * @memberOf Scale#get*/
        step_sizes: (cache = false) => {

            if (this.catalog['step sizes']) return this.catalog['step sizes']
            let lst = this.parent.get.unique_elements(this.to.steps())
            lst.sort((a, b) => a - b)
            if (cache) this.catalog['step sizes'] = lst
            return lst


        },

        /**
         * @typedef {Object} quality_position_obj
         * @property {Array&lt;Number>} quality - Some chord quality
         * @property {Array&lt;Number>} positions - The positions where this quality is available
         */

        /**
         * @typedef {Object} steps_quality_obj
         * @property {Array&lt;Number>} steps - The given steps
         * @property {Array&lt;quality_position_obj>} combos - An array of qualities and their positions
         */

        /** &lt;p>from a given array of steps taken, returns all of the available qualities and their positions&lt;/p>
         * @param {Array&lt;Number>} steps - steps in the scale in the form of [1,1,2,1..] (1=one step, 2= two steps, etc)
         * @returns {quality_position_obj} The step sizes
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.get.steps_to_qualities([1,1]) //two successive steps
         * //returns
         *  {
         *      "steps":[1,1],
         *      "combos":[
         *          {"quality":[0,2,4],"positions":[0,5,7]},
         *          {"quality":[0,2,3],"positions":[2,9]},
         *          {"quality":[0,1,3],"positions":[4,11]}
         *          ]
         *  }
         * @memberOf Scale#get*/
        steps_to_qualities: (steps) => {
            let modes = this.get.modes()
            steps = this.parent.convert.intervals_to_pitches(steps)
            let combos = modes.map((mode) => steps.map((scale_degree) => mode[scale_degree]))
            combos = combos.map((el) => this.parent.get.normal_order(el))
            combos = this.parent.get.unique_elements(combos)
            combos = combos.map((cmb) => {
                return {quality: cmb, positions: this.get.position_of_quality(cmb)}
            })
            return {steps: this.parent.convert.to_steps(steps), combos: combos}
        },

        /** Returns the sets that the scale is contained in from a given list of sets
         * @param  {Array&lt;Array&lt;Number>>} scales - a list of scales
         * @returns {Array&lt;Array&lt;Number>>} the scales that contain the Scale object
         * @memberOf Scale#get
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,3,7]) //minor triad
         * scale.get.supersets([[0,1,2,3,4,5,6,7],[0,3,4,7],[0,1,2]])
         * //returns [[0,1,2,3,4,5,6,7],[0,3,4,7]]*/
        supersets: (scales) => {
            let sets = []
            for (let scale of scales) {
                let modes = this.parent.get.modes(scale)
                for (let mode of modes) {
                    if (this.is.subset(mode)) sets.push(scale)
                }
            }
            sets = this.parent.get.unique_elements(sets)
            return sets
        },

        /** &lt;p>Returns every tetrachord (normalized to 0) available in this scale&lt;/p>
         * &lt;p>Note: for a collection of all pitch subsets of length n (rather than 4) use [Scale.get.n_chords()]{@link Scale#get.n_chords}&lt;/p>
         * @param  {Boolean} cache - When true, the result will be cached for faster retrieval
         * @returns {Array&lt;Number>} An array containing all tetrachords
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,7,9]) //pentatonic scale
         * scale.get.tetrachords()
         * //returns [ [ 0, 2, 4, 7 ], [ 0, 3, 5, 7 ], [ 0, 2, 5, 7 ], [ 0, 3, 5, 8 ] ]
         *
         * @see Scale#get.trichords
         * @see Scale#get.n_chords
         */
        tetrachords: (cache = false) => {
            /*
            Returns a list of every tetrachord (normalized to 0) available in this scale.

            :param cache:
            :return:
            */
            if (this.catalog['tetrachords']) return this.catalog['tetrachords']

            let tetrachords = this.get.n_chords(4, true, cache)

            if (cache) this.catalog['tetrachords'] = tetrachords
            return tetrachords
        },

        /** &lt;p>Returns every possible interpretation of the scale's intervals in terms of their possible scale degree&lt;/p>
         * @param  {Object} [interval_map] - a map of every interval and the role it can play in the scale (for instance PC6 in 12EDO  can be both an augmented 4th and a diminished 5th. see code for clarity). This paramater must be passed in EDO systems other than 12.
         * @returns {Array&lt;Array&lt;Number>>} An array containing every interpretation of the scale degrees.
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,7,9]) //pentatonic scale
         * scale.get.scale_degree_roles()
         * //returns [ [ 1, 2, 3, 5, 6 ], [ 1, 2, 3, 5, 7 ] ] (the last note can be interpreted as a major 6th, or a diminished 7th)
         *
         */
        scale_degree_roles: (interval_map) => {
            if(this.edo!=12 &amp;&amp; !interval_map) return
            if(!interval_map) {
                interval_map = {
                    0:[1],
                    1:[2],
                    2:[2],
                    3:[2,3],
                    4:[3],
                    5:[4],
                    6:[4,5],
                    7:[5],
                    8:[5,6],
                    9:[6,7],
                    10:[6,7],
                    11:[7]
                }

            }
            let interpretations = this.parent.get.partitioned_subsets(this.pitches.map(n=>interval_map[n]))
            return interpretations
        },

        /** &lt;p>Returns the scale's pitches transposed by a certain amount&lt;/p>
         * @param {Number} amount - The amount by which to transpose the pitches
         * @returns {Array&lt;Number>} The transposed pitches
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,7,9]) //a major pentatonic scale
         * scale.get.transposition(5) //returns [ 5, 7, 9, 0, 2 ]*/
        transposition: (amount) => {
            return this.parent.get.transposition(this.pitches, amount)
        },

        /** &lt;p>Returns the transpositions of the scale that include the given pitches verbatim.&lt;/p>
         * @param {Array&lt;Number>} pitches - The pitches to find
         * @returns {Array&lt;Object>} - The property 'pitches' includes the pitches of the transposition. The property 'common_tones' tallies how many pitches the original scale and the transposed scale have in common..
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define tuning
         * let scale = edo.scale([0,2,4,5,5,9,11]) //a major scale
         * scale.get.transpositions_with_pitches(1,4,8)
         * [
         *  {pitches: [9,11,1,2,4,6,8], alterations: 4}, //The transposition starting on 9 contains 1,4,8 verbatim. It has 4 tones in common with the original scale.
         *  {pitches: [4,6,8,9,11,1,3], alterations: 3}, //The transposition starting on 4 ... It has 3 tones in common...
         *  {pitches: [11,1,3,4,6,8,10], alterations: 2} //The transposition starting on 11 ... It has 2 tones in common...
         * ]*/
        transpositions_with_pitches: (pitches) => {
            let scales = []
            for (let i = 0; i &lt; this.edo; i++) {
                let new_scale = this.parent.get.starting_at(this.pitches, i)
                scales.push({
                    pitches: new_scale,
                    common_tones: this.count.pitches() - this.get.levenshtein([...new_scale].sort((a, b) => a - b))
                })
            }
            scales = scales.filter((scale) => {
                let temp = pitches.map((pitch) => scale.pitches.indexOf(pitch) != -1)
                temp = temp.reduce((a, el) => a * el, true)
                return temp
            })
            scales = scales.sort((a, b) => b.common_tones - a.common_tones)
            return scales
        },

        /** &lt;p>Returns every trichord (normalized to 0) available in this scale&lt;/p>
         * &lt;p>Note: for a collection of all pitch subsets of length n (rather than 3) use [Scale.get.n_chords()]{@link Scale#get.n_chords}&lt;/p>
         * @param  {Boolean} cache - When true, the result will be cached for faster retrieval
         * @returns {Array&lt;Number>} An array containing all trichords
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,7,9]) //pentatonic scale
         * scale.get.trichords()
         * //returns
         * [
         *  [ 0, 2, 4 ],
         *  [ 0, 2, 7 ],
         *  [ 0, 3, 5 ],
         *  [ 0, 4, 7 ],
         *  [ 0, 3, 7 ],
         *  [ 0, 2, 5 ]
         * ]
         *
         * @see Scale#get.tetrachords
         * @see Scale#get.n_chords
         */
        trichords: (cache = false) => {
            /*
            Returns a list of every trichord (normalized to 0) available in this scale.

            :param cache:
            :return:
            */
            if (this.catalog['trichords']) return this.catalog['trichords']
            let trichords = this.get.n_chords(3, true, cache)
            if (cache) this.catalog['trichords'] = trichords
            return trichords

        },

        /** &lt;p>Returns the scale without the pitches in &lt;code>to_remove&lt;/code> array&lt;/p>
         * @param  {Array&lt;Number>} to_remove - The pitches to be removed from the original scale
         * @param  {Boolean} [normal=false] - When true, the returned array will be in normal order.
         * @returns {Array&lt;Number>} An array containing the original scale with pitches &lt;code>to_remove&lt;/code> removed.
         * @memberOf Scale#get
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11])
         * scale.get.without([5,11]) //returns [0,2,4,7,9]
         */
        without: (to_remove, normal = false) => {
            return this.parent.get.without(this.pitches, to_remove, normal)
        },

    }

    /**A collection of functions that returns a Boolean about various features regarding the scale
     * @namespace*/
    is = {

        /**&lt;p>Returns true if the scale a deep scale&lt;/p>
         * @returns {Boolean}
         * @memberOf Scale#is
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.is.deep() //returns false
         * @see Clough, J., et al. (1999). "Scales, sets, and interval cycles: A taxonomy." Music Theory Spectrum 21(1): 74-104.
         * */
        deep: () => {
            let vector = this.get.interval_vector()
            let vector_set = new Set(this.get.interval_vector())
            return vector.length==vector_set.size
        },

        /**&lt;p>Returns true if the scale is distributionally even&lt;/p>
         * @returns {Boolean}
         * @memberOf Scale#is
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.is.distributionally_even() //returns true
         * @see Clough, J., et al. (1999). "Scales, sets, and interval cycles: A taxonomy." Music Theory Spectrum 21(1): 74-104.
         * */
        distributionally_even: () => {
            let map = {}
            for (let i = 0; i &lt; this.count.pitches(); i++) {
                let gen = this.get.generic_intervals(i)
                gen.forEach(interval=>(map[interval.generic])?map[interval.generic].push(interval.specific):map[interval.generic]=[interval.specific])
            }
            for (let i = 0; i &lt; this.count.pitches(); i++) {
                if(map[String(i)].length>2) return false
            }
            return true
        },

        /**&lt;p>Returns a list of (lower-order) EDOs if the scale can be represented in them.&lt;/p>
         &lt;p>For instance 12-EDO &lt;code>[0,3,6,9]&lt;/code> also exists in in 4-EDO as &lt;code>[0,1,2,3]&lt;/code>. Therefore the function will return &lt;code>[4]&lt;/code>&lt;/p>
         * @param {Boolean} cache - When true, the result will be cached for faster retrieval in subsequent calls.
         * @returns {Boolean}
         * @memberOf Scale#is
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,3,6,9]) //fully diminished chord
         * scale.is.in_lower_edos() //returns [4]*/
        in_lower_edos: (cache = false) => {

            if (this.catalog['lower EDOs']) return this.catalog['lower EDOs']
            let scale = this.pitches
            let edos = []
            for (let divisor of this.parent.edo_divisors) {
                let valid = true
                for (let note of scale) {
                    if (note % divisor != 0) {
                        valid = false
                        break
                    }
                }
                if (valid) edos.push(parseInt(this.edo / divisor))
            }
            if (cache) this.catalog['lower EDOs'] = edos
            return edos

        },

        /**&lt;p>Returns true if the scale is invertible and false if it isn't&lt;/p>
         * @param {Boolean} [cache=false] - when true, the result will be cached for future retrieval
         * @returns {Boolean}
         * @memberOf Scale#is
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major
         * scale.is.invertible() //returns false*/
        invertible: (cache = false) => {
            if (this.catalog['invertible']) return this.catalog['invertible']

            let scale = this.get.normal_order()
            let i_scale = this.parent.scale(this.get.inversion()).get.normal_order()
            let result = true
            if (this.parent.is.same(scale, i_scale)) result = false
            if (cache) this.catalog['invertible'] = result
            return result
        },

        /**&lt;p>Returns true if the scale is maximally even&lt;/p>
         * @returns {Boolean}
         * @memberOf Scale#is
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.is.maximally_even() //returns true
         * @see Clough, J., et al. (1999). "Scales, sets, and interval cycles: A taxonomy." Music Theory Spectrum 21(1): 74-104.
         * */
        maximally_even: () => {
            let map = {}
            for (let i = 0; i &lt; this.count.pitches(); i++) {
                let gen = this.get.generic_intervals(i)
                gen.forEach(interval=>(map[interval.generic])?map[interval.generic].push(interval.specific):map[interval.generic]=[interval.specific])
            }
            for (let i = 0; i &lt; this.count.pitches(); i++) {
                if(map[String(i)].length>2) return false
                if(map[String(i)].length==2) {
                    if(Math.abs(map[String(i)][0]-map[String(i)][1]) != 1) return false
                }
            }
            return true
        },

        /**&lt;p>Returns true if the scale has the Myhill property&lt;/p>
         * @returns {Boolean}
         * @memberOf Scale#is
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major scale
         * scale.is.myhill_property() //returns true
         * @see Scale#get.myhill_property
         * @see Clough, J., et al. (1999). "Scales, sets, and interval cycles: A taxonomy." Music Theory Spectrum 21(1): 74-104.
         * */
        myhill_property: () => {
            return this.get.myhill_property()
        },

        /**&lt;p>Checks if the scale is a mode / rotation of another scale&lt;/p>
         *
         * &lt;p>To check again multiple scale see [Scale.is.one_of]{@link Scale#is.one_of}&lt;/p>
         * @param {Array&lt;Number>} scales - a collection of scales (or necklaces)
         * @returns {Boolean}
         * @memberOf Scale#is
         * @see Scale#is.one_of
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major
         * scale.is.mode_of([0,2,3,5,7,9,10]) //returns true
         * */
        mode_of: (scale) => {
            let modes = this.parent.get.modes(scale)
            return (this.parent.is.element_of(this.pitches, modes))
        },

        /**&lt;p>Checks if the scale is a mode of limited transpositions&lt;/p>
         * @returns {Boolean}
         * @memberOf Scale#is
         * @see Scale#is.MOLT
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,6,8,10]) //whole-tones
         * scale.is.MOLT() //returns true
         * */
        MOLT: () => {
            return this.count.transpositions()&lt;this.edo
        },

        /**
         * &lt;p>Returns True if the scale is in normal order and False if it isn't&lt;/p>
         * @returns {Boolean}
         * @memberOf Scale#is
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major
         * scale.is.normal_order() //returns false
         * */
        normal_order: () => {
            return this.parent.is.same(this.pitches, this.get.normal_order())
        },

        /**&lt;p>Checks if the scale (as a whole!) is one of the scales given in a list of scales (or in one of their modes)&lt;/p>
         * @param {Array&lt;Array&lt;Number>>} scales - a collection of scales (more accurately, necklaces)
         * @returns {Boolean}
         * @memberOf Scale#is
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major
         * scale.is.one_of([[0,2,3,5,7,9,10],[0,1,2,3,4,5,6,7,8,9]]) //returns true*/
        one_of: (scales) => {
            /**/
            let scale = this.pitches
            let all_modes = scales.map((item) => this.parent.get.modes(item))
            all_modes = all_modes.flat(1)
            if (this.parent.is.element_of(scale, all_modes)) return true
            return false
        },

        /**
         * &lt;p>Returns True if the scale is in prime form and False if it isn't.&lt;/p>
         * (Notice, the prime form calculation conforms to Rahn's prime form rather than Forte's)
         * @returns {Boolean}
         * @memberOf Scale#is
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major
         * scale.is.prime_form() //returns false
         * */
        prime_form: () => {
            return this.parent.is.same(this.pitches, this.get.prime_form())
        },

        /**&lt;p>Returns true if the scale is a subset of one of multiple scales provided.&lt;/p>
         * @param {Array&lt;Number>|Array&lt;Array&lt;Number>>} scales - another scale, or a collection of scales
         * @param {Boolean} [include_modes=true] - When true, the function will return true also when the scale is a subset of one of the modes of the scales in question. When false, the scale must appear verbatim to return true
         * @returns {Boolean}
         * @memberOf Scale#is
         *
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //major
         * scale.is.subset([[0,2,4,5],[7,9,11]]) //returns false*/
        subset: (scales) => {

            const is_subset_of_one = function (scale1, scale2) {
                for (let note of scale1) {
                    if (scale2.indexOf(note) == -1) return false
                }
                return true
            }
            if (!Array.isArray(scales[0])) scales = [scales]
            scales = scales.map((scale) => {
                return this.parent.scale(scale).get.modes()
            }).flat()
            for (let scale of scales) {
                if (is_subset_of_one(this.pitches, scale)) return true
            }
            return false
        },
    }

    /**A collection of functions that convert data from one representation to another
     * @namespace*/
    to = {

        /**
         * Returns the scale's representation in cents [0,100,300, etc.]
         * @returns {Array&lt;Number>}
         * @memberOf Scale#to
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //new Scale object
         * scale.to.cents() //returns [0,200,400,500,700,900,1100]
         * */
        cents: () => {
            return this.pitches.map((note) => note * this.parent.cents_per_step)
        },

        /**
         * Instead of PCs, this returns the scale represented by intervals (steps between notes)
         * @param {Boolean} [cache=false] - when true, the result is cached for future retrieval
         * @returns {Array&lt;Number>}
         * @memberOf Scale#to
         * @example
         * let edo = new EDO(12) //define context
         * let scale = edo.scale([0,2,4,5,7,9,11]) //new Scale object
         * scale.to.steps() //returns [2,2,1,2,2,2,1]
         * */
        steps: (cache = false) => {

            if (this.catalog['steps']) return this.catalog['steps']

            let intervals = this.parent.convert.to_steps(this.pitches.concat([this.edo]), cache = false)
            if (cache) this.catalog['steps'] = intervals
            return intervals
        }
    }

    /**&lt;p>A collection of functions that make visual representations&lt;/p>
     * &lt;p>Note: Scale.show can only be used client-side&lt;/p>
     * @namespace Scale#show
     * */
    show = {
        /**
         * &lt;p>Makes a fractal tree corresponding to the scale with branches diverging by given step sizes.&lt;/p>
         * &lt;img src='img/fractal_tree.png'>
         * @param  {String} container_id - The ID of a DOM element in which the tree will be shown.
         * @param  {Number} [length=200] - The length (or height) or the tree's "trunk".
         * @param  {Number} [angle_span=90] - the angle between branches.
         * @param  {Array&lt;Number>} [intervals=[-1,1]] - Each interval represents the number of scale degrees away from the current node.
         * @param  {Number} [iterations=5] - The number of sub-branches on the tree
         * @param  {Number} [length_mul=0.7] - The factor by which every new sub-branch's length is to its parent.

         * @example
         * &lt;script src="edo.js">&lt;/script>
         * &lt;script src="raphael.min.js">&lt;/script>
         * &lt;div id="container" style="width:900px;height:600px; margin:0 auto;">&lt;/div>
         * &lt;script>
         *  let edo = new EDO()
         *  edo.show.interval_fractal_tree(container_id)
         * &lt;/script>


         * @see /demos/fractal_tree.html
         * @memberOf Scale#show*/
        interval_fractal_tree: (container_id, length = 200, angle_span = 90, intervals = [-1, 1], iterations = 5, length_mul = 0.7) => {
            this.parent.show.interval_fractal_tree(container_id, length, angle_span, this.pitches, intervals, iterations, length_mul)
        },

        /**
         * &lt;p>Graphs the scale's necklace.&lt;/p>
         ** &lt;img src='img/Necklace.png'>
         * @param  {String} container_id - The ID of a DOM element in which the contour will be shown.
         * @param  {Boolean} [replace=false] - When false, any time the function is called a new contour will be appended to the object. When true, it will replace the contents of the container.
         * @param  {Number|Array&lt;Number,Number>} [radius] - Radius (in px) of the ring. When no values are passed, the ring will take the size of the container.
         *
         * @example
         * &lt;script src="edo.js">&lt;/script>
         * &lt;script src="raphael.min.js">&lt;/script>
         * &lt;div id="container" style="width:900px;height:600px; margin:0 auto;">&lt;/div>
         * &lt;script>
         *  let edo = new EDO()
         *  let scale = edo.scale([0,2,4,5,7,9,11])
         *  scale.show.necklace('container')
         * &lt;/script>
         * @see /demos/necklace.html
         * @memberOf Scale#show*/
        necklace: (container_id, replace = true, radius = 600) => {
            return this.parent.show.necklace(container_id, this.pitches, replace, radius)
        }
    }


    /**
     * Returns a Scale object with pitches corresponding to the nth mode of the original scale
     * @param {Number} n - Mode number to be returned (starting at 0)
     * @returns {Scale}
     * */
    mode(n = 0) {
        let modes = this.get.modes()
        let mode = modes[this.parent.mod(n, modes.length)]
        return new Scale(mode, this.parent)
    }

    /**
     * Returns a Scale object with pitches corresponding to the inversion of the original scale.
     * @returns {Scale}
     * */
    invert() {
        let pitches = this.get.inversion()
        return new Scale(pitches, this.parent)
    }

    /**
     * Returns a Scale object with pitches corresponding to the normal order of the original scale.
     * @returns {Scale}
     * */
    normal() {
        let pitches = this.get.normal_order()
        return new Scale(pitches, this.parent)
    }

    /**
     * Returns a Scale object with pitches corresponding to the prime form of the original scale.
     * @returns {Scale}
     * */
    prime() {
        let pitches = this.get.prime_form()
        return new Scale(pitches, this.parent)
    }

    /**
     * Returns a Scale object with pitches corresponding to the complement of the original scale in the current EDO.
     * @returns {Scale}
     * */
    complement() {
        let pitches = this.get.complement(true)
        return new Scale(pitches, this.parent)
    }


}

/** &lt;p>Class for rhythm / tempo manipulation&lt;/p>
 * &lt;p>(This is not really part of a "tuning system" per se, but a need to interact with rhythm seems fitting for such a library).&lt;/p> */
class Time {
    constructor() {

    }

    /**A collection of functions manipulates an input
     * @namespace Time#get*/
    get = {
        /** Get all unique subdivisions of a given &lt;code>num_of_beats&lt;/code>, without their rotations.
         *
         * @param  {Number} num_of_beats - The amount of beats to subdivide
         * @param  {Number} minimal_subdivision - The smallest allowed subdivision (the returned result will not include subdivisions smaller than this value)
         * @param  {Number} maximal_subdivision - The largest allowed subdivision (the returned result will not include subdivisions larger than this value)
         * @returns {Array&lt;Array&lt;Number>>} All possible subdivisions.
         * @memberOf Time#get
         * @example
         * let time = new Time()
         * time.get.subdivisions(12,2,3)
         * //returns
         * [
         *  [ 2, 2, 2, 2, 2, 2 ],
         *  [ 2, 2, 2, 3, 3 ],
         *  [ 2, 2, 3, 2, 3 ],
         *  [ 3, 3, 3, 3 ]
         * ]*/
        subdivisions: (num_of_beats,minimal_subdivision = 1, maximal_subdivision = num_of_beats) => {
            let edo = new EDO(num_of_beats)
            let scales = edo.get.scales(minimal_subdivision,maximal_subdivision).map(scale=>scale.to.steps())
            return scales
        },

        /** returns the ratios to a &lt;code>max_ratio&lt;/code> from a given &lt;code>base_ratio&lt;/code>.
         *
         * @param  {Number} base_ratio - The number to be used as a baseline (=:1)
         * @param  {Number} max_ratio - The maximal ratio to be returned
         * @returns {Object} A list of ratios given the &lt;code>base_ratio&lt;/code>
         * @memberOf Time#get
         * @example
         * let time = new Time()
         * time.get.ratios(110,3)
         * //returns { '1': 110, '2': 220, '3': 330, '1/2': 55, '1/3': 36.666666666666664 } */
        ratios: (base_ratio=1,max_ratio=10) =>{
            let beats = {}
            for (let i = 1; i &lt;=max_ratio ; i++) {

                beats[i]=base_ratio*i
                if(i==1) continue
                beats["1/"+String(i)] = base_ratio/i
            }
            return beats
        },

        /** Multiplies each element in the &lt;code>base&lt;/code>with the entire &lt;code>base&lt;/code>, &lt;code>iteration&lt;/code> times.
         *
         * @param  {Number} base - some rhythmic cell
         * @param  {Number} iteration - The amount of times to apply the algorithms to the cell
         * @returns {Array&lt;Number>} The fractal
         * @memberOf Time#get
         * @example
         * let time = new Time()
         * time.get.fractal([2,4,3],1)
         * //returns [2, 4, 3]
         *
         * time.get.fractal([2,4,3],2)
         * //returns [4, 8,  6, 8, 16, 12, 6, 12, 9]
         *
         * time.get.fractal([2,4,3],3)
         * //returns
         * [8, 16, 12, 16, 32, 24, 12, 24,
         *  18, 16, 32, 24, 32, 64, 48, 24,
         *  48, 36, 12, 24, 18, 24, 48, 36,
         *  18, 36, 27]*/
        fractal: (base=[2,2,3],iteration=1) =>{
            const do_it = function (arr,it) {
                if(it&lt;=1) return arr
                else {
                    it--
                    arr = arr.map(el=>{
                        return base.map(b=>{
                            return b*el
                        })
                    }).flat()
                    return do_it([...arr],it)
                }

            }
            return do_it([...base],iteration)


        },

        /** Returns an array of arrays representing different sized beats coalescing with the pattern.
         *
         * @param  {Array&lt;Number>} array - A beat pattern
         * @returns {Array&lt;Number>} An ordered array showing as tuples [beat_size,number_of_alignments]
         * @memberOf Time#get
         * @example
         * let time = new Time()
         * time.get.beat([2,4,4,4,4,4,4,4])
         * //returns
         * [
         *  [ 2, 8 ], //a beat of size 2 aligns with the pattern 8 times (every element in the pattern falls on a beat)
         *  [ 4, 7 ], //a beat of size 4 aligns with the pattern 7 times (in this case, all the elements align if the first element is seen as a pickup)
         *  [ 3, 3 ] //a beat of size 3 aligns with the pattern 3 times
         * ]
         *
         * */
        beat: (array) =>{
            let beats = []
            let min = Math.min(...array)
            let max = Math.max(...array)
            let edo = new EDO()
            for (let i = min; i &lt;= max; i++) {
                let max_oc = 0
                let intervals = edo.convert.intervals_to_pitches(array).slice(1)
                for (let j = 0; j &lt; array.length; j++) {
                    let len = intervals.filter(el=>Math.round(el/i)==el/i).length
                    if(len>max_oc) max_oc=len
                    intervals = edo.convert.intervals_to_pitches(array.slice(j)).slice(1)
                }
                if(max_oc!=0) beats.push([i,max_oc])

            }
            beats = beats.sort((a,b)=>b[1]-a[1])
            return beats

        },

        /** Returns the rhythmic motives as they appear verbatim, from most common to least common.
         * @memberOf Time#get
         * @param {Array&lt;Number>} pattern - The pattern to be repeated
         * @param {Number} times - The number of times to repeat
         * @returns The pattern repeating
         * @example
         * let time = new Time()
         * time.get.repeated([2,1,1],3) // returns  [2,1,1,2,1,1,2,1,1]
         */
        repeated: (pattern,times=2)=>Array.from(new Array(times), () => pattern).flat(),

        /** Returns the rhythmic motives as they appear verbatim, from most common to least common.
         *
         * @param  {Array&lt;Number>} array - A beat pattern
         * @param  {Number} [maximal_length=8] - The maximal motive length to be searched
         * @param  {Boolean} [show_singulars=false] - Whether to show "motives" that appear only once.
         * @returns {Array&lt;Object>} motive:[an array with the motive], incidence: the number of times that motive appears in the input
         * @memberOf Time#get
         * @example
         * let time = new Time()
         * time.get.motives([2,2,4,2,2,4,3,3,6,3])
         * //returns
         * [
         *    { motive: [ 2, 2, 4 ], incidence: 2 }
         *    { motive: [ 2, 2 ], incidence: 2 },
         *    { motive: [ 2, 4 ], incidence: 2 }
         * ]
         * @see Time#get.relational_motives
         * */
        motives: (array,maximal_length=8,show_singulars=false) => {
            let edo = new EDO()
            return edo.get.motives(array,false,false,maximal_length)
                .filter(el=>(el.incidence>1 || show_singulars) &amp;&amp; el.motive.length>1)
        },

        /** Returns the rhythmic motives in terms of relationships (rather than verbatim durations like in [Time.get.motives]{@link Time#get.motives} ), from most common to least common.
         *
         * @param  {Array&lt;Number>} array - A beat pattern
         * @param  {Number} [maximal_length=8] - The maximal motive length to be searched
         * @param  {Boolean} [show_singulars=false] - Whether to show "motives" that appear only once.
         * @returns {Array&lt;Object>} motive:[an array with the motive], incidence: the number of times that motive appears in the input
         * @memberOf Time#get
         * @example
         * let time = new Time()
         * time.get.relational_motives([2,2,4,2,2,4,3,3,6,3])
         * //returns
         * [
         *  { motive: [ 1, 2 ], incidence: 3, position: [ 0, 3, 6 ] }, //motive of duration=[same,double] appears 3 times, at positions 0, 3, and 6 of the original input
         *  { motive: [ 1, 2, 0.5 ], incidence: 2, position: [ 0, 6 ] }, //motive of duration=[same,double,half] appears 2 times, at positions 0, and 6 of the original input
         *  { motive: [ 2, 0.5 ], incidence: 2, position: [ 1, 7 ] } //motive of duration=[double,half] appears 2 times, at positions 1, and 7 of the original input
         * ]
         * @see Time#get.motives
         *
         * */
        relational_motives: (array,maximal_length=8,show_singular = false)=> {
            let ratios = this.convert.beats_to_ratios(array)
            let motives = this.get.motives(ratios,maximal_length,show_singular)
            let edo = new EDO()
            motives = motives.map(motive=>{
                let position = edo.get.subset_indices(motive.motive,ratios,false).map(i=>i[0])
                motive.position = position
                return motive
            })
            return motives
        },

        /** Returns the position of every subdivision of a given beat(s).
         *
         * @param  {Array&lt;Number>} arrays - Any number of beat patterns separated by commas.
         * @returns {Array&lt;String>} The flushing out of each pattern into its subdivisional representation.
         * @memberOf Time#get
         * @example
         * let time = new Time()
         * let sub = time.get.subdivisions(12) //get all subdivisions of 12 beats
         * let rhythms = time.get.explicit(...sub)
         * rhythms.forEach(r=>console.log(r))
         * //returns
         *  "2  .  2  .  2  .  2  .  2  .  2  . "
         *  "2  .  2  .  2  .  3  .  .  3  .  . "
         *  "2  .  2  .  3  .  .  2  .  3  .  . "
         *  "3  .  .  3  .  .  3  .  .  3  .  . "
         *
         * */
        explicit: (...arrays) =>{
            arrays = arrays.map(arr=>{
                arr = arr.map(el=>{
                    el = [String(el),...Array.from(Array(el-1).fill("."))]
                    el = el.map(e=>(e.length==1)?e+" ":e)
                    return el
                })
                return arr.flat().join(" ")
            })
            return arrays
        },


        /** Returns a binary representation of ONE complete cycle of all given beat patterns
         *
         * @param  {...Array&lt;Number>|Number} patterns - beat patterns as arrays or integers seperated by commas.
         * @returns {Array&lt;Array&lt;Number>>} Returns a binary representation of ONE complete cycle of all given beat patterns
         * @memberOf Time#get
         * @example
         * let time = new Time()
         * time.get.counterpoint_cycle([1,1,2],3)
         * //returns
         * [1,1,1,0,1,1,1,0,1,1,1,0]
         * [1,0,0,1,0,0,1,0,0,1,0,0]
         *
         * time.get.counterpoint_cycle([1,2,1,3,1],[3,1])
         * //returns
         * [1,1,0,1,1,0,0,1]
         * [1,0,0,1,1,0,0,1]
         * */
        counterpoint_cycle: (...patterns) => {
            patterns = patterns.map(p=>(Array.isArray(p))?p:[p]).map(p=>this.convert.binary(p))
            let lengths = patterns.map(p=>p.length)

            let product = lengths.reduce((a,e)=>a*e,1)

            // let gcd = GCD(...lengths)
            let divisible = false
            product=Math.max(...lengths)
            while(!divisible) {
                divisible = Boolean(lengths.map(l=>Number(Number.isInteger(product/l))).reduce((ar,el)=>ar*el,1))
                if(divisible) break
                product++
            }
            patterns = patterns.map(p=>this.get.repeated(p,product/p.length))
            return patterns

        },
    }

    /**A collection of functions that resizes the elements of an array or the array itself
     * @namespace Time#resize*/
    resize = {
        /** Returns a given array with its elements "resized" by a given multiplier.
         *
         * @param  {Array&lt;Number>} input - The original array.
         * @param  {Number} [by=1] - The number by which to resize the elements
         * @param  {false|"up"|"down"|"closest"} [round=false] - When not false, this determines how the elements are to be rounded when not integers
         * @param  {Boolean} [remove_0s=false] - When true, 0s will be completely erased from the array.
         * @returns {Array&lt;Number>} The resized input
         * @memberOf Time#resize
         * @example
         * let time = new Time()
         * time.resize.by_product([2,4,1,3],0.45) // returns [ 0.9, 1.8, 0.45, 1.35 ]
         * time.resize.by_product([2,4,1,3],0.45,"up") // returns [ 1, 2, 1, 2 ]
         * time.resize.by_product([2,4,1,3],0.45,"closest",false) // returns [ 1, 2, 0, 1 ]
         * time.resize.by_product([2,4,1,3],0.45,"closest",true) // returns [ 1, 2, 1 ]
         * */
        by_product: (input,by=1,round=false,remove_0s=false) =>{
            input = input.map(el=>el*by).map(el=>{
                switch(round) {
                    case "closest": return Math.round(el)
                    case "down":return Math.floor(el)
                    case "up":return Math.ceil(el)
                    case false: return el
                }
            })
            if(remove_0s) input = input.filter(el=>el!=0)

            return input
        },

        /** Returns a given array with its elements "resized" by an added sum.
         *
         * @param  {Array&lt;Number>} input - The original array.
         * @param  {Number} [by=1] - The number by which to resize the elements
         * @param  {Boolean} [remove_0s=false] - When true, 0s will be completely erased from the array.
         * @returns {Array&lt;Number>} The resized input
         * @memberOf Time#resize
         * @example
         * let time = new Time()
         * time.resize.by_sum([2,4,1,3],-1,false) //[ 1, 3, 0, 2 ]
         * time.resize.by_sum([2,4,1,3],-1,true) //[ 1, 3, 2 ]
         * */
        by_sum: (input,by,remove_0s)=>(remove_0s)?input.map(d=>d+by).filter(el=>el!=0): input.map(d=>d+by),

    }

    /**A collection of functions that convert an input into other equivalent representations
     * @namespace Time#convert*/
    convert = {
        binary: (pattern) =>{
            return pattern.map(e=>{
                if(e==0) return [0]
                e = Array.from([...new Array(e).fill(0)])
                e[0]=1
                return e
            }).flat()

        },

        /** Returns the new tempo, if the number of &lt;code>beats_in_old_tempo&lt;/code> occupies the same time as the number of &lt;code>beats_in_new_tempo&lt;/code>, and the old tempo being &lt;code>old_tempo&lt;/code>.
         *
         * @param  {Number} beats_in_old_tempo - The number of beats in the old tempo
         * @param  {Number} beats_in_new_tempo - The equivalent number of beats in the new tempo
         * @param  {Number} old_tempo - The old tempo
         * @returns {Number} The new tempo
         * @memberOf Time#convert
         * @example
         * let time = new Time()
         * time.convert.beats_to_tempo(4,6,60) // returns 90 */
        beats_to_tempo: (beats_in_old_tempo=4,beats_in_new_tempo=6,old_tempo=60) =>(beats_in_new_tempo/beats_in_old_tempo)*old_tempo,

        /** Returns the new tempo, if the number of &lt;code>beats_in_old_tempo&lt;/code> occupies the same time as the number of &lt;code>beats_in_new_tempo&lt;/code>, and the old tempo being &lt;code>old_tempo&lt;/code>.
         *
         * @param  {Array&lt;Number>} array - An array of beats
         * @param  {Boolean} [relate_only_to_first=false] - When true, all ratios will be calculated based on the first value. Otherwised, they'll be calculated based on their relationship with the previous beat.
         * @returns {Array&lt;Number>} An array with the ratios
         * @memberOf Time#convert
         * @example
         * let time = new Time()
         * time.convert.beats_to_ratios([2,3,2,1]) // [ 1.5, 0.6666666666666666, 0.5 ] */
        beats_to_ratios: (array,relate_only_to_first=false)=>array.map((el,i,arr)=>(i>0)?arr[i]/arr[(relate_only_to_first)?0:i-1]:1).slice(1),




        /** Returns an array of beats as expressed in their duration in milliseconds
         *
         * @param  {Array&lt;Number>} beats - An array of beats
         * @param  {Number} [bpm=60] - The tempo
         * @param  {Number} [units_per_beat=1] - The number of units each beat subdivides to.
         * @returns {Array&lt;Number>} An array with the pattern in milliseconds
         * @memberOf Time#convert
         * @example
         * let time = new Time()
         * time.convert.beats_to_msec([2,3,2,1],120,2) // [ 500, 750, 500, 250 ] */
        beats_to_msec: (beats,bpm=60,units_per_beat=1) =>beats.map(b=>((60/bpm*1000)*b)/units_per_beat)

    }
}

/**
 * For server side*/
try {
    module.exports = {
        EDO: EDO,
        Scale: Scale,
        Time: Time
    }
}
    /**
     * For client-side*/ catch (e) {
    1 + 1
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
  
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script>
var list = [{"link":"<a href=\"EDO.html\">EDO</a>"},{"title":"EDO#scale","link":"<a href=\"EDO.html#scale\">EDO &rtrif; scale</a>"},{"link":"<a href=\"Scale.html\">Scale</a>"},{"title":"Scale#complement","link":"<a href=\"Scale.html#complement\">Scale &rtrif; complement</a>"},{"title":"Scale#invert","link":"<a href=\"Scale.html#invert\">Scale &rtrif; invert</a>"},{"title":"Scale#mode","link":"<a href=\"Scale.html#mode\">Scale &rtrif; mode</a>"},{"title":"Scale#normal","link":"<a href=\"Scale.html#normal\">Scale &rtrif; normal</a>"},{"title":"Scale#prime","link":"<a href=\"Scale.html#prime\">Scale &rtrif; prime</a>"},{"link":"<a href=\"Time.html\">Time</a>"},{"link":"<a href=\"EDO_convert.html\">convert</a>"},{"title":"EDO#convert.cents_to_ratio","link":"<a href=\"EDO_convert.html#.cents_to_ratio\">EDO &rtrif; convert.cents_to_ratio</a>"},{"title":"EDO#convert.interval_to_cents","link":"<a href=\"EDO_convert.html#.interval_to_cents\">EDO &rtrif; convert.interval_to_cents</a>"},{"title":"EDO#convert.interval_to_ratio","link":"<a href=\"EDO_convert.html#.interval_to_ratio\">EDO &rtrif; convert.interval_to_ratio</a>"},{"title":"EDO#convert.intervals_to_pitches","link":"<a href=\"EDO_convert.html#.intervals_to_pitches\">EDO &rtrif; convert.intervals_to_pitches</a>"},{"title":"EDO#convert.intervals_to_scale","link":"<a href=\"EDO_convert.html#.intervals_to_scale\">EDO &rtrif; convert.intervals_to_scale</a>"},{"title":"EDO#convert.midi_to_freq","link":"<a href=\"EDO_convert.html#.midi_to_freq\">EDO &rtrif; convert.midi_to_freq</a>"},{"title":"EDO#convert.midi_to_intervals","link":"<a href=\"EDO_convert.html#.midi_to_intervals\">EDO &rtrif; convert.midi_to_intervals</a>"},{"title":"EDO#convert.midi_to_name","link":"<a href=\"EDO_convert.html#.midi_to_name\">EDO &rtrif; convert.midi_to_name</a>"},{"title":"EDO#convert.name_to_scale","link":"<a href=\"EDO_convert.html#.name_to_scale\">EDO &rtrif; convert.name_to_scale</a>"},{"title":"EDO#convert.pc_to_name","link":"<a href=\"EDO_convert.html#.pc_to_name\">EDO &rtrif; convert.pc_to_name</a>"},{"title":"EDO#convert.pitches_to_PCs","link":"<a href=\"EDO_convert.html#.pitches_to_PCs\">EDO &rtrif; convert.pitches_to_PCs</a>"},{"title":"EDO#convert.ratio_to_cents","link":"<a href=\"EDO_convert.html#.ratio_to_cents\">EDO &rtrif; convert.ratio_to_cents</a>"},{"title":"EDO#convert.ratio_to_interval","link":"<a href=\"EDO_convert.html#.ratio_to_interval\">EDO &rtrif; convert.ratio_to_interval</a>"},{"title":"EDO#convert.to_steps","link":"<a href=\"EDO_convert.html#.to_steps\">EDO &rtrif; convert.to_steps</a>"},{"link":"<a href=\"EDO_count.html\">count</a>"},{"title":"EDO#count.common_tones","link":"<a href=\"EDO_count.html#.common_tones\">EDO &rtrif; count.common_tones</a>"},{"title":"EDO#count.differences","link":"<a href=\"EDO_count.html#.differences\">EDO &rtrif; count.differences</a>"},{"title":"EDO#count.pitches","link":"<a href=\"EDO_count.html#.pitches\">EDO &rtrif; count.pitches</a>"},{"link":"<a href=\"EDO_export.html\">export</a>"},{"title":"EDO#export.png","link":"<a href=\"EDO_export.html#.png\">EDO &rtrif; export.png</a>"},{"link":"<a href=\"EDO_get.html\">get</a>"},{"title":"EDO#get.angle","link":"<a href=\"EDO_get.html#.angle\">EDO &rtrif; get.angle</a>"},{"title":"EDO#get.combinations","link":"<a href=\"EDO_get.html#.combinations\">EDO &rtrif; get.combinations</a>"},{"title":"EDO#get.complementary_interval","link":"<a href=\"EDO_get.html#.complementary_interval\">EDO &rtrif; get.complementary_interval</a>"},{"title":"EDO#get.complementary_set","link":"<a href=\"EDO_get.html#.complementary_set\">EDO &rtrif; get.complementary_set</a>"},{"title":"EDO#get.contour","link":"<a href=\"EDO_get.html#.contour\">EDO &rtrif; get.contour</a>"},{"title":"EDO#get.contour_motives","link":"<a href=\"EDO_get.html#.contour_motives\">EDO &rtrif; get.contour_motives</a>"},{"title":"EDO#get.coordinates","link":"<a href=\"EDO_get.html#.coordinates\">EDO &rtrif; get.coordinates</a>"},{"title":"EDO#get.fill_partial_harp_pedaling","link":"<a href=\"EDO_get.html#.fill_partial_harp_pedaling\">EDO &rtrif; get.fill_partial_harp_pedaling</a>"},{"title":"EDO#get.generated_scale","link":"<a href=\"EDO_get.html#.generated_scale\">EDO &rtrif; get.generated_scale</a>"},{"title":"EDO#get.generators","link":"<a href=\"EDO_get.html#.generators\">EDO &rtrif; get.generators</a>"},{"title":"EDO#get.harmonic_progression","link":"<a href=\"EDO_get.html#.harmonic_progression\">EDO &rtrif; get.harmonic_progression</a>"},{"title":"EDO#get.harmonized_melody","link":"<a href=\"EDO_get.html#.harmonized_melody\">EDO &rtrif; get.harmonized_melody</a>"},{"title":"EDO#get.harp_pedals_to_pitches","link":"<a href=\"EDO_get.html#.harp_pedals_to_pitches\">EDO &rtrif; get.harp_pedals_to_pitches</a>"},{"title":"EDO#get.harp_position_of_quality","link":"<a href=\"EDO_get.html#.harp_position_of_quality\">EDO &rtrif; get.harp_position_of_quality</a>"},{"title":"EDO#get.intersection","link":"<a href=\"EDO_get.html#.intersection\">EDO &rtrif; get.intersection</a>"},{"title":"EDO#get.interval_stack","link":"<a href=\"EDO_get.html#.interval_stack\">EDO &rtrif; get.interval_stack</a>"},{"title":"EDO#get.interval_traversed","link":"<a href=\"EDO_get.html#.interval_traversed\">EDO &rtrif; get.interval_traversed</a>"},{"title":"EDO#get.inversion","link":"<a href=\"EDO_get.html#.inversion\">EDO &rtrif; get.inversion</a>"},{"title":"EDO#get.lattice","link":"<a href=\"EDO_get.html#.lattice\">EDO &rtrif; get.lattice</a>"},{"title":"EDO#get.levenshtein","link":"<a href=\"EDO_get.html#.levenshtein\">EDO &rtrif; get.levenshtein</a>"},{"title":"EDO#get.maximal_carey_coherence_failures","link":"<a href=\"EDO_get.html#.maximal_carey_coherence_failures\">EDO &rtrif; get.maximal_carey_coherence_failures</a>"},{"title":"EDO#get.maximal_rahn_difference","link":"<a href=\"EDO_get.html#.maximal_rahn_difference\">EDO &rtrif; get.maximal_rahn_difference</a>"},{"title":"EDO#get.minimal_voice_leading","link":"<a href=\"EDO_get.html#.minimal_voice_leading\">EDO &rtrif; get.minimal_voice_leading</a>"},{"title":"EDO#get.modes","link":"<a href=\"EDO_get.html#.modes\">EDO &rtrif; get.modes</a>"},{"title":"EDO#get.motives","link":"<a href=\"EDO_get.html#.motives\">EDO &rtrif; get.motives</a>"},{"title":"EDO#get.necklace","link":"<a href=\"EDO_get.html#.necklace\">EDO &rtrif; get.necklace</a>"},{"title":"EDO#get.new_pitches","link":"<a href=\"EDO_get.html#.new_pitches\">EDO &rtrif; get.new_pitches</a>"},{"title":"EDO#get.ngrams","link":"<a href=\"EDO_get.html#.ngrams\">EDO &rtrif; get.ngrams</a>"},{"title":"EDO#get.normal_order","link":"<a href=\"EDO_get.html#.normal_order\">EDO &rtrif; get.normal_order</a>"},{"title":"EDO#get.partitioned_subsets","link":"<a href=\"EDO_get.html#.partitioned_subsets\">EDO &rtrif; get.partitioned_subsets</a>"},{"title":"EDO#get.path_n_steps","link":"<a href=\"EDO_get.html#.path_n_steps\">EDO &rtrif; get.path_n_steps</a>"},{"title":"EDO#get.path_on_tree","link":"<a href=\"EDO_get.html#.path_on_tree\">EDO &rtrif; get.path_on_tree</a>"},{"title":"EDO#get.permutations","link":"<a href=\"EDO_get.html#.permutations\">EDO &rtrif; get.permutations</a>"},{"title":"EDO#get.pitch_distribution","link":"<a href=\"EDO_get.html#.pitch_distribution\">EDO &rtrif; get.pitch_distribution</a>"},{"title":"EDO#get.pitch_fields","link":"<a href=\"EDO_get.html#.pitch_fields\">EDO &rtrif; get.pitch_fields</a>"},{"title":"EDO#get.random_melody","link":"<a href=\"EDO_get.html#.random_melody\">EDO &rtrif; get.random_melody</a>"},{"title":"EDO#get.random_melody_from_contour","link":"<a href=\"EDO_get.html#.random_melody_from_contour\">EDO &rtrif; get.random_melody_from_contour</a>"},{"title":"EDO#get.random_melody_from_distribution","link":"<a href=\"EDO_get.html#.random_melody_from_distribution\">EDO &rtrif; get.random_melody_from_distribution</a>"},{"title":"EDO#get.random_melody_from_ngram","link":"<a href=\"EDO_get.html#.random_melody_from_ngram\">EDO &rtrif; get.random_melody_from_ngram</a>"},{"title":"EDO#get.ratio_approximation","link":"<a href=\"EDO_get.html#.ratio_approximation\">EDO &rtrif; get.ratio_approximation</a>"},{"title":"EDO#get.retrograde","link":"<a href=\"EDO_get.html#.retrograde\">EDO &rtrif; get.retrograde</a>"},{"title":"EDO#get.rotated","link":"<a href=\"EDO_get.html#.rotated\">EDO &rtrif; get.rotated</a>"},{"title":"EDO#get.rotations","link":"<a href=\"EDO_get.html#.rotations\">EDO &rtrif; get.rotations</a>"},{"title":"EDO#get.scalar_melodies","link":"<a href=\"EDO_get.html#.scalar_melodies\">EDO &rtrif; get.scalar_melodies</a>"},{"title":"EDO#get.scales","link":"<a href=\"EDO_get.html#.scales\">EDO &rtrif; get.scales</a>"},{"title":"EDO#get.shortest_path","link":"<a href=\"EDO_get.html#.shortest_path\">EDO &rtrif; get.shortest_path</a>"},{"title":"EDO#get.simple_ratios","link":"<a href=\"EDO_get.html#.simple_ratios\">EDO &rtrif; get.simple_ratios</a>"},{"title":"EDO#get.stacked","link":"<a href=\"EDO_get.html#.stacked\">EDO &rtrif; get.stacked</a>"},{"title":"EDO#get.starting_at","link":"<a href=\"EDO_get.html#.starting_at\">EDO &rtrif; get.starting_at</a>"},{"title":"EDO#get.subset_indices","link":"<a href=\"EDO_get.html#.subset_indices\">EDO &rtrif; get.subset_indices</a>"},{"title":"EDO#get.subsets","link":"<a href=\"EDO_get.html#.subsets\">EDO &rtrif; get.subsets</a>"},{"title":"EDO#get.transposition","link":"<a href=\"EDO_get.html#.transposition\">EDO &rtrif; get.transposition</a>"},{"title":"EDO#get.union","link":"<a href=\"EDO_get.html#.union\">EDO &rtrif; get.union</a>"},{"title":"EDO#get.unique_elements","link":"<a href=\"EDO_get.html#.unique_elements\">EDO &rtrif; get.unique_elements</a>"},{"title":"EDO#get.well_formed_scale","link":"<a href=\"EDO_get.html#.well_formed_scale\">EDO &rtrif; get.well_formed_scale</a>"},{"title":"EDO#get.without","link":"<a href=\"EDO_get.html#.without\">EDO &rtrif; get.without</a>"},{"title":"EDO#get.without_chromatic_notes","link":"<a href=\"EDO_get.html#.without_chromatic_notes\">EDO &rtrif; get.without_chromatic_notes</a>"},{"link":"<a href=\"EDO_is.html\">is</a>"},{"title":"EDO#is.element_of","link":"<a href=\"EDO_is.html#.element_of\">EDO &rtrif; is.element_of</a>"},{"title":"EDO#is.rotation","link":"<a href=\"EDO_is.html#.rotation\">EDO &rtrif; is.rotation</a>"},{"title":"EDO#is.same","link":"<a href=\"EDO_is.html#.same\">EDO &rtrif; is.same</a>"},{"title":"EDO#is.subset","link":"<a href=\"EDO_is.html#.subset\">EDO &rtrif; is.subset</a>"},{"title":"EDO#is.transposition","link":"<a href=\"EDO_is.html#.transposition\">EDO &rtrif; is.transposition</a>"},{"link":"<a href=\"EDO_midi.html\">midi</a>"},{"title":"EDO#midi.chordify","link":"<a href=\"EDO_midi.html#.chordify\">EDO &rtrif; midi.chordify</a>"},{"title":"EDO#midi.import","link":"<a href=\"EDO_midi.html#.import\">EDO &rtrif; midi.import</a>"},{"title":"EDO#midi.strip","link":"<a href=\"EDO_midi.html#.strip\">EDO &rtrif; midi.strip</a>"},{"link":"<a href=\"EDO_show.html\">show</a>"},{"title":"EDO#show.contour","link":"<a href=\"EDO_show.html#.contour\">EDO &rtrif; show.contour</a>"},{"title":"EDO#show.interval_fractal_tree","link":"<a href=\"EDO_show.html#.interval_fractal_tree\">EDO &rtrif; show.interval_fractal_tree</a>"},{"title":"EDO#show.necklace","link":"<a href=\"EDO_show.html#.necklace\">EDO &rtrif; show.necklace</a>"},{"title":"EDO#show.necklace_fractal","link":"<a href=\"EDO_show.html#.necklace_fractal\">EDO &rtrif; show.necklace_fractal</a>"},{"title":"EDO#show.nested_necklaces","link":"<a href=\"EDO_show.html#.nested_necklaces\">EDO &rtrif; show.nested_necklaces</a>"},{"link":"<a href=\"EDO_xml.html\">xml</a>"},{"link":"<a href=\"Scale_count.html\">count</a>"},{"title":"Scale#count.chord_quality","link":"<a href=\"Scale_count.html#.chord_quality\">Scale &rtrif; count.chord_quality</a>"},{"title":"Scale#count.consecutive_steps","link":"<a href=\"Scale_count.html#.consecutive_steps\">Scale &rtrif; count.consecutive_steps</a>"},{"title":"Scale#count.imperfections","link":"<a href=\"Scale_count.html#.imperfections\">Scale &rtrif; count.imperfections</a>"},{"title":"Scale#count.interval","link":"<a href=\"Scale_count.html#.interval\">Scale &rtrif; count.interval</a>"},{"title":"Scale#count.M3s","link":"<a href=\"Scale_count.html#.M3s\">Scale &rtrif; count.M3s</a>"},{"title":"Scale#count.m3s","link":"<a href=\"Scale_count.html#.m3s\">Scale &rtrif; count.m3s</a>"},{"title":"Scale#count.major_minor_triads","link":"<a href=\"Scale_count.html#.major_minor_triads\">Scale &rtrif; count.major_minor_triads</a>"},{"title":"Scale#count.modes","link":"<a href=\"Scale_count.html#.modes\">Scale &rtrif; count.modes</a>"},{"title":"Scale#count.P5s","link":"<a href=\"Scale_count.html#.P5s\">Scale &rtrif; count.P5s</a>"},{"title":"Scale#count.pitches","link":"<a href=\"Scale_count.html#.pitches\">Scale &rtrif; count.pitches</a>"},{"title":"Scale#count.rahn_ambiguities","link":"<a href=\"Scale_count.html#.rahn_ambiguities\">Scale &rtrif; count.rahn_ambiguities</a>"},{"title":"Scale#count.rahn_contradictions","link":"<a href=\"Scale_count.html#.rahn_contradictions\">Scale &rtrif; count.rahn_contradictions</a>"},{"title":"Scale#count.rahn_differences","link":"<a href=\"Scale_count.html#.rahn_differences\">Scale &rtrif; count.rahn_differences</a>"},{"title":"Scale#count.ratio","link":"<a href=\"Scale_count.html#.ratio\">Scale &rtrif; count.ratio</a>"},{"title":"Scale#count.rotational_symmetries","link":"<a href=\"Scale_count.html#.rotational_symmetries\">Scale &rtrif; count.rotational_symmetries</a>"},{"title":"Scale#count.simple_ratios","link":"<a href=\"Scale_count.html#.simple_ratios\">Scale &rtrif; count.simple_ratios</a>"},{"title":"Scale#count.tetrachords","link":"<a href=\"Scale_count.html#.tetrachords\">Scale &rtrif; count.tetrachords</a>"},{"title":"Scale#count.thirds","link":"<a href=\"Scale_count.html#.thirds\">Scale &rtrif; count.thirds</a>"},{"title":"Scale#count.transpositions","link":"<a href=\"Scale_count.html#.transpositions\">Scale &rtrif; count.transpositions</a>"},{"title":"Scale#count.trichords","link":"<a href=\"Scale_count.html#.trichords\">Scale &rtrif; count.trichords</a>"},{"link":"<a href=\"Scale_export.html\">export</a>"},{"title":"Scale#export.scala","link":"<a href=\"Scale_export.html#.scala\">Scale &rtrif; export.scala</a>"},{"link":"<a href=\"Scale_get.html\">get</a>"},{"title":"Scale#get.area","link":"<a href=\"Scale_get.html#.area\">Scale &rtrif; get.area</a>"},{"title":"Scale#get.chord_quality_from_shape","link":"<a href=\"Scale_get.html#.chord_quality_from_shape\">Scale &rtrif; get.chord_quality_from_shape</a>"},{"title":"Scale#get.coherence_quotient","link":"<a href=\"Scale_get.html#.coherence_quotient\">Scale &rtrif; get.coherence_quotient</a>"},{"title":"Scale#get.common_tone_transpositions","link":"<a href=\"Scale_get.html#.common_tone_transpositions\">Scale &rtrif; get.common_tone_transpositions</a>"},{"title":"Scale#get.complement","link":"<a href=\"Scale_get.html#.complement\">Scale &rtrif; get.complement</a>"},{"title":"Scale#get.coordinates","link":"<a href=\"Scale_get.html#.coordinates\">Scale &rtrif; get.coordinates</a>"},{"title":"Scale#get.generic_intervals","link":"<a href=\"Scale_get.html#.generic_intervals\">Scale &rtrif; get.generic_intervals</a>"},{"title":"Scale#get.interval_class","link":"<a href=\"Scale_get.html#.interval_class\">Scale &rtrif; get.interval_class</a>"},{"title":"Scale#get.interval_vector","link":"<a href=\"Scale_get.html#.interval_vector\">Scale &rtrif; get.interval_vector</a>"},{"title":"Scale#get.inversion","link":"<a href=\"Scale_get.html#.inversion\">Scale &rtrif; get.inversion</a>"},{"title":"Scale#get.least_step_multiplier","link":"<a href=\"Scale_get.html#.least_step_multiplier\">Scale &rtrif; get.least_step_multiplier</a>"},{"title":"Scale#get.lerdahl_attraction","link":"<a href=\"Scale_get.html#.lerdahl_attraction\">Scale &rtrif; get.lerdahl_attraction</a>"},{"title":"Scale#get.lerdahl_attraction_vector","link":"<a href=\"Scale_get.html#.lerdahl_attraction_vector\">Scale &rtrif; get.lerdahl_attraction_vector</a>"},{"title":"Scale#get.levenshtein","link":"<a href=\"Scale_get.html#.levenshtein\">Scale &rtrif; get.levenshtein</a>"},{"title":"Scale#get.modes","link":"<a href=\"Scale_get.html#.modes\">Scale &rtrif; get.modes</a>"},{"title":"Scale#get.motives_diatonic","link":"<a href=\"Scale_get.html#.motives_diatonic\">Scale &rtrif; get.motives_diatonic</a>"},{"title":"Scale#get.n_choose_k","link":"<a href=\"Scale_get.html#.n_choose_k\">Scale &rtrif; get.n_choose_k</a>"},{"title":"Scale#get.n_chords","link":"<a href=\"Scale_get.html#.n_chords\">Scale &rtrif; get.n_chords</a>"},{"title":"Scale#get.n_chords_diatonic","link":"<a href=\"Scale_get.html#.n_chords_diatonic\">Scale &rtrif; get.n_chords_diatonic</a>"},{"title":"Scale#get.name","link":"<a href=\"Scale_get.html#.name\">Scale &rtrif; get.name</a>"},{"title":"Scale#get.normal_order","link":"<a href=\"Scale_get.html#.normal_order\">Scale &rtrif; get.normal_order</a>"},{"title":"Scale#get.pairwise_generic_specific_intervals","link":"<a href=\"Scale_get.html#.pairwise_generic_specific_intervals\">Scale &rtrif; get.pairwise_generic_specific_intervals</a>"},{"title":"Scale#get.permutations","link":"<a href=\"Scale_get.html#.permutations\">Scale &rtrif; get.permutations</a>"},{"title":"Scale#get.pitches","link":"<a href=\"Scale_get.html#.pitches\">Scale &rtrif; get.pitches</a>"},{"title":"Scale#get.position_of_quality","link":"<a href=\"Scale_get.html#.position_of_quality\">Scale &rtrif; get.position_of_quality</a>"},{"title":"Scale#get.prime_form","link":"<a href=\"Scale_get.html#.prime_form\">Scale &rtrif; get.prime_form</a>"},{"title":"Scale#get.product","link":"<a href=\"Scale_get.html#.product\">Scale &rtrif; get.product</a>"},{"title":"Scale#get.quality_with_intervals","link":"<a href=\"Scale_get.html#.quality_with_intervals\">Scale &rtrif; get.quality_with_intervals</a>"},{"title":"Scale#get.resize_melody","link":"<a href=\"Scale_get.html#.resize_melody\">Scale &rtrif; get.resize_melody</a>"},{"title":"Scale#get.rotations","link":"<a href=\"Scale_get.html#.rotations\">Scale &rtrif; get.rotations</a>"},{"title":"Scale#get.rothenberg_propriety","link":"<a href=\"Scale_get.html#.rothenberg_propriety\">Scale &rtrif; get.rothenberg_propriety</a>"},{"title":"Scale#get.roughness","link":"<a href=\"Scale_get.html#.roughness\">Scale &rtrif; get.roughness</a>"},{"title":"Scale#get.sameness_quotient","link":"<a href=\"Scale_get.html#.sameness_quotient\">Scale &rtrif; get.sameness_quotient</a>"},{"title":"Scale#get.scale_degree_roles","link":"<a href=\"Scale_get.html#.scale_degree_roles\">Scale &rtrif; get.scale_degree_roles</a>"},{"title":"Scale#get.scale_degree_transpositions","link":"<a href=\"Scale_get.html#.scale_degree_transpositions\">Scale &rtrif; get.scale_degree_transpositions</a>"},{"title":"Scale#get.segments","link":"<a href=\"Scale_get.html#.segments\">Scale &rtrif; get.segments</a>"},{"title":"Scale#get.sequence_transposition","link":"<a href=\"Scale_get.html#.sequence_transposition\">Scale &rtrif; get.sequence_transposition</a>"},{"title":"Scale#get.shortest_path","link":"<a href=\"Scale_get.html#.shortest_path\">Scale &rtrif; get.shortest_path</a>"},{"title":"Scale#get.sine_pair_dissonance","link":"<a href=\"Scale_get.html#.sine_pair_dissonance\">Scale &rtrif; get.sine_pair_dissonance</a>"},{"title":"Scale#get.specific_intervals","link":"<a href=\"Scale_get.html#.specific_intervals\">Scale &rtrif; get.specific_intervals</a>"},{"title":"Scale#get.stacks","link":"<a href=\"Scale_get.html#.stacks\">Scale &rtrif; get.stacks</a>"},{"title":"Scale#get.step_sizes","link":"<a href=\"Scale_get.html#.step_sizes\">Scale &rtrif; get.step_sizes</a>"},{"title":"Scale#get.steps_to_qualities","link":"<a href=\"Scale_get.html#.steps_to_qualities\">Scale &rtrif; get.steps_to_qualities</a>"},{"title":"Scale#get.supersets","link":"<a href=\"Scale_get.html#.supersets\">Scale &rtrif; get.supersets</a>"},{"title":"Scale#get.tetrachords","link":"<a href=\"Scale_get.html#.tetrachords\">Scale &rtrif; get.tetrachords</a>"},{"title":"Scale#get.transposition","link":"<a href=\"Scale_get.html#.transposition\">Scale &rtrif; get.transposition</a>"},{"title":"Scale#get.transpositions_with_pitches","link":"<a href=\"Scale_get.html#.transpositions_with_pitches\">Scale &rtrif; get.transpositions_with_pitches</a>"},{"title":"Scale#get.trichords","link":"<a href=\"Scale_get.html#.trichords\">Scale &rtrif; get.trichords</a>"},{"title":"Scale#get.without","link":"<a href=\"Scale_get.html#.without\">Scale &rtrif; get.without</a>"},{"link":"<a href=\"Scale_is.html\">is</a>"},{"title":"Scale#is.deep","link":"<a href=\"Scale_is.html#.deep\">Scale &rtrif; is.deep</a>"},{"title":"Scale#is.distributionally_even","link":"<a href=\"Scale_is.html#.distributionally_even\">Scale &rtrif; is.distributionally_even</a>"},{"title":"Scale#is.in_lower_edos","link":"<a href=\"Scale_is.html#.in_lower_edos\">Scale &rtrif; is.in_lower_edos</a>"},{"title":"Scale#is.invertible","link":"<a href=\"Scale_is.html#.invertible\">Scale &rtrif; is.invertible</a>"},{"title":"Scale#is.maximally_even","link":"<a href=\"Scale_is.html#.maximally_even\">Scale &rtrif; is.maximally_even</a>"},{"title":"Scale#is.mode_of","link":"<a href=\"Scale_is.html#.mode_of\">Scale &rtrif; is.mode_of</a>"},{"title":"Scale#is.MOLT","link":"<a href=\"Scale_is.html#.MOLT\">Scale &rtrif; is.MOLT</a>"},{"title":"Scale#is.myhill_property","link":"<a href=\"Scale_is.html#.myhill_property\">Scale &rtrif; is.myhill_property</a>"},{"title":"Scale#is.normal_order","link":"<a href=\"Scale_is.html#.normal_order\">Scale &rtrif; is.normal_order</a>"},{"title":"Scale#is.one_of","link":"<a href=\"Scale_is.html#.one_of\">Scale &rtrif; is.one_of</a>"},{"title":"Scale#is.prime_form","link":"<a href=\"Scale_is.html#.prime_form\">Scale &rtrif; is.prime_form</a>"},{"title":"Scale#is.subset","link":"<a href=\"Scale_is.html#.subset\">Scale &rtrif; is.subset</a>"},{"link":"<a href=\"Scale_show.html\">show</a>"},{"title":"Scale#show.interval_fractal_tree","link":"<a href=\"Scale_show.html#.interval_fractal_tree\">Scale &rtrif; show.interval_fractal_tree</a>"},{"title":"Scale#show.necklace","link":"<a href=\"Scale_show.html#.necklace\">Scale &rtrif; show.necklace</a>"},{"link":"<a href=\"Scale_to.html\">to</a>"},{"title":"Scale#to.cents","link":"<a href=\"Scale_to.html#.cents\">Scale &rtrif; to.cents</a>"},{"title":"Scale#to.steps","link":"<a href=\"Scale_to.html#.steps\">Scale &rtrif; to.steps</a>"},{"link":"<a href=\"Time_convert.html\">convert</a>"},{"title":"Time#convert.beats_to_msec","link":"<a href=\"Time_convert.html#.beats_to_msec\">Time &rtrif; convert.beats_to_msec</a>"},{"title":"Time#convert.beats_to_ratios","link":"<a href=\"Time_convert.html#.beats_to_ratios\">Time &rtrif; convert.beats_to_ratios</a>"},{"title":"Time#convert.beats_to_tempo","link":"<a href=\"Time_convert.html#.beats_to_tempo\">Time &rtrif; convert.beats_to_tempo</a>"},{"link":"<a href=\"Time_get.html\">get</a>"},{"title":"Time#get.beat","link":"<a href=\"Time_get.html#.beat\">Time &rtrif; get.beat</a>"},{"title":"Time#get.counterpoint_cycle","link":"<a href=\"Time_get.html#.counterpoint_cycle\">Time &rtrif; get.counterpoint_cycle</a>"},{"title":"Time#get.explicit","link":"<a href=\"Time_get.html#.explicit\">Time &rtrif; get.explicit</a>"},{"title":"Time#get.fractal","link":"<a href=\"Time_get.html#.fractal\">Time &rtrif; get.fractal</a>"},{"title":"Time#get.motives","link":"<a href=\"Time_get.html#.motives\">Time &rtrif; get.motives</a>"},{"title":"Time#get.ratios","link":"<a href=\"Time_get.html#.ratios\">Time &rtrif; get.ratios</a>"},{"title":"Time#get.relational_motives","link":"<a href=\"Time_get.html#.relational_motives\">Time &rtrif; get.relational_motives</a>"},{"title":"Time#get.repeated","link":"<a href=\"Time_get.html#.repeated\">Time &rtrif; get.repeated</a>"},{"title":"Time#get.subdivisions","link":"<a href=\"Time_get.html#.subdivisions\">Time &rtrif; get.subdivisions</a>"},{"link":"<a href=\"Time_resize.html\">resize</a>"},{"title":"Time#resize.by_product","link":"<a href=\"Time_resize.html#.by_product\">Time &rtrif; resize.by_product</a>"},{"title":"Time#resize.by_sum","link":"<a href=\"Time_resize.html#.by_sum\">Time &rtrif; resize.by_sum</a>"},{"title":"environment","link":"<a href=\"global.html#environment\">Global &rtrif; environment</a>"},{"title":"myhill_property","link":"<a href=\"global.html#myhill_property\">Global &rtrif; myhill_property</a>"}];
setupSearch(list)
</script>

 
<script type="text/javascript" src="scripts/misc.js"></script>
</body>
</html>
